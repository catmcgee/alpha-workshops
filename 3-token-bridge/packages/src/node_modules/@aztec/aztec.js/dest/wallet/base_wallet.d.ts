/// <reference types="node" resolution-mode="require"/>
import { type AuthWitness, type ExtendedNote, type FunctionCall, type GetUnencryptedLogsResponse, type L2Block, type LogFilter, type NoteFilter, type PXE, type SyncStatus, type Tx, type TxEffect, type TxExecutionRequest, type TxHash, type TxReceipt } from '@aztec/circuit-types';
import { type AztecAddress, type CompleteAddress, type Fr, type GrumpkinPrivateKey, type PartialAddress } from '@aztec/circuits.js';
import { type ContractArtifact } from '@aztec/foundation/abi';
import { type ContractClassWithId, type ContractInstanceWithAddress } from '@aztec/types/contracts';
import { type NodeInfo } from '@aztec/types/interfaces';
import { type Wallet } from '../account/wallet.js';
import { type ContractFunctionInteraction } from '../contract/contract_function_interaction.js';
import { type FeeOptions } from '../entrypoint/entrypoint.js';
/**
 * A base class for Wallet implementations
 */
export declare abstract class BaseWallet implements Wallet {
    protected readonly pxe: PXE;
    constructor(pxe: PXE);
    abstract getCompleteAddress(): CompleteAddress;
    abstract getChainId(): Fr;
    abstract getVersion(): Fr;
    abstract createTxExecutionRequest(execs: FunctionCall[], fee?: FeeOptions): Promise<TxExecutionRequest>;
    abstract createAuthWit(messageHashOrIntent: Fr | Buffer | {
        /** The caller to approve  */
        caller: AztecAddress;
        /** The action to approve */
        action: ContractFunctionInteraction | FunctionCall;
        /** The chain id to approve */
        chainId?: Fr;
        /** The version to approve  */
        version?: Fr;
    }): Promise<AuthWitness>;
    getAddress(): AztecAddress;
    getContractInstance(address: AztecAddress): Promise<ContractInstanceWithAddress | undefined>;
    getContractClass(id: Fr): Promise<ContractClassWithId | undefined>;
    addCapsule(capsule: Fr[]): Promise<void>;
    registerAccount(privKey: GrumpkinPrivateKey, partialAddress: PartialAddress): Promise<CompleteAddress>;
    registerRecipient(account: CompleteAddress): Promise<void>;
    getRegisteredAccounts(): Promise<CompleteAddress[]>;
    getRegisteredAccount(address: AztecAddress): Promise<CompleteAddress | undefined>;
    getRecipients(): Promise<CompleteAddress[]>;
    getRecipient(address: AztecAddress): Promise<CompleteAddress | undefined>;
    registerContract(contract: {
        /** Instance */ instance: ContractInstanceWithAddress;
        /** Associated artifact */ artifact?: ContractArtifact;
    }): Promise<void>;
    registerContractClass(artifact: ContractArtifact): Promise<void>;
    getContracts(): Promise<AztecAddress[]>;
    simulateTx(txRequest: TxExecutionRequest, simulatePublic: boolean): Promise<Tx>;
    sendTx(tx: Tx): Promise<TxHash>;
    getTxEffect(txHash: TxHash): Promise<TxEffect | undefined>;
    getTxReceipt(txHash: TxHash): Promise<TxReceipt>;
    getNotes(filter: NoteFilter): Promise<ExtendedNote[]>;
    getNoteNonces(note: ExtendedNote): Promise<Fr[]>;
    getPublicStorageAt(contract: AztecAddress, storageSlot: Fr): Promise<any>;
    addNote(note: ExtendedNote): Promise<void>;
    getBlock(number: number): Promise<L2Block | undefined>;
    viewTx(functionName: string, args: any[], to: AztecAddress, from?: AztecAddress | undefined): Promise<any>;
    getUnencryptedLogs(filter: LogFilter): Promise<GetUnencryptedLogsResponse>;
    getBlockNumber(): Promise<number>;
    getNodeInfo(): Promise<NodeInfo>;
    isGlobalStateSynchronized(): Promise<boolean>;
    isAccountStateSynchronized(account: AztecAddress): Promise<boolean>;
    getSyncStatus(): Promise<SyncStatus>;
    addAuthWitness(authWitness: AuthWitness): Promise<void>;
    getAuthWitness(messageHash: Fr): Promise<Fr[] | undefined>;
    isContractClassPubliclyRegistered(id: Fr): Promise<boolean>;
    isContractPubliclyDeployed(address: AztecAddress): Promise<boolean>;
}
//# sourceMappingURL=base_wallet.d.ts.map