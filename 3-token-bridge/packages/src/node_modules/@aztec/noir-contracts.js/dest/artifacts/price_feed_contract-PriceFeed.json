{ "noir_version": "0.25.0+d1ed549202e5a840845298c931418e173eb5437c", "name": "PriceFeed", "functions": [{ "name": "set_price", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "asset_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "price", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "asset_id": [{ "start": 37, "end": 38 }], "inputs": [{ "start": 0, "end": 37 }], "price": [{ "start": 38, "end": 39 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240] }, "bytecode": "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", "debug_symbols": "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DjfHc7g5nsPN8RxujudwczyHm+M53BzP4eZ4DjfHc7g5nsPN8RxujudwczyHm+M53BzP4eZ4DjfHc7g5nsPN8RxujudwczyHm+M53BzP4eZ4DjfHc7g5nsPN8RxujudwczyHm+M53BzP4eZ4Djf77p8iMDsun5+Xz6/L5/fl8+fy+evy+Xf/FJD1PJfPt8vn++Xz4/L5efn8unx+Xz5/Lp+/Lp9/uX/tcv/a5f61y/1rl/vXLvevXe7fz/1VHh1vf6RZ189/0qjZe5/1mW+fjefnc6PeChmVQpZKIVukkM/9FR6/ZSGmUoirFBIqhaRKIaVSiEqyukqyukqyukqyhkqyhkqyhkqyhkqyhkqyhkqyhkqyhkqyhkqyhkqypkqypkqypkqypkqypkqypkqypkqypkqypkqypkqylkqylkqylkqylkqylkqylkqylkqylkqylkqylkqytkqytkqytkqytkqy9qVk/XZ6XT29r54+V09fV0/fN0+f5+rpdvV0v3p6XD39aq/O1V6dq706V3t1rvbqXO3VdbVX19VeXVd7dV3t1XW1V9fVXl1Xe3Vd7dX1uV7tejt99ud+YbW2SCH7USnEVApxlUJCpZBUKaRUCmmVQkalEJVk3SLJuh+RZN2PSLLuRyRZ9yOSrPsRSdb9iCTrfkSSdT8iybofkWTdj0qymkqymkqymkqymkqymkqymkqymkqymkqymkqymkqyukqyukqyukqyukqyukqyukqyukqyukqyukqyukqyhkqyhkqyhkqyhkqyhkqyhkqyhkqyhkqyhkqyhkqypkqypkqypkqypkqypkqypkqypkqypkqypkqypkqylkqylkqylkqylkqylkqylkqylkqylkqylkqylkqytkqytkqytkqytkqytkqytkqytkqytkqytkqytkqyjkqyjkqyjkqyjkqyjkqyjkqyjkqyjkqyjkqyjkqyLpVkXSrJulSSdakk61JJ1qWSrEslWZdKsqrsYG2VHaytsoO1VXawtsoO1lbZwdoqO1hbZQdrq+xgbZUdrK2yg7VVdrDsUVnCelUikq2vSkTC9VWJSLq+KhGJ11clIvn6qkQkYF+ViCTsqxKRiH1VIpOxKutYr0pkMlZlIetViUzGqqxkvSqRyViVpaxXJTIZq7KW9apEJmNVFrNelchkrMpq1qsSmYxVWc56VSKT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" }, { "name": "fetch_price", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "assetId", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "assetId": [{ "start": 0, "end": 1 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "asset::Asset", "fields": [{ "name": "price", "type": { "kind": "struct", "path": "std::uint128::U128", "fields": [{ "name": "lo", "type": { "kind": "field" } }, { "name": "hi", "type": { "kind": "field" } }] } }] }, "visibility": "public" }, "return_witnesses": [1, 2] }, "bytecode": "H4sIAAAAAAAA/81XzY7TMBC2k7RNmu2mPSIE8hOsnIUbHAI8ABLcuFRZmqJKbSMlqVh4+BV1O8N+GGv5qaPtSO2Mx5OZbz47TiLFUYL9T5Idgo3CvoK0Pk1yj7l04MBpfJ/IjmG+8FX3pX4xNEmiX+uypIRBQMyIfjwvo3usP6+J7tfByMwRZ/oZ+O5H6+sU6tp8In8sA8AT+ceT99SnNnmHlOvOI17D1cjiKrS4uoSYIfA36oE/CXU5N4+53r9iDs4AM+4LJfzui9h/T9fZPkcCvMYWv9jXmGyP+1ILqs81ud4Y6l6QLT3WNblSyhVRbsZxAX6OeU56Ko57Tjj4SfyvT/7QGcf1EI88AzypcD9zEoszfA7h3HuYn5CNzyHuN3TknoCP1+7ScS3yNIFeCrL1aXLgCWsVMJ6AlhbGx8YzcuDp6yzl9eHcPB6dSe0e1uFwjmc99TSlXAPKy/i5XgQxr0mbMV7LuOz7CfcGxwZg89wdcZfBuPjLHpd/EJNjBvWmjv54/h1gdeEsyJ9BHOPFMb6DcGwMdU54Fua2A/GFgGEGdaeA/z/r/oYD7wc+G1KLBzxPM/A9dKanoPmsTkDH4Pf5rovv0D55Mn3wt4QAvlAKsPEduodvhXwMHLdd3ZRfqg9VuZAALbJgopaONgLwoR06fILKc5sR+Hg7DMAXWLTgtuD4RDg+8QvS+jQ57PPQalg4GpZku2Kfkebz8+ORd9Wu605ptd3/l+t1/bVaXCmca9Vm13aq7cqmU8um3qj8CvO+Iv2E9JumKb+p1XZR3ap616l6qW7q3XbR4kVvST8l/XlfWnW1Ktu2arr5pryd36y6ebv6Xokfpso9nFERAAA=", "debug_symbols": "5drdasJAEAXgd9lrKTM7s3++SulFai0IoqK2UMR3byTJmmJQmlY5IXeGzGa/CXrWDTmY5XpW7Bfr1c5MD4aegpk+H8xuU6xOx7t9sd2bafAyMfPVW/kppuPEvC+WczO1iY6Ti9rErq5NPuZa31UaRLi5riR3vjDx8WVSYiISJiFhmKA0DKWxUBqB0iiUxkFpPJQGKokZKooZKostVBZbqCy2UFlsobLY/jmLmbQpZia67qG6km5c1IdYV/qW2kuNdkNE+yGiwxDRcYjoNEC03Fp1kr+FZg4ZrbE9w2WxBFvXKksuZQq1hqE0FkojUBqF0jgojYfSBChNhNIkJI1CZbFCZbFCZbFCZbFCZbFCZbFCZbFCZbFCZbFCZbGDymJ3zyyuZrB3n+EfMtPFPEOk63f0SnHFUSyOeyhHffNQSUNrA1nuUCuNh9IEKE2E0iQkjScoDUNp7GM1mleUwD80HauPkK+LRcTmatWuB9IZEZKeL0x1lzKKLnUUXbpRdOlH0WUA7tJx7tKldpcVPQ6XnoDpMWZ66wvT0AMh05udhijJJZ2HS0f5k1BpUBbzStP5Y7I+31DSy51zpD6DuM8g22eQ9BmkvxxUHn0W20Xxupyf3s88nfxYzZrXNcvD/demOnP8Bg==" }, { "name": "get_price", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "asset_id", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "asset_id": [{ "start": 37, "end": 38 }], "inputs": [{ "start": 0, "end": 37 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239] }, "bytecode": "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", "debug_symbols": "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LYCHWwAPtwAebgE83AJ4uAXwcAvg4RbAwy2Ah1sAD7cAHm4BPNwCeLgF8HAL4OEWwMMtgIdbAA+3AB5uATzcAni4BfBwC+DhFsDDLYCHWwAPtwAebgE83AJ4uAXwcAHwcAHwcAHwcAHwcPEE0COBHgX0aKDHBnoAOgd4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAB4uAR4uAR4uAR4uAR4uHwC6JFAjwJ6NNBjAz0AnQM8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAI8XAE8XAE8XAE8XAE8XD0B9EigRwE9GuixgR6AzgEergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAergAe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" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2YzU7DMAyA0x/W/zJgsPIn9chxlXbYsQ/BC0yjErtsaC08PqLeYtXNGBfcg6VZipKmafLZSRM7ljrIY5ssXXbadKGOBd+XOp/9TwrGvmZDclpCOG0hnA4jJ7BN1LDr1B3ArtyMFwIYRwIYPQGMvgDGQABjKIAxEsAYC2BMBDCmAhgvBTCOBTBeCWC8FsB4I4BxIoDxVgDjnQDGKSOjRRhdXc7adN+mB3WI2Re63ledlFwM82IFPjsOnqm+gG9i44Pb1TnITeqQ3yZ1eMfguJ0OI3YdZnPo1+PuV8cKGbG/y2//hU/sxMg+lE32axbXIsakHnlGWwW6zHi3UtCxLZ0CMqbSc4TlKWmL7dAeuK6RHfxHXJvBH9+5xncpaTP6Rf9S8ervGTyewQxzEOsy+CCZ29nFZOO894J+Q/5+e3PuGnMSknps86zzsa6L+edhHqn+fow6UylJOSa2j/h5ioH03M9povv6Vrx7SGrYyjdslZI2CbFfOoD9LDIu9k05QM7MZ+ZTzJHq/+NYR99jbhu6UH8K2wfqeD9hVQgHpA6fpeHgHWyocJDAgeap7tAIibKJBoYLA9hs4bCBgBICNgiIIOAAh35Kxjjl5FJHGOVJ5y86f31f1/lqu2l2y1WTv22rOt9sm/yzrvKP3fpr2VTwXNXqB8Nw3LryGgAA", "debug_symbols": "nZBLCoAgFEX38sYSEX3dSjR4mYEgKmpBiHtPkRaQs/vhTE4AqRl6oZUDGqBtuh7oGsAZVHlwHq0H2s0DAa6OlJY2EjiF5CVvJENDDTTWQFMNNP+EUrvRCtwlz1ryeSn2WUrVP6Y88QU=" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "35": { "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n", "path": "std/option.nr" }, "44": { "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\n\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else if ascii < 71 {\n            ascii - 55\n        } else {\n            ascii - 87\n        } as Field\n    }\n\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if self < b {\n            (U128::from_u64s_le(0, 0), self)\n        } else {\n            //TODO check if this can overflow?\n            let (q,r) = self.unconstrained_div(b * U128::from_u64s_le(2, 0));\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::from_u64s_le(1, 0), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64))as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift left with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift right with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n", "path": "std/uint128.nr" }, "60": { "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr" }, "63": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T> Storage<T> for PublicMutable<T> {}\n\nimpl<T> PublicMutable<T> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable reads only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "107": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "201": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "289": { "source": "use dep::aztec::protocol_types::traits::{Serialize, Deserialize};\n\nstruct Asset {\n    price: U128,\n}\n\nglobal ASSET_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn serialize(asset: Asset) -> [Field; ASSET_SERIALIZED_LEN] {\n        [asset.price.to_integer()]\n    }\n}\n\nimpl Deserialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn deserialize(fields: [Field; ASSET_SERIALIZED_LEN]) -> Asset {\n        let price = U128::from_integer(fields[0]);\n        Asset { price }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/price_feed_contract/src/asset.nr" }, "290": { "source": "mod asset;\n\ncontract PriceFeed {\n    use dep::aztec::prelude::{AztecAddress, FunctionSelector, PrivateContext, Map, PublicMutable};\n    use dep::aztec::{context::{PublicContext, Context}};\n    use crate::asset::Asset;\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    struct Storage {\n        assets: Map<Field, PublicMutable<Asset>>,\n    }\n\n    #[aztec(public)]\n    fn set_price(asset_id: Field, price: Field) {\n        let asset = storage.assets.at(asset_id);\n        asset.write(Asset { price: U128::from_integer(price) });\n    }\n\n    #[aztec(public)]\n    fn get_price(asset_id: Field) -> Asset {\n        storage.assets.at(asset_id).read()\n    }\n\n    unconstrained fn fetch_price(assetId: Field) -> pub Asset {\n        storage.assets.at(assetId).read()\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/price_feed_contract/src/main.nr" } } }
