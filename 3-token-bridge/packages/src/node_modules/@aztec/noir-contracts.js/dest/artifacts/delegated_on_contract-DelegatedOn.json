{ "noir_version": "0.25.0+d1ed549202e5a840845298c931418e173eb5437c", "name": "DelegatedOn", "functions": [{ "name": "view_private_value", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "amount", "type": { "kind": "field" }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "amount": [{ "start": 0, "end": 1 }], "owner": [{ "start": 1, "end": 2 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [2] }, "bytecode": "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", "debug_symbols": "zf3djq5Zdp7pnQu3CSPG/xg6FcMbdFsGBAhUo0UbMASdu1PoyiyqO1Yzn5v5BeYWs1A5+EblvN+5Vl4rxhf/7R/+83/5X/7pX/7Tf/nn//oP/+G//cPX/23+4T/83//bP/zX//Wf/vl//Of/+i//9L/9yz/8h69//If/+M//r9/+73//x3/4f/+n//wf/+E/eOd//8f/09936X/7O6/6j7/X7Oubv9dn/vb3xtff//9G/ff/xz/+9mXsG1/GvfFl2NcjX4c98nX4I19HPPJ15CNfRz3ydfQjX8cjt6k9cp3aI/epP3Kf+iP3qT9yn/oj96k/cp/6I/epP3Kf+iP3qT9yn/oj92k8cp/GI/dpPHKfxiP3aTxyn8Yj92k8cp/GI/dpPHKfxiP3aT5yn+Yj92k+cp/mI/dpPnKf5iP3aT5yn+Yj92k+cp/mI/dpPXKf1iP3aT1yn9Yj92k9cp/WI/dpPXKf1iP3aT1yn9Yj92k/cp/2I/dpP3Kf9iP3aT9yn/Yj92k/cp/2I/dpP3Kf9iP36Txyn84j9+k8cp/OI/fpPHKfziP36Txyn84j9+k8cp/OI/fpPnKf7iP36T5yn+4j9+k+cp/uI/fpPnKf7ivfffrIfbqP3Kf3yH16j9yn98h9eo/cp/fIfXqP3Kf3yH16j9yn98q38z/z/fyvfEP/1yvf0f/1yrf0f73yPf1fj1yq9vXKd/V/vfJt/V+vfF//1yvf2P/1ys36zqrUKzfrM8tSz2xLPbMu9cy+1DMLU89sTD2zMvXKzpS9sjRlr2xN2StrU/bK3pS9sjhlr2xO2SurU/bK7pS9sjxlr2xP2SvrU/bK/pS9skBlr2xQ2SsrVPbKDpW9skRlr2xR2StrVPbKHpW9skhlr2xS2SurVPbKLpW9skxlr2xT2SvrVPbKPpW9slBlr2xU2SsrVfbKTpW9slRlr2xV2StrVfbKXpW9slhlr2xW2SurVfbKbpW9slxlr2xX2SvrVfbKfpW9smBlr2xY2SsrVvbKjpW9smRlr2xZ2StrVvbKnpW9smhlr2xa2SurVvbKrpW9smxlr2xb2SvrVvbKvpW9snBlr2xc2SsrV/bKzpW9snRlr2xd2StrV/bK3pW9snhlr2xe2SurV/bK7pW9snxlr2xf2SvrV/bK/pW9soBlr2xg2SsrWPbKDpa/soPlr+xg+Ss7WP7KDpZ/PXKz+is7WP7KDpa/soPlr+xg+Ss7WP7KDpa/soPlr+xg+Ss7WP7KDpa/soPlr+xg+Ss7WP7KDpY/83OrnvnBVe/85KpXbtZnfnbVMz+86pmfXvXMj6965udXPfMDrF7ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR0sf2UHy1/ZwfJXdrD8lR2seGUHK17ZwYpXdrDilR2s+HrkZo1XdrDilR2s+HfuYPXv/89v7d/5hewrX8g98oX8O3ew/sIvxF75QvyVLyRe+ULylS+kXvlC+pUv5JWb1V65We2Vm9VfuVn9lZvVX7lZ/ZWb1V+5Wf2Vm9VfuVn9lZvVX7lZ/ZWbNV65WeOVmzVeuVnjlZs1XrlZ45WbNV65WeOVmzVeuVnjlZs1X7lZ85WbNV+5WfOVmzVfuVnzlZs1X7lZ85WbNV+5WfOVm7VeuVnrlZu1XrlZ65WbtV65WeuVm7VeuVnrlZu1XrlZ65WbtV+5WfuVm7VfuVn7lZu1X7lZ+5WbtV+5WfuVm7VfuVn7lZt1XrlZ55WbdV65WeeVm3VeuVnnlZt1XrlZ55WbdV65WeeVm3VfuVn3lZt1X7lZ95WbdV+5WfeVm3VfuVn3lZt1X7lZ95Wb9V65We+Vm/VeuVnvlZv1XrlZ75Wb9V65We+Vm/VeuVnvkZs1vx65WfPrkZs1vx65WfPrkZs1vx65WfPrkZs1vx65WfOVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax8ZQcrX9nByld2sPKVHax6ZQerXtnBqld2sOqVHaz6euRmrVd2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerXtnBqld2sOqVHax6ZQerlR2sv02YPOHyRMgTKU+UPNHyxMgTK0+cOmHymZt85iafuclnbvKZm3zmJp+5yWdu8pmbfOYun7nLZ+7ymbt85i6fuctn7vKZu3zmLp+5y2ce8pmHfOYhn3nIZx7ymYd85iGfechnHvKZh3zmKZ95ymee8pmnfOYpn3nKZ57ymad85imfecpnXvKZl3zmJZ95yWde8pmXfOYln3nJZ17ymZd85i2fectn3vKZt3zmLZ95y2fe8pm3fOYtn3nLZz7ymY985iOf+chnPvKZj3zmI5/5yGc+8pmPfOYrn/nKZ77yma985iuf+cpnvvKZr3zmK5/5ymd+8pmffOYnn/nJZ37ymZ985ief+clnfvKZn3rmIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexw9iVD3G8jpo+4PhL6SOojpY+0PjL6yOoj+umbfvqmn77pp2/66Zt++qafvumnb/rpm376pp++66fv+um7fvqun77rp+/66bt++q6fvuun7/rph376oZ9+6Kcf+umHfvqhn37opx/66Yd++qGffuqnn/rpp376qZ9+6qef+umnfvqpn37qp5/66Zd++qWffumnX/rpl376pZ9+6adf+umXfvqln37rp9/66bd++q2ffuun3/rpt376rZ9+66ff+umPfvqjn/7opz/66Y9++qOf/uinP/rpj376o5/+6qe/+umvfvqrn/7qp7/66a9++quf/uqnv/rpn376p5/+6ad/+umffvqnn/7pp3/66Z9++rr1mW59pluf6dZnuvX99rtefaT0kdZHRh9ZfUQ/fd36TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936TrY+/5Kt77cR00dcHwl9JPWR0kdaHxl9ZPUR/fRNP33TT9/00zf99E0/fdNP3/TTN/30TT9900/f9dN3/fRdP33XT9/103f99F0/fddP3/XTd/30Qz/90E8/9NMP/fRDP/3QTz/00w/99EM//dBPP/XTT/30Uz/91E8/9dNP/fRTP/3UTz/100/99Es//dJPv/TTL/30Sz/90k+/9NMv/fRLP/3ST7/102/99Fs//dZPv/XTb/30Wz/91k+/9dNv/fRHP/3RT3/00x/99Ec//dFPf/TTH/30Rz/90U9/9dNf/fRXP/3VT3/101/99Fc//dVPf/XTX/30Tz/900//9NM//fRPP/3TT//00z/99E8/fd36TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpctz7Xrc9163Pd+n77E259pPSR1kdGH1l9RD993fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOuL763PfvtzzL9N2W+C+O1g0MGkg0UHmw4OHVw6eHDwexv8M4NGB2k5RcspWk7RcoqWU7ScouUULadpOU3LaVpO03KaltO0nKblNC2naTlNyxlaztByhpYztJyh5QwtZ2g5Q8sZWs7QcpaWs7ScpeUsLWdpOUvLWVrO0nKWlrO0nKPlHC3naDlHyzlaztFyjpZztJyj5RwsJ7++6KDRQaeDQQeTDhYdbDo4dHDpIC3HaDlGyzFajtFyjJZjtByj5Rgtx2g5RstxWo7TcpyW47Qcp+U4LcdpOU7LcVqO03KClhO0nKDlBC0naDlBywlaTtBygpYTtJyk5SQthxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0MeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR805PiChvzboNFBp4NBB5MOFh1sOjh0cOkgLcdoOUbLMVqO0XKMlmO0HKPlGC3HaDlGy3FajtNynJbjtByn5Tgtx2k5TstxWo7TcoKWE7ScoOUELSdoOUHLCVpO0HKClhO0nKTlJC0naTlJy0laTtJykpaTtJyk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uwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u4x360v5ru/zRmcczgXcC7hXMG5hnMD5xbOwV4M9mKwF4O9GOzFYC8GezHYi8FeDPZisBeHvTjsxWEvDntx2IvDXhz24rAXh7047CVgLwF7CdhLwF4C9hKwl4C9BOwlYC8Be0nYS8JeEvaSsJeEvSTsJWEvCXtJ2EvCXgr2UrCXgr0U7KVgLwV7KdhLwV4K9lKwl4a9NOylYS8Ne2nYS8NeGvbSsJeGvTTsZWAvA3sZ2MvAXgb2MrCXgb0M7GVgLwN7WdjLwl4W9rKwl4W9LOxlYS8Le1nYy8JeDvZysJeDvRzs5WAvB3s52MvBXg72An3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2E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DdmoIRs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0MOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0MeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxry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" }, { "name": "private_set_value", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "new_value", "type": { "kind": "field" }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "new_value": [{ "start": 33, "end": 34 }], "owner": [{ "start": 34, "end": 35 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263] }, "bytecode": "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", "debug_symbols": "7VjbattAEP2XfTZibjs7618pfVBTFwzGCbFbKMb/XinyrmR7qZACTmzyZITOWZ05mpt1cJvnp3q/ft7u3PLgENzy28HtXupte7nb1697t4SFW21/Nr/Hhfu13qzcklSOiysc+nhComHGWihACS1hiUT7gwEL6MCMJ3Tg6M/Q3xcO8S5V061UM3FSzcbvVM3vUe1R7QT1BNbrplKIAJRiBOqDRM8FtETKJ4ceK/amWu5Stb9L1VpS7S3loKIfUd6kWlJOQNKjpUvBUHqAkk8PCDRWPKiSomXojdSSNSYJa9YfjGhF5TE3CKTec6RSqVlInkTwI1jMKgjOHZlewvYg/kXVnLOoI+AxU+KXKVemENzUFITcsRBjPLOlVYMfpqbx/UoN3VYN5ZOR1EZSRryk9ype47D3t9L5fqXLjaXHnAMsPCId1eej1WCkS0ueiJ77yovwFqZ/mDADJnAYbMxNmIXWJSGX/2DIoYQZrUsfxkHN21ZQ+b+DGBXyqEA4W82mWxgeJwlDyiyDcFlr9qnDjOmF4nBJLIfJIea9fLDw+24tr4pNJe8WOJhx0Xfjvyp/EMjWB7tczlsOzuAUp6nPvUNhMICb3nBi8SyWTGdJVV4QWdLL5GiXiSVVeYEaI+EcEs0h8WSSVeXZ5DnZ5wf10qVeS9I5pHIDYsi1PPijCppYxXo24MySEitOZDVXf+rXdf1js2o/nbU3f2+f0pe05nL/96W7c/wH" }, { "name": "public_set_value", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "new_value", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 37 }], "new_value": [{ "start": 37, "end": 38 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239] }, "bytecode": "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", "debug_symbols": "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vSqRyViVNa1XJTIZq7Ko9apEJmNVVrVelchkrMqy1qsSmYxVWdd6VSKTsSoLW69KZDJWZWXrVYlMxqosbb0qkclYlbWtVyUyGauyuPWqRCZjVVa3XpXIZKzK8tarEpmMVVnfelUik7EqC1yvSmQyVmWF61WJTMaqLHG9KpHJWJU1rlclMhmrssj1qkQmY1VWuV6VyGSsyjLXqxKZjFVZ53pVIpOxKgtdr0pkMlZlpetViUzGqix1vSqRyViVta5XJTIZq7LY9apEJmNVVrtelchkrMpy16sSmYxVWe96VSKTsSoLXq9KZDJWZcXrVYlMxqoseb0qkclYlTWvVyUqGWsye14ms+dlMnteJrPn9fplWplKVDLWZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rzsg3teZ335yX7qnyp5O37fPf5cPf6Da1Y/ebzdPX7dPd7vHh93j8+7x9fd4+927b7btftu1567XXvudu2527Xnbteeu1177nbtudu1527Xnrtde6527Xqeu8d/qGt/4p+i1sd2Nn7ydL96elw9Pa+eXldP76un76unn5unf2yn4CdPv9qrdrVX7Wqv2tVetau9ald71a72ql3tVbvaq+tqr66rvbqu9uq62qvraq9+zG//3J/bO7785Hns68/W+lpFSVTRElVsiSqOQhUfs9q/WhUmUcWSqMIlqgiJKiSy0yWy0yWy0yWy0yWyMySyMySyMySyMySyMySyMySyMySyMySyMySyM5DsrN5ffrJOfqvC36rIR6IKk6hiSVThElWERBUpUUVJVNESVWyJKiSysySysySysySysySysySysySysySysySysySysySysyWysyWysyWysy9k59vRce/ovHd03Tu67x297x19rh29n3tH272j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nAEezgAPZ4CHM8DDGeDhDPBwBng4AzycAR7OAA9ngIczwMMZ4OEM8HAGeDgDPJwBHs4AD2eAhzPAwxng4QzwcAZ4OAM8nAEezgAPZ4CHM8DDGeDhDPBwBng4AzycAR7OAA9ngIczwMMZ4OEM8HAGeDgDPJwBHs4AD2eAhzPAwxng4QzwcAZ4OAM8nAEezgAPZ4CHM8DDGeDhDPBwBng4AzycAR7OAA9ngIczwMMZ4OEM8HAGeDgDPJwBHs4AD2eAhzPAwxng4QzwcAZ4OAM8nAEezgAPZ4CHM8DDGeDhDPBwC/BwC/BwC/BwC/Bw6wngjgTuKOCOBu7YwB1AnwMebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEebgEezgEP54CHc8DDOeDh/AngjgTuKOCOBu7YwB1AnwMezgEP54CHc8DDOeDhHPBwDng4BzycAx7OAQ/ngIdzwMM54OEc8HAOeDgHPJwDHs4BD+eAh3PAwzng4RzwcA54OAc8nAMezgEP54CHc8DDOeDhHPBwDng4BzycAx7OAQ/ngIdzwMM54OEc8HAOeDgHPJwDHs4BD+eAh3PAwzng4RzwcA54OAc8nAMezgEP54CHc8DDOeDhHPBwDng4BzycAx7OAQ/ngIdzwMM54OEc8HAOeDgHPJwDHs4BD+eAh3PAwzng4RzwcA54OAc8nAMezgEP54CHc8DDOeDhHPBwDng4BzycAx7OAQ/ngIdzwMM54OEc8HAOeDgHPJwDHs4BDxeAhwvAwwXg4QLwcPEEcEcCdxRwRwN3bOAOoM8BDxeAhwvAwwXg4QLwcAF4uAA8XAAeLgAPF4CHC8DDBeDhAvBwAXi4ADxcAB4uAA8XgIcLwMMF4OEC8HABeLgA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" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "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", "debug_symbols": "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" }, { "name": "view_public_value", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [], "param_witnesses": {}, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [0] }, "bytecode": "H4sIAAAAAAAA/81UzU7DMAx20jZrmYbgyAHUC/dM4gHCK/AGRS2Iyyp1mwQvjyDD1j4y35YiLFV2v/zY/uzY0FEM60LBRDzrGrDA32H9HHnwaxcvKUmVxfdXsb2EfZaxa8AMxCnrn7ni9H59Sacc1cBdyOgrrUEAuwA+0n1LWLeA2eRs5PUe1ivljFP8iY01kdI55SzyVEEugW1/nhx4Ql8B/sXfCuJwfxAPtnKA/+qf+F7k9+1rOs6H3Dk1kEOA+MVfCXvuWF/RT80Fl7iw/6OsgJsG7m1mykXqYZL6iD98T/jGLOQq+3H25Jxz8V43Q/6YGwEPKAHsud/qBXMbZbsbp+51eBq63kBoZRImaqOkYQFDu1Awot+jsgRM2lNrARyzaTs3dEpp1v4tSBeNDMRuWd+wfpym7qN92/TDezvud+340j6P+02/pS876jhFnggAAA==", "debug_symbols": "zZjdaoQwEIXfZa6lzE9Moq9SepFuLQjiLqstFPHdq7jai10WKu1y7jLknMxHICcwAzXHQ+rrY9tRORA/5VQ+D9SdUjvXXZ/OPZViuc+oat/mZXRjRu91U1Gpflpfq0XCqhYXN7W3G2ILetE6sU0qHMaXbMLxWDgBCydi4RRYOMJgPALGo2A8BsbjwHjAslnAwlnA0lnA4lnA8lnB8ln/N5+XHvqAHn+So3ncekS+f693xAuQQwPKHw3EYquYVX+OZr4QeTiiAEcU4YgKNCJjOCKBI1I4IoMjuvn61a8fj7G7/kAt7jEVO0yO95hkj0l/aZqqz3Su02tTzSOVefOjPawTlqnsv07LzvgN" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "35": { "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n", "path": "std/option.nr" }, "62": { "source": "use dep::protocol_types::{\n    constants::{MAX_NOTES_PER_PAGE, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    abis::side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateSet<T> {}\n\nimpl<Note> PrivateSet<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n    // docs:start:insert\n    pub fn insert<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            broadcast\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N>(self, note: &mut Note) where Note: NoteInterface<N> {\n        create_note_hash_from_public(self.context.public.unwrap(), self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n\n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(\n            false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(\n            false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // docs:start:remove\n    pub fn remove<N>(self, note: Note) where Note: NoteInterface<N> {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_consumption(note);\n        let has_been_read = context.note_hash_read_requests.any(|r: SideEffect| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>\n    ) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(self.context.private.unwrap(), storage_slot, options);\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N>(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr" }, "63": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T> Storage<T> for PublicMutable<T> {}\n\nimpl<T> PublicMutable<T> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable reads only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "85": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/log.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "90": { "source": "use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "95": { "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/rand.nr" }, "104": { "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "106": { "source": "use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr" }, "107": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "118": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "122": { "source": "use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn extract_property_value_from_selector<N>(serialized_note: [Field; N], selector: PropertySelector) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = value_field == select.value.to_field();\n        let isLt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "147": { "source": "use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    let expected_public_keys_hash = 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8;\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/public_keys_hash.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address,\n                deployer\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n    let deployer = AztecAddress::from_field(7);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address,\n        deployer\n    );\n\n    let expected_computed_address_from_preimage = 0x027ea2b41ced2ec9a98305984e96dd28518536a4628883ccdc06e38aa8997220;\n    assert(address.to_field() == expected_computed_address_from_preimage);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "200": { "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<1> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<1> for U128 {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr" }, "201": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "211": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "241": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.owner.to_field(), self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "264": { "source": "// A contract used along with `Parent` contract to test nested calls.\ncontract DelegatedOn {\n    use dep::aztec::prelude::{\n        AztecAddress, FunctionSelector, NoteHeader, NoteGetterOptions, NoteViewerOptions,\n        emit_unencrypted_log, PublicMutable, PrivateSet, PrivateContext\n    };\n    use dep::value_note::value_note::ValueNote;\n\n    struct Storage {\n        current_value: PublicMutable<Field>,\n        a_private_value: PrivateSet<ValueNote>,\n    }\n\n    #[aztec(private)]\n    fn private_set_value(new_value: Field, owner: AztecAddress) -> Field {\n        let mut note = ValueNote::new(new_value, owner);\n        storage.a_private_value.insert(&mut note, true);\n        new_value\n    }\n\n    #[aztec(public)]\n    fn public_set_value(new_value: Field) -> Field {\n        storage.current_value.write(new_value);\n        new_value\n    }\n\n    unconstrained fn view_private_value(amount: Field, owner: AztecAddress) -> pub Field {\n        let options = NoteViewerOptions::new().select(ValueNote::properties().value, amount, Option::none()).select(\n            ValueNote::properties().owner,\n            owner.to_field(),\n            Option::none()\n        ).set_limit(1);\n        let notes = storage.a_private_value.view_notes(options);\n        notes[0].unwrap_unchecked().value\n    }\n\n    unconstrained fn view_public_value() -> pub Field {\n        storage.current_value.read()\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/delegated_on_contract/src/main.nr" } } }
