{ "noir_version": "0.25.0+d1ed549202e5a840845298c931418e173eb5437c", "name": "Claim", "functions": [{ "name": "claim", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "proof_note", "type": { "kind": "struct", "path": "value_note::value_note::ValueNote", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "randomness", "type": { "kind": "field" } }, { "name": "header", "type": { "kind": "struct", "path": "aztec::note::note_header::NoteHeader", "fields": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "nonce", "type": { "kind": "field" } }, { "name": "storage_slot", "type": { "kind": "field" } }, { "name": "is_transient", "type": { "kind": "boolean" } }] } }] }, "visibility": "private" }, { "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "proof_note": [{ "start": 33, "end": 40 }], "recipient": [{ "start": 40, "end": 41 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446] }, "bytecode": "H4sIAAAAAAAA/+1dB5gURfavmdm8sLAkwykuqIjxppa04KkjKiqeCpgTurssiCIoWYyYEMxwJu6voCd66qlnwHjmdHqnnp7h9M6cvTOfCU/812O6mDe1vaFn3luqmKrvq2+6e6qr3+/F6urX1TGRLiMqhZhVlt6OqRpXNaFqDdovCrb1frGxX2K0LzP2q4397sZ+T2N/HWO/xtjfLNjGRe+ngt8BycEDBzYNqW2SA2R9snZoQ92g5MBBDYPrZJ0cVDdoXG3dgAFNdQPrhgxtGDokOVQOHNAkxw8aOmB8Ml02R30l8ywxxBMofVRdqWrf4Hfj4HeT4HfT4Ldf8LtZ8Ns/+N3c8d+tVN0ikBnmyxZrCb58+LKlSNufqd9CNNfxZH5FEvaVxPQCjuJguySEfl0SIdtlqN1KYqz4WiYt1SF0NpNBipAYDmFuxdDv1oLOqXLh3ppeRquddhwpw0r0W6rqNoEyxUXzQo1zfUJsIeTm27fUG5gXv9R9iowjwA4hHsIzfQz4+rPxn/6NofN/FtkyMtvEWuinMoSO6pBjbE5AgwUmvYHAA7NqjGsmiK+NlSlHo64NjFr+UtA5iKTgUfI4Mf8oMcuQvhqSjeMGyYbB44bIpvpBdY2NQwdIWVs/uH5wQ23d+KaGQbJuUJ3qs7G+tk5drra+UTYl6wc3ddTIQQqekUOt8COHNonhEGYtQ78DhN0jB8A9gF5GobRSOMYBDP1eV8zjcKkClqaTUpcGCjodouSfHgAAfX1Ex40suYIuNZ3bENJZjOgcFPwODn6HBL91AYYewf5QVYepuq2qv1J1O1W3V3WHgK4dVR2u6k6q7qzqLqqOUHVXVXdTdXdVR6q6h6q/VvWQgEFliJYUFcaBsn5VAC1K92XqURz9p39rRHpUvLptcByOaXuOBcfg7mc9kfk/blxn1TnBsQQ6VlSU1fWqY8XBjpZJmcjwJCWo+JEcDH2WU/eblAPLROZugq7ftD/oJDK8SaHrlCNeddayobu2xNfWd1P6Ovp4EdpeF7XV7TQ/9EBO0w7/V6Dtls4rM86rQm0qQvCnBC3+SoMeTD+UYrQNg0BtA+si2sj1OCnrKkX24FjzTxj0CkSH/i0lpycpQRYbBn1NaJq+14xJkyaOn9g0dc+mYxqapk47cuKxB0ycPrlp2jQ8OtYA1jUA4Ft3/D92YHg7EXJMg6VnfloxStF1Umi/zJJr0zu5ZG2lyA5UUFpTOuygGJzjgEp0jfbQU4noqaCnR3IFAehXO1nCu9pkmMMtN3iFHW4nxL815XA9zR1Dc5XI2DqmFduQDTTqY3gwwGCDrfrdSt5rJ1cNmo1rwcBjR3RdBn82ADCXo+ulEB36ekWozWaxTNtdgmOdRXYc0BjC9KgTPYZW9agTorEC0abp4Y7ferDekWMHjVP3XRFybe4YRtevrMO+tbgF+RahNvsEv11F+29UytC25hGXz2tJPvjaDHayytar2sFH3eYQg49VBt3lIXzEfpsRy6pxWBcmHnU1eKTp74J4pNs0GDzSx00eYT9Uhc7RPGLAUgv9VjPxqJvBI01/NeKRbjPR4JE+bvKoC+KR5o1uG0d9d0XnxlEb/f/K4LjZB7QvM/ZTNDzJsmvt8yuM63Pes2GfomnAJYW2caym1w85MOo9WzWih0M2THawKt51D/qivmfrYfCq3OBVFWrTHfGvBwP/YiL76WcK7evreZo9zZ5mT7On2dPsafY0e5o9zZ5mT7OnOX+agR59f4/n3HS7Ckto1MfwfAfDfXerz2mqEX+K0bYI9l9AtDHMVQ8E2rqg66UQHXiOVbf5DLV9OdjujP7HzyzCnoMxzCe1+jylHNHYCdGm6eF45t7a85SKDri2xqn77tSB124Ld6Vo/nwH60pndEzLrgodM+dU4Zi23y7omPaDWObxEFpwEqD+1c8Tse/SNoHtVT+X6YaOabzdUR8u2wcDPQPD6Ck26ME+vMRoo88tQm2+D367Cq552fRzPS1X83lUN0STbvM/RBM+V9MV9lxP48FxnAHLQDyuMP0+xqLbxGPZ/KWP2+mEVa5nHT0RJui3UwhW3aYU5QyUxzIy0nLC8XLdkP91iRn7KbSt+QeY16HHvGpOfl1EZwpdB197PUQr0bUlvrbOm9TX0ceL0PY6sUxb3U7zQ/Na0w420ivYxrSb51Ua51WhNr1C8KcELf51DHrWMWgGmXRCerYuSrrvzkRTrxZ4VIx4pNvgZ1wMz3pDxymaDn291mIAHpvqNjXIR+F7EBzbbb0H6Y5oNDHi+wCXc5c6ip4igx6cU1NitMFjCd1GGrGuipzu9FjCvO/CeZeaJt1mEKIJn6vpChtLaDy6bZnIzkVIkWBJ51dUG1g0f7siLLrNtgZ/OXI+mLBKnA+ixxIVIVhXj2OQjx+OxgpaJjiXcXTI/7q0NpbAvprBlyXx+EnLt0fItXshWomunTV202MJfR08ptPbo9BYwox3mteadrAP7Xcx7eZ5XYzzcJzsHoI/JWjxm/N/PQyaV+W2Ij0bjcYS9L4rTVP3FnhUhHik24Tlb+N79bB8T6774JZyGfFcQwXa1jS2luts2iYpwTBpUSeyDV6I5ktH5Pv28TaEdA+m6yvZUUtHUL7Fi+ndU/ilI9okhkOYezL0u5egMzgu3HvRy6jDjHCI4DHCvYU3wjaJ4RDm3gz9jhJ2GyHgHkUvow4zwjrBY4SjhTfCNonhEOZohn7HCLuNEHCPoZcRC60QsUcJ+kWU9hG0hgxGqA0SRhpgiEOC37rgF8q+wS81HpDnPgz97kcoS31bJlrgQTK/IgfR9ZXU8wj7q3qAqgeqepCqB4v0u3SHqnqYqmNVPVzVI1StF+l3yBpVHadqk6rjVZ2g6pEi/e5UXGRWjdxfZOZt4sF18P6Bxv5Bxv7Bxv4hxv6hxv5hxv5YY/9wY/8IY7/e2G8w9huN/XHGfpOxP97Yn2DsH2nsTxQtB8RU8JvMr2TpUL62sz9hX9d30KJvudLZND5dDqDra9yBhPy7wQ3+DT2Iri95MCH/bnSCf03yELK+GuWhhPz7gxP8q5OHkfWVlGMJ+XeTC/xrSsrDqfpqTMojCPl3swv8q0vKeqq+VCxvIOTfLQ7wr0lhbiTqq1H1NY6Qf390gH91CnMTUV+KTDmekH+32s+/JsA8gaavRujrSEL+3WY//+oA80RBdy+D7xny5d/tli86HRRJOM6XNxLy7w5H+Ec4TpU3EfJvuSP8IxxnyVsI+XenI/wjHCfIWwn5d5cj/COMc/J2Qv7d7Qj/CP20XE7Iv3sc4R+hn5F3EfLvXkf4R2gnklBnJBf/4gb/bJpzP4pQrtAH9fMueJa4n6B/5ne0oJU1NW74qMf+DLifKbYbN+jj0Qy4n7X83ljTOYmQl4Syls9arjdgL0cx6M3zluPen8leXnDEXo4h5CWhrCUl/3TujR5HgI+AXJtjRCbnZrLILtRjjgMI+5oi7B5zwMe0DhD0NvWS5b4EdGgKA+6XHfElxxLyklDW8mXL9WYYk968ajlu8BGTGXC/5oi9HEfIS0JZy9cYYy/4CIi5x4lM7J0qsgt17KXMEZsm7I698BHLAwW9Tb1uuS8BHZrGgPsNR3zJdEJeEspavmG53mzLpDdvW44bfMRUBtzvOGIvMwh5SShr+Q5j7AUfATF3hsjE3pkiu1DH3oMI+5ol7I698PHogwS9Tb1vuS8BHZrFgPsDR3zJbEJeEspafmC53vyKSW8+thw3+IiZDLg/ccRejifkJaGs5SeMsRd8BMTc40Um9s4R2YU69lK+23OCsDv2bicy7zpS8vBTy30J6NAJDLg/c8SXnEjIS0JZy88s15vtmPTmS8txg4+Yw4D7K0fs5SRCXhLKWn7FGHvBR0DMPUlkYu/JIrtQx95DCPs6Rdgde7cXmXUFKHn4jeW+BHToFAbc3zriS04l5CWhrOW3luvN9kx684PluMFHnMyAe4Uj9jKXkJeEspYrGGPvqSIdc+eKTOw9TWQX6thLuSbD6cLu2LuDyKzhQ8nDnyz3JaBDpzPgXumILzmDkJeEspYrLdebHZj0JlZiN27wEacx4I6XuGEvZxLyklDWkpJ/ZuwFHwEx90yRib1niexCHXsPI+xrnrA79kI/hwl6myq23JeADs1jwF3iiC85m5CXhLKWJZbrTYpJb8otxw0+4iwG3BWO2Mt8Ql4SylpWMMZe8BEQc+eLTOxdILILdeylXEvvHGF37N1RZNampeRhZ8t9CejQOQy4qxzxJecS8pJQ1rLKcr3ZkUlvqi3HDT5iAQPubo7Yy3mEvCSUtezGGHvBR0DMPU9kYu/5IrtQx97DCfu6QNgde4eLzDrwlDzsabkvAR26gAF3L0d8yYWEvCSUtexlud4MZ9Kb9SzHDT7ifAbc6ztiLxcR8pJQ1nJ9xtgLPgJi7kUiE3sXiuxCHXuPIOxrkbA79u4kMt9coeThhpb7EtChRQy4ezviS35DyEtCWcveluvNTkx608dy3EeItN+lxt3XEXu5mJCXhLKWfRljL/gIiLkXi0zsvURkF+rYW0/Y16XC7ti7s8h834ySh5ta7ktAhy5lwN3PEV9yGSEvCWUt+1muNzsz6c3mluMGH3EJA+4tHLGXywl5SShruQVj7AUfATH3cpGJvYtFdqGOvQ2Eff1W2B17dxGZb4lS8nBry30J6NBvGXBv44gv+T9CXhLKWm5jud7swqQ30nLc4CMWM+CudcReriDkJaGsZS1j7AUfATH3CpGJvVeK7EIdexsJ+1oi7I69I0Tmu92UPBxkuS8BHVrCgHuwI75kKSEvCWUtB1uuNyOY9Gao5bjBR1zJgHuYI/ZyFSEvCWUthzHG3qUiHXOvEpnYe7XILtSxl/Kbw78TdsfeXVUf4xhsajvLfQno0O8YcG/viC+5hpCXhLKW21uuN7sy6c2OluMGH3E1A+7hjtjLMkJeEspaDmeMveAjIOYuE5nYe63ILtSxt4mwr+uE3bF3N9VHE4NN7WK5LwEduo4B9whHfMnvCXlJKGs5wnK92Y1Jb3a3HDf4iGsZcI90xF6uJ+QloazlSMbYCz4CYu71IhN7bxDZhTr2jifs60Zhd+zdXfUxnsGm9rTcl4AO3ciAey9HfMkfCHlJKGu5l+V6szuT3oy2HDf4iBsYcI9xxF5uIuQloazlGMbYCz4CYu5NIhN7bxbZhTr2TiDs6xZhd+wdqfqYwGBT+1nuS0CHbmHAvb8jvuSPhLwklLXc33K9GcmkNwdZjht8xM0MuA92xF5uJeQloazlwYyxF3wExNxbRSb23iayC3XsPZKwr9uF3bF3D9XHkQw2dZjlvgR06HYG3GMd8SV3EPKSUNZyrOV6sweT3tRbjht8xG0MuBscsZflhLwklLVsYIy94CMg5i4Xmdh7p8gu1LF3ImFfdwm7Y++vVR8TGWyqyXJfAjp0FwPu8Y74krsJeUkoaznecr35NZPeTLQcN/iIOxlwH+WIvdxDyUtCezmKMfaCj4CYe4/IxN57RXYxY28yvyJ7EMrsXjq6kgmk+2GFCr++Rgxd7z5VewfbZcY1Sa47cNWrfkIUZa6NSyWSs25Tqmp3RFMRPU0S+i2m7jeZ7reUvt/V9iMCulPoOsWIV+Uiw2cqTPjaWnfK0TW16PR2N9RWt9P80LLWtHdWtSTYLm/lvCLjvCrUpiQEf0rQ4i816Ck1aC5Gx6oBg6HvQJuOGysFrb6VMGCuRDwXIhsL5oMIkQGHXVWItK+AMm36lKn1E5rGNNWPwy6tyCAzzN3h43F0DG8nQo6J4PIaZhE6Zpohdmkl6JjuF6tOM7efCn6T+RUpQgDrvvONfX8S9L4ljmgF+/hT8LuOqvcHzDMFEoYtmV+RSbq+kpx03k9IZwmi84Hg98Hg96Hg9+Hg95EAS/9g/1FVH1P1cVWfUPVJVf+s6lOqPq3qX1T9q6rPqPqsqs+p+jdVn1f1BVX/ruqLqr6k6suqvqLqP1R9VdXXVP2nqv9S9XVV31D1TVXfUvVtVd9R9V1V31P1fVU/UPVDVT9S9WNVP1F1r4DxPGOb2vF4bGPqZxz9p39rRPiYBzuIGBoHrS8y/8eN66w6JziWQMeKirK6XnWsONjBTqokOMYaPwcmh0C/FdT9JmvroN9O5P2mx1qdRYZfKXSdCsSrqmCbeqzVGfUbQ9fRx4vQ9nqorW6n+aEDTSd0vo6hVa2cV26cV4XaVIbgTwla/J0MejAdUIrRNoy1tF1sjWijH4PXjqsUGfsRiH/CoFeXUkQPxxgNdHHdoK8JTdNHzWiYNLFx5/rp9ftObWo6YOL0yU3TpuFBkKZ9a4N2c4Ck/486QGK691mlEzhGpdA+5nEZ/bWTPPcUtasGrtqXaB+j6dfXK0Jt+gW/XUVaVvq4pgvfA0LpjHiDfRbH/RH0W8nEo04GjzT9lYhHus3WBo86tcCjcsQjzZtOiEf0WJK1ZSLjs6l5VGXwqBLh0zzSbQYaPKpqgUe4D9P/8mBJDoB+uzDxqKvBI01/F8Qj3WZbg0f6uMmjzui3Cp0DJY76xnEyjtro/1cGx80+oD0PT5IDod9q8n7TvNbzP5rXmn59vSLUZheEGZ+r6So2eNUZ8Ue35cGSrK006BGi9XhfjejpQU5PbV0lukZ76OmB6OlOTk/a79PjTMfcnkFfhHNlq8b1vQxeVRu8qkJteiL+9WLgXwxdV/et9/X1PM2eZk+zp9nT7Gn2NHuaPc2eZk+zp9nT7Gn2NHuaPc2eZk+zp9nT7Gn2NHuaU55mT7OnOSeagR79vFfTWonadbOERn0MvyPD8By21byrHog/RYgOKPDM/gd0jCGnow5oq0bXSyE6cE6HbtMzlmn7U3CsM/q/G8LT2TjGlBOUleup++6M6NA04twHTU83Jnq0fHVOa0kILzhyGWMIp+5b7+OXKDQdpeiY5ksFOqb51wkd03lfXdExbUM4v1XrNvYB2j91QcfiIps3OIcbyxHnYetfMxcNv1zSHR3TOLG9aTvrifpwWZcZ6BkURo8ph5jIfocMt8G5c7rNRoEP6Sq48k3T+VNa/mauGn7XTrfZGNGEz9V0heWqaTw4fjBgqcPxzPTRGItus7nBX/qYln5ngB5rWv97IkzQb5cQrLrNNigeJYNtbK84tu0Q8r8uMWM/hbZ7oOuvQ495FdnrIjpT6Dr42vgdBaJrS3xtnb+ur6OPF6Ht7WOZtrqd5ofmtaYdeKzHW5h287zOxnlVqE2vEPwpQYt/HYOedQyaQSYDkJ5pPeLKBwwb82M/qnmk2+B3iBnyN0PHFJoOfb3WYgAeR+o2uyIfhe8XcKzTbXHM5Rqfm+9J6318j2X6+8oQjHjMbvoUUoJh0PSIyHZUUKgX1SB8QVI+SEjXv+noanHhiBix3ChpxvT+R2QGKCUh9Ju6gbfLUDvKF+rN65q0VIfQyWYwuHOqPv8dMJ66308FnZFw4f6UXkarjDAhmhdq+inf+Oak80EmOmnlVpvliD5T9ZRgu8y4Fsn1BiYH4jfFTX2BoLj67e4c3hTHET2O3h7HswsJ4+3xanQshrBrR1xDhV0mk3gmYzWdInMnrq+p34QqN9qmAtro3yJPr3SCZY75IdD1dME87YSwaP4xvBWdxCNZfadVZdAD1+6K6Ce6dtYoWt9pmW+wFaHtjUSmdEX/45k4XaoR/7qG/I/fhO9knINngIXI6IhAvKlCbfCdc6dW6OK8G6ky6MVvsUMB2XbETJ359jCeOdW/+A1bKCAjc0ZW22sno21KsNmCjDoLguWr+YwHkQwz6cmwWbxuBj34rpDaXrujfvEsnD6OZxAHi0zpgf7XvMJ30Hr2Ko7a4v+x/6k2zsEzZEJkzw5o3lShNvit2+pW6MJvC6YELR/Nt1G7GZhAtpsjOhje1G3Vb2AedGW4dqXIli+U1mytawg9hLqdrEL04GtxPA2L+rYt1uHqVmisoaMxiZ8k4beud0b04jffa1B7vDCRbrMHartrsI3fbsdPv8y32/FYVf+nn0zp/qtD+EHt+/ATTGzDeCyi24xCeGcj2sjHwAFt2CZqREYGmOZu6FiNaL7kHH57fj+ELWbwtEZky14f7270X4z60P3rNgeh/+LoOLa3sKc8uh1enQVnhqSC7WR+pdlTF0xLL3RctzlcZPOrZwt0l4ec29DCuZoPeuyp++iMaMExsFsL18RPJbsamLqFYNJtjjTo6tpC/51Czj26hXM1ps4hmEx7wjqlVwENy5jBPEgF28n8SjObwnLpHoJ3KuLNrBD6i1ugH8cd/NS0OwMmHD+6h9Db0b5K921O1Ib5qjBfotuchP6rDGlrxq2sjVTwm+/E4qfETAKn+JloPjCIM9Kdb1+fE/Kgo55AUE4qxhGdXwS/X4qMM2SaAByQyzLYOM0pFrL8Y9yYUKwOaVeW6ZJ0Ug/6LabuV03M4lQo3T9gqchmz+rJhzKjbUrwLXWGJzJ1ae2mQNOGJ1SwXBiW0UriG8aWUojwzSp1QMZLS+LJQ30cL0eml54XInsyUfMKT1SFLa2F/++ErltpnBM2uMFLkGv6uhp9CZE9EWbSxXXjHRMtp9PhgIlvqDgmx1tLMcA8YFiGdZWtYflCac9EH6aHcvmoKhG+XCCDDUvsL9qDHetwZQiNNkzEVoXQQ/nkvsrgg74Wg30m8UM4bI8SXZd+GXyZxA9CtG9PoH0o+KHGr9B/g4JtnAJagY619hAAP/QqM87FYxd8Lp5k133g5ST1+TFEu4kJL03NtdwynljBtOB4pdsMD371DXNRC3SXhZy7SwvnCpEdj3AKuTlZFzeuCWWl0RbbZJdWzjO3OxnnYH9XHEITfmBGP/Gdreu674RBI+ZjidEGT3joNmOC35bk1wn1pfs3J2NwKqM+rtvsb/TftYX+y0LOPaiFc4XI1g+8nHcROgdK2MO4lUZbrB+tnWdumzfsONYUhdCEx5xdES2pYDuZT5Hp5BB8f1AUQh9exl3TQv45ocCPYFuCfhMGb7A+m7oa5rsnIjyVIW1xvIlR33DDJMFnIhsQQb8tZktFvU4bkxytfv8kmV+RXxDyIx8etEFmVobTV8JnOGnsPsPJZzhh/vgMp3RJ5ld8hhMR/T7DqXX++AyndEnmV3yGk89w8hlOwmc4pQhp8xlOPsPJZzjx2ZTPcKLnq+67QzOcXJmw01lOX4nm77tS0Q50fy7os72+JuQDB26YSPyaAfd/GeQPfZ7KJP8vmfjwDQMfvkF80CXBoBft7Eu28X/yS0J+fivstqcHmfTomBJe3BR+7luGficT49YlTix3QvlILszU65tQ+oivCOn6LoJc2/MQj9pHgK18x2Ar3wv6WAN9niqyC7UeUcYHSj36IQI/27oWlx79wKBHKxj0aEWgRx2VrU+5VEkc0flj8Ps/4bP1IxWfrb+6tDbB7bP1fbZ+rnz02fo+W7+92H22vs/W99n60RmKs699tn72OT5b32fr+2z99lGD/Ybuu0Oz9YWxkSICRvnAa23I1P+RkB/58KANMrMy9eHrND5T32fq69LaIN1n6vtM/Vz56DP1faa+z9RPl5TwmfrtpcNn6qeLz9TPLj5TP1tmPlM/u3+fqe8z9X2mvs/Uz4evum8r1iJN5ldIJ+t0ps9Pgi9LH+j9UdBnPFE+9dV8gD5PZeTD/xj48DMDH35GfNCFOls9wiRrm5mo/yPkJwiIip8cegRZchzZ6sc5kK0OnVL3O9WRbHVC+cipjmSrU/qInwjpikXwEWsqWz3GYCvxGH2sgT5PFdmFWo8o4wOlHiUi8HNNZasnGPSoiEGPimKZbPWO+LDmF4LHh/qH2epGSu1cF2wX8sPsKoMmzQ/6rMP0DTMuKbRdHEJPwjJ6iiyjJ2YBPZVChL6FgjOq9DE9KZJAx8yEB6z/+BpmJifW/1L0K0OuFw+5XklIu47gJ75WSjR/Q6UzoqPEEnqKLKMnYRk9cYMe/H8x+j+B+sJv0MB+qXEetiH89o9pG+XCJyQJxFdcUmjbJyS1npCkH2QK4ROSTD62JyFpGKLDJyQ1p98nJLXOH3zt9iQkjRWZ4hOSsvnYnoSk0YgOn5DUnB5C3fYJSUZpKSFpEqI3SkLSNNR2SrC9NickzUZ4lyLaXElIwg/5ORKS5qL/4sL9hKR5IptfURKSFrRwrubDmkpIutCgK0pC0qIWztWY1raEpMWIN0tC6Lc5IWkJ2l6KaHAlIWkZ+q+lhCQct7I2UkTAOBKSimPNBwacyyVSPqjOt68ZHfRwvo1T23ygXhyjw1xC90BQYv7lnQzEZC8lDA9VS2P0dljajofzyfyKpFxKjvJB/yxHkmQo7bCM0A6p+cdhh2UMdljOYIflIXYYJ6b7M8K+Kgj1yPXlBysDQjvF/PKDkYpffnB1aW2SzC8/6JcfzJWPfvlBv/xge7H75Qf98oN++cHoDI0Jv/ygLn75Qb/8ID7P3PbLD7ZMDfYbuu8OXX6Q+ob7c9VHRSwbEEG/a8UShJWEk0j58KANMrPe2ugc80sQauw+49dn/GL+4GvrSQu/BGFufPRLEPqMX78EYbqkhF+CsL10+IzfdPEZv9nFL0GYLTPoyy9BSJfx65cg9EsQmpj8EoQZTH4Jwswx3CbvJQhdmbDTWU6dUTYWF+3U2V5VxBN1HBOJVQy4u8To5d8lxrf8YicmPnRl4ENXxAddqLNuI0wwt5kJ3ilGx89qy+0JsgQ59Oh4y5dfBMzVDLjnOLL8IqF85BxHMsspfURnQh/RLYKPWBPLL4KtdGOwle4MsaZ7O2JNvnRTxgdKPeoRgZ9rYvlF0KMeDHrUk0GPesYyyy/GRPNCzZsH6frKytbvFRC6Tsxn60cqPlt/dWltgttn6/ts/Vz56LP1fbZ+e7H7bH2fre+z9aMzNCZ8tr4uPlvfZ+vj88xtn63fMjXYb+i+OzRbXxgbKSJglA+81oZM/V7EDyxy5UEbZGZl6q8b85n6GrvP1PeZ+pg/+Np6wsJn6ufGR5+p7zP1faZ+uqSEz9RvLx0+Uz9dfKZ+dvGZ+tkyg758pr7P1BfCZ+r7TP3meH2mfnS+6r47NFNfGBspImCUk3U602fdGF+WPtDbiyHjaT0GPqwXZDxx8WEdBj6sz8CH9REfdKHOVo8wydpmJuo6MTp+/oJ48pdajyBLjiNb/SQHstV/wYD7ZEey1QnlI092JFud0kesS+gjNojgI9ZUtvoGDLayIUOs2bAdsSZfuinjA6Ue9Y7AzzWVrd6bQY82YtCjjWKZbPWwB9DUvOFazs0/zFY3YmrnumC7kB9mVxk0aX7QZx227+PzmJ6EZfQUWUZPzAJ6KoUIfQsFZ1TpY3pSJIGOmQkPWP/xNcxMTqz/pehXhlwvHnK9kpB2HcHP9nx8PmbQuKbpKbKMnoRl9MQNevD/xej/BOoLv0ED+6XGediG8Ns/pm2UC5+QJBBfcUmhbZ+Q1HpCkn6QKYRPSDL52J6EpGGIDp+Q1Jx+n5DUOn/wtbW9tpaQNFZkik9IyuZjexKSRiM6fEJSc3oIddsnJBmlpYSkSYjeKAlJ01DbKcH22pyQNBvhXYpocyUhCT/kjwn6hKS56L+4cD8haZ7I5leUhKQFLZyr+bCmEpIuNOiKkpC0qIVzNaa1LSFpMeLNkhD6bU5IWoK2lyIaXElIWob+aykhCcetrI0UETCOhKSaWPOBAedyiZQPqvPta24HPZxv49Q2H6jXEGLuQ6dDEvMvX7q47KUPw0PVvgx22DfGnwhGuZQc5YP+0x1JkqG0w40J7ZCafxx2uDGDHW7CYIebdIAd3k/Ig4cJ+9qUkJ8dtZThpsQ6oEu/WPNBoxAtj5XwdhlqR7kkk3ldk5bqEDqbySBFSAyHMPvF6PvdLGb3QAVwbxYjl1GyozK0HhY8AZyazvuZ6KSVW22WI+of88uNaOz+6b5/uo/5g6/dnqf7frmRlvnolxvxT/f9ciPpkhJ+uZH20uGf7qeLf7qfXfxyI9kyi/p0fxTC65cbyfTvlxtpfm5DC+dqPvjlRvxyIxSY/HIjrTzdz3dicbMYLZPAKfaPNR8YxBnpzrevzQl50FFPICgnFeOIzi0CQreM+Y8pRSr+Y0qrS2s3Bf5jSv5jSrny0X9MyX9Mqb3Y/ceU/MeUwj7I4T+m1DpDYyJ7YgXT4j+m5D+mFDYZU4T4o4/rNv5jSs2v4z+mlC5Yn8k/pkR9ww2TBP1j2YAI+l0rPqi0Bd0ESjIfHrRBZlaG01Y+w2k1dp/h5DOcMH/wtX2GU3589BlOPsPJZzilS0r4DKf20uEznNLFZzhlF5/hlC0zn+GU3b/PcPIZTj7DyWc45cNX3XeHZji5MmGns5y2ijV/35WKdqB78xh9ttfWxBN1HBOJWzPg3iZGL3/o81Qm+W/JxIdfMvDhl4gPulCvXRBhgrnNdW22jNHxM2m5PUGWIIcenWn5x6QAc5IB91mOfEyKUD6SCzP1OjmUPmIrQh8hI/iINfExKbAVyWArtQyxprYdsSZfuinjA6UeDYjAzzXxMSnQowEMejSQQY8GBnrUUdn6D9P1lZWtPyggdHDMZ+tHKj5bf3VpbYLbZ+v7bP1c+eiz9X22fnux+2x9n63vs/WjMzQmfLa+Lj5b32fr4/PMbZ+t3zI12G/ovjs0W18YGykiYJQPvNaGTP1BxA8scuVBG2RmZeoPiflMfY3dZ+r7TH3MH3xtPWHhM/Vz46PP1PeZ+j5TP11Swmfqt5cOn6mfLj5TP7v4TP1smUFfPlPfZ+oL4TP1faZ+c7w+Uz86X3XfVqxFmsyvkE7W6UyfITG+LH2gdxBDxlMdAx/qgownLj4MZuDDUAY+DEV80IU6Wz3CJGubmaiDY3T8HEY8+UutRw8Lnmz1+Q5kqw9jwL3AkWx1QvnIBY5kq1P6iCGEPmLbCD5iTWWrb8tgK79iiDW/akesyZduyvhAqUfbReDnmspW345Bj7Zn0KPtY5ls9Y74sCbXcm7+YbYQO6id64LtQn6YXWXQpPlBn3WYvmHGJYW2i0PoSVhGT5Fl9MQsoKdSiNC3UHBGlT6mJ0US6JiZ8ID1H1/DzOTE+l+KfmXI9eIh1ysJadcR/MTXSonmb6h0RnSUWEJPkWX0JCyjJ27Qg/8vRv8nUF/4DRrYLzXOwzaE3/4xbaNc+IQkgfiKSwpt+4Sk1hOS9INMIXxCksnH9iQkDUN0+ISk5vT7hKTW+YOvre21tYSksSJTfEJSNh/bk5A0GtHhE5Ka00Oo2z4hySgtJSRNQvRGSUiahtpOCbbX5oSk2QjvUkSbKwlJ+CF/TNAnJM1F/8WF+wlJ80Q2v6IkJC1o4VzNhzWVkHShQVeUhKRFLZyrMa1tCUmLEW+WhNBvc0LSErS9FNHgSkLSMvRfSwlJOG5lbaSIgHEkJO0Qaz4w4FwukfJBdb59nddBD+fbOLXNB+o7EGJO0emQxPzLly42e2F4qLojgx3uGONPBKNcSo7yQf8FjiTJUNrhcEI7pOYfhx0OZ7DDnRjscKcQO4wT092fUI92JtQj15cf3CUgdETMLz8YqfjlB1eX1ibJ/PKDfvnBXPnolx/0yw+2F7tfftAvP+iXH4zO0Jjwyw/q4pcf9MsP4vPMbb/8YMvUYL+h++7Q5Qepb7jh2107x7IBEfS7VixBuAvhJFI+PGiDzKy3NnaN+SUINXaf8eszfjF/8LX1pIVfgjA3PvolCH3Gr1+CMF1Swi9B2F46fMZvuviM3+zilyDMlhn05ZcgpMv49UsQ+iUITUx+CcIMJr8EYeYYbpP3EoSuTNjpLKddUTYWF+3U2V67EU/UcUwk7saAe/cYvfyhz1OZ5D+CiQ8jGfgwEvFBF+qs2wgTzG1mgo+I0fFzD8vt6WHBo0cXWb78ImDegwH3QkeWXySUj1zoSGY5pY/YldBH/DqCj1gTyy+CrfyawVb2ZIg1e7Yj1uRLN2V8oNSjvSLwc00svwh6tBeDHu3NoEd7xzLLL8ZE80LNm/vp+srK1h8VEDo65rP1IxWfrb+6tDbB7bP1fbZ+rnz02fo+W7+92H22vs/W99n60RkaEz5bXxefre+z9fF55rbP1m+ZGuw3dN8dmq0vjI0UETDKB15rQ6b+KOIHFrnyoA0yszL1x8R8pr7G7jP1faY+5g++tp6w8Jn6ufHRZ+r7TH2fqZ8uKeEz9dtLh8/UTxefqZ9dfKZ+tsygL5+p7zP1hfCZ+j5Tvzlen6kfna+67w7N1BfGRooIGOVknc70GRPjy9IHekcxZDztw8CHfYKMJy4+jGbgw74MfNgX8UEX6mz1CJOsbWaijo7R8XM/4slfaj2CLDmObPWLHchW348B9yWOZKsTykde4ki2OqWPGEPoI/aP4CPWVLb6/gy2cgBDrDmgHbEmX7op4wOlHh0YgZ9rKlv9QAY9OohBjw6KZbLVwx5AU/OGazk3/zBbiIPVznXBdiE/zK4yaNL8oM86bN/H5zE9CcvoKbKMnpgF9FQKEfoWCs6o0sf0pEgCHTMTHrD+42uYmZxY/0vRrwy5XjzkeiUh7TqCn+35+HzMoHFN01NkGT0Jy+iJG/Tg/4vR/wnUF36DBvZLjfOwDeG3f0zbKBc+IUkgvuKSQts+Ian1hCT9IFMIn5Bk8rE9CUnDEB0+Iak5/T4hqXX+4Gtre20tIWmsyBSfkJTNx/YkJI1GdPiEpOb0EOq2T0gySksJSZMQvVESkqahtlOC7bU5IWk2wrsU0eZKQhJ+yB8T9AlJc9F/ceF+QtI8kc2vKAlJC1o4V/NhTSUkXWjQFSUhaVEL52pMa1tC0mLEmyUh9NuckLQEbS9FNLiSkLQM/ddSQhKOW1kbKSJgHAlJB8eaDww4l0ukfFCdb1+Xd9DD+TZObfOB+sGEmA+h0yGJ+ZcvXVz2cgjDQ9VDGezw0Bh/IhjlUnKUD/p/60iSDKUdHkZoh9T847DDwxjscCyDHY6NdexSfI8IWgy6HB5rPugRouVYj7fLUDvKJYXM65q0VIfQ2UwGKUJiOIR5eIy+3yNidgdawH1EjFxGyY4ywocFjxHWeyNsmxgOYdYzGGGD5UYIuBsYjJCDVvigBEdqfWPMbtzgJBsYcI+zHPfnqo8qBtxNzLgp9BFkQ30nR6jnchyhXxtvuR6Cvoxn0MMJluO+T/UxgSk26BJn5Gm+fR0Z4x2z5EsfvGp2JINeXmH5zMCDTLivdORVM0L5yCtL7I6F9zHJ+irLdfwhJtxXO6LjhPKRlJg7anLhQbq+siYXJvrJhbaJ4RDmRIbJhaMsn1wA3Ec5PMP3kOAxwqO9EbZNDIcwj2YwwkmWGyHgnuTIDB84i0kMo55jLL/Thtm9YxhwTyZ+1omXbgfnDg7ooeD3keD34eAXypQAEDUumBGdzMCvYwnv+PWIWBdqnXmArq9k/6Cf4xSRU1Wdpup0VWeoOlPVWarOVvV4VeeoeoKqJ6p6kqonq3qKqqeqOlfV01Q9XdUzVD1T1bNUnafq2arOV3WBqueoeq6q56l6vqoXqHqhqhepulDVRar+RtWLVb1E1UtVvSyWvssAPsYDWmNof6qxP83Yn27szzD2Zxr7s4z92cb+8cb+HGP/BGP/RGP/JGP/ZGP/FGP/VGN/rrF/mrF/urF/hrF/prF/lrE/z9g/29ifb+wvMPbPMfbPNfbPM/bPN/YvMPYvNPYvMvYXGvuLjP3fGPsXG/uXGPuXGvuXxVoeoKWC32R+Jcum8/VlYB9UfS2zPNeqaXy6TI2R9TVuGiH/rnWDf0On0/FPziDk33VO8K9JziTjX6OcRci/3zvBvzo5m4x/SXk8If+ud4F/TUk5h4p/jUl5AiH/bnCBf3VJeSIV/1QsP4mQfzc6wL8mhflkIv41qr5OIeTfHxzgX53CfCoR/xSZci4h/26yn39NgPk0Gv41Ql+nE/LvZvv5VweYz6DhH5ApzyTk3y3W869pFeazSPjXuKqveYT8+6P1/KtbhflsEv6tIlPOJ+TfrbbzrymNeQEF/xrTfZ1DyL/bbOdfXRrzuRT8S5MpzyPk3+2W829cgPl8AswNQV8XEPLvDsv5NyTAfGH+mGv1wtUXEfJvud38kxrzwrwx143XfS0i5N+dVvOvrkFj/k3+/Fu9cPrFhPy7y2r+DVmN+ZK8MQ9a3delhPy722r+ydWYL4vRPUtZRrjOwD12rPnQVpGEzxnkdYT8u9cR/hHOk8vrCfl3nyP8I5znlTcS8u9PjvCPcJ5S3kTIv/sd4R/hPJu8hZB/DzjCP8J5InkrIf8edIR/hPMc8nZC/j3kCP8I79PlckL+PewI/wjvM+VdhPx7xBH+Ed4nyXsI+feoI/wjHOfL+wj595gj/CMcp8r7Cfn3uCP8IxxnyQcJ+feEI/wjHCfIhwn596Qj/COMc/JRQv792RH+Efpp+Tgh/55yhH+EfkY+Sci/px3hH6GdSEKdkVz8ixv8s+mdg8sJnwVAHzFiXYF3246N0b+DtjhGK2tq3I+KzLtXlLi/tHxFDtDHxQy4v3JkHePfEtojoazlV5brDdjL5Qx6843luI9jspdvHbGX/yO0F0JZS0r+gWzhnXA9jgAfAe9+/18s8w74FTGRVajHHFMJxxxXWj7meExk3nOm5OEPlvsS0KErGXCvcMSXLCHUS0JZyxWW6w3YC4fe/GQ5bvARVzDgXumIvSwltBdCWcuVjLF3SRBzl6LYexVz7KV8R/5qy2Pv4yKzpgglD2OldvsS0KGrGXDHS93wJb8j1EtCWcu45XoD9sKhN8WW4wYfcRUD7hJH7OUaQnshlLWk5J8Ze38XxNxrUOxdxhx7pxPG3mstj71PiMz6XZQ8LLfcl4AOXcuAu8IRX3IdoV4SylpWWK43YC8cetPZctzgI5Yx4K5yxF5+T2gvhLKWVYyx97og5v4exd7rmWMv5dpmN1gee58UmbUyKXlYbbkvAR26gQF3N0d8yY2Eekkoa9nNcr0Be+HQm56W4wYfcT0D7l6O2MsfCO2FUNayF2PsvTGIuX9Asfcm5tg7kzD23mx57P2zyKxLTcnD9Sz3JaBDNzPgXt8RX3ILoV4Sylqub7negL1w6M2GluMGH3ETA+7ejtjLHwnthVDWsjdj7L0liLl/RLH3VubYS7km9W2Wx96nROYbEJQ87GO5LwEduo0Bd19HfMnthHpJKGvZ13K9AXvh0JtNLccNPuJWBtz9HLGXOwjthVDWsh9j7L09iLl3oNi7nDn2ziaMvXdaHnufFpnvLVHycHPLfQno0J0MuLdwxJfcRaiXhLKWW1iuN2AvHHqzteW4wUcsZ8C9jSP2cjehvRDKWm7DGHvvCmLu3Sj23sMceym/JXSv5bH3LyLzbUNKHkrLfQno0L0MuGsd8SX3EeoloaxlreV6A/bCoTeDLMcNPuIeBtyDHbGXPxHaC6Gs5WDG2HtfEHP/hGLv/cyxdw5h7H3A8tj7V5H5jjAlD4da7ktAhx5gwD3MEV/yIKFeEspaDrNcb8BeOPRmO8txg4+4nwH39o7Yy0OE9kIoa7k9Y+x9MIi5D6HY+zBz7KX8BuwjlsfeZ1QfJzDY1I6W+xLQoUcYcA93xJc8SqiXhLKWwy3XG7AXDr3ZxXLc4CMeZsA9whF7eYzQXghlLUcwxt5Hg5j7GIq9jzPH3hMJY+8TlsfeZ1UfJzLY1O62r5GgOnyCAfdIR3zJk4R6SShrOdJyvQF74dCbPS3HDT7icQbcezliL38mtBdCWcu9GGPvk0HM/TOKvU8xx96TCGPv05bH3udUHycx2NRo2/NVVYdPM+Ae44gv+QuhXhLKWo6xXG/AXjj0Zj/LcYOPeIoB9/6O2MtfCe2FUNZyf8bY+5cg5v4Vxd5nmGPvyYSx91nLY+/fVB8nM9jUQbbPHaoOn2XAfbAjvuQ5Qr0klLU82HK9AXvh0JvDLMcNPuIZBtxjHbGXvxHaC6Gs5VjG2PtcEHP/hmLv88yx9xTC2PuC5bH3edXHKQw2VW+5LwEdeoEBd4MjvuTvhHpJKGvZYLveCB69abIcN/iI5xlwj3fEXl4ktBdCWcvxjLH370HMfRHF3peYY++phLH3Zctj7wuqj1MZbGqi5b4EdOhlBtxHOeJLXiHUS0JZy6Ms1xuwFw69OcZy3OAjXmLAPdkRe/kHob0QylpOZoy9rwQx9x8o9r7KHHvnEsbe1yyPvX9XfcxlsKnjLPcloEOvMeCe6ogv+SehXhLKWk61XG/AXjj0ZobluMFHvMqAe6Yj9vIvQnshlLWcyRh7/xnE3H+h2Ps6c+w9jTD2vmF57H1R9XEag00db7kvAR16gwH3HEd8yZuEekkoaznHcr0Be+HQm5Msxw0+4nUG3Cc7Yi9vEdoLoazlyYyx980g5r6FYu/bzLH3dMLY+47lsfcl1cfpDDY113JfAjr0DgPu0xzxJe8S6iWhrOVptj+rEDx6c6bluMFHvM2A+yxH7OU9QnshlLU8izH2vhvE3PdQ7H2fOfaeQRh7P7A89r6s+jiDwabmW+5LQIc+YMC9wBFf8iGhXhLKWi6wXG/AXjj05jzLcYOPeJ8B9/mO2MtHhPZCKGt5PmPs/TCIuR+h2Psxc+w9kzD2fmJ57H1F9XEmg01dZLkvAR36hAH3Qkd8yb8J9ZJQ1nKh5XoD9sKhNxdbjht8xMcMuC9xxF7+Q2gvhLKWlzDG3n8HMfc/KPZ+yhx7zyKMvZ9ZHnv/ofo4i8GmLrfcl4AOfcaAe7EjvuRzQr0klLVcbLnegL1w6M0VluMGH/EpA+4rHbGXLwjthVDW8krG2Pt5EHO/QLH3S+bYO48w9n5leex9VfUxj8GmrrLcl4AOfcWA+2pHfMnXhHpJKGt5teV6A/bCoTfLLMcNPuJLBtzXOmIv/yW0F0JZy2sZY+/XQcz9L4q93zDH3rMJY++3lsfe11QfZzPY1PWW+xLQoW8ZcN/giC/5jlAvCWUtb7Bcb8BeOPTmJstxg4/4hgH3zY7Yy/eE9kIoa3kzY+z9Loi536PY+wNz7J1PGHtXWB57/6n6mM9gU7da7ktAh1Yw4L7NEV/yI6FeEspa3ma53oC9cOjNcstxg4/4gQH3nY7Yy/8I7YVQ1vJOxtj7YxBz/4di70/MsXcBYexdaXns/ZfqYwGDTd1juS8BHVrJgPteR3zJz4R6SShrea/legP2wqE391uOG3zETwy4H3DEXiDIUPGSUNbyAcbY+7OOufFM7I3FRVahjr3nEMbeeNzu2Pu66uMcBpt62HJfAjoEsqHG/YgjviRBqJeEspaPWK43YC8cevO45bhX+QgG3E84Yi9FhPZCKGv5BGPsTQQxtwjF3mLm2HsuYewtsTz2vqH6OJch9j5luS8BHSph8CVPO+JLSgn1klDW8mnL9QbshUNvnrEcN/iIYgbczzpiL2WE9kIoa/ksY+wtDWJuGYq95cyx9zzC2Ftheex9U/VxHkPsfd5yXwI6VMHgS15wxJdUEuoloazlC5brDdgLh968ZDlu8BHlDLhfdsReOhHaC6Gs5cuMsbcyiLmdUOztzBx7zyeMvVWWx963VB/nM8TeVy33JaBDVQy+5DVHfEkXQr0klLV8zXK9eUvw6M3rluMGH9GZAfcbjthLV0J7IZS1fIMx9nYJYm5XFHurmWPvBYSxt5vlsfdt1ccFDLH3bct9CehQNwZf8o4jvqQ7oV4Sylq+Y7negL1w6M37luMGH1HNgPsDR+ylB6G9EMpafsAYe7sHMbcHir09mWPvhYSxt5flsfcd1ceFDLH3Y8t9CehQLwZf8okjvmQdQr0klLX8xHK9AXvh0JtPLccNPqInA+7PHLGXdQnthVDW8jPG2LtOEHPXRbF3PebYexFh7F3f8tj7rurjIobY+6XlvgR0aH0GX/KVI77kF4R6SShr+ZXlegP2wqE331iOG3zEegy4v3XEXjYgtBdCWctvGWPvL4KYuwGKvRsyx96FhLG3t+Wx9z3Vx0KG2PuD5b4EdKg3gy9Z4Ygv2YhQLwllLVdYrjdgLxx685PluMFHbMiAe6Uj9lJDaC+EspYrGWPvRkHMrUGxtw9z7F1EGHv7Wh5731d9LGKIvbEyu30J6FBfBl8SL3PDl2xMqJeEspZxy/UG7IVDb4otxw0+og8D7hJH7GUTQnshlLWk5J8ZezcOYu4mKPZuyhx7f0MYe/tZHns/UH38hiH2llvuS0CH+jH4kgpHfMlmhHpJKGtZYbnegL1w6E1ny3GDj9iUAXeVI/bSn9BeCGUtqxhj72ZBzO2PYu/mzLH3YsLYu4XlsfdD1cfFDLG32nJfAjq0BYMv6eaIL9mSUC8JZS27Wa43YC8cetPTctzgIzZnwN3LEXvZitBeCGUtezHG3i2DmLsVir1bM8feSwhj7zaWx96PVB+XMMTe9Sz3JaBD2zD4kvUd8SW/JNRLQlnL9S3XG7AXDr3Z0HLc4CO2ZsDd2xF7SRLaC6GsZW/G2PvLIOYmUeyVzLH3UsLYW2t57P1Y9XEpQ+ztY7kvAR2qZfAlfR3xJQMI9ZJQ1rKv5XoD9sKhN5tajht8hGTA3c8RexlIaC+Espb9GGPvgCDmDkSxdxBz7L2MMPYOtjz2fqL6uIwh9m5uuS8BHRrM4Eu2cMSXDCHUS0JZyy0s1xuwFw692dpy3OAjBjHg3sYRe6kjtBdCWcttGGPvkCDm1qHYO7SN2JvMr8hehDIbGufRLerxxiaE/LtPuIFZ0NEp+wp6G9D+o4/I6D78boz2hwX+ENtMv+D/Ychmto2n+4uJ5oU8j03Q8kKXXykMxcF2SQj9uiRCtstQu5WEWM3rmrRUh9DZTAYpQmI4hPmrOH2/28VpDZkD93ZxchmxOrTNCPvannCwEcWh7dCKQ9sBObRUSLtNgnapoF2Rqjsy36hT6vHwNcTznVrh+U6I5zu3wvOdEc93CWm3adBul6Ad0DUi+JPDt2zPcKOwK/Fgjho3YB7OgHs3y3GDje/KgFtafkMM9rMbA+5aR26Idyf0l4SylpT8A54ZIUxw6FJS0Mqc+qYcxjbbxml95e4M4zssq5GBbdYE+3uo/V+ruqeqe6m6t6qjVB2t6hhV91F1X1X3U3V/VQ9Q9UBVD1L1YFUPUfVQVQ9Tdayqh6t6hKr1qjao2qjqOFWbVB2v6gRVj1R1oqpHqbpZoDRlIhs3CfaBtQNW3ZQVpfsydTaO/tO/NapW4rbBcTimfUUsOFaqai+R+T9uXAcwFZNjSg6Afkuo+03WJstERg50/aZvmMuDvoqDfvV1ShCvKjR/6a4t8bVjQdXXKUci1ts9UVvdTvMD37hD6SzSOiAM2s3zio3zqlCb0hD8KUE/5sb0lBk0F6NtmBzQetwH0abNhHKiogrRxWozAR+EwQeB8EPB9CQsoydmAT2VovlEUSX6P46OabsuQse0rifQsXjINfT/JeiY7qcU/e6A/i8LoaE85HoVrdBVFkJ/eQjOipD+sHz0OSlBKx/TP5p+rDOio8ISehKW0RM36MF6UoqOmfGpMqhQsK7GjWtg/cX6hPVNt+eJt7US669APMElhbbL0G8pOT1JCbzuEfQ1oWn6nk3HNDRNnXbkxGMPmDh9ctO0aXgSWtPdx6A7JrIx6P/xxDoe3+HjRSHHMHaGMc8qfSxF10mJ5n6GyRaSPGOJ2lWYsA2kEP3Yr+o2ewS/XUVadvq4psv0sZ1Fts1oHjGMi2orDXqEaN1GsP/qTE5PbRLHkvbQ0xnR04mcnlXTTAw407qpxzWEY8lV9xhdDF5VGLyqQm2qEP+6MPAvhq6r+9b7+nqeZk+zp9nT7Gn2NHuaPc2eZk+zp9nT7Gn2NHuaPc2eZk+zpzmz7Wn2NNtKM9CgnyfgZ4ud0bYNNOpjnRA9DPP8rT7/wjzRz1JxftCbiDb652O1SfysWD/HMukoQm2+Rm3fRRiwnPVvJ+MYJ3/1tXTfnRBt+lfjwfKuZKJHy1c/f8fP0/W1OZ4v4xwv3XfYM/3W8jywLPEzen0sHtJfa3kquA+XdaWj6Ck26IE2VYi/uI0+twi1+Sn47Sq4fGz6+XfXoK9ig49dEE26TSyWoQmfq+kqMfB0Rnh0W8BSTY9llQ/sZmDR/K1GWHSb0lg2f7sx0MSDNa1v3REm6Lc8BKtu0ymW4UtVsF0pMjLBsWPDkP91iRn7KbSt+QeYe9JjXiXfXojOFLoOvvY6iFaia0t8bZ23o6+jjxeh7Q1imba6neaH5rWmHWxE5xJh2s3zuhrnVaE2PULwpwQt/p4GPT0NmkEm1UjPtB5xjg97tMAjnG/aA23rXx2fdPtK9D+OXVx5fVUG3Xq/HNGoj3VBdJnxAo8tTdskIzhu9Bsj7h9e4CDqK1kT9HO06nOSqseoOlnVKaoeq+pxqk5VdZqq01WdoepMVWepOlvV41Wdo+oJqp6o6kmqnqzqKaqequpcVU9T9XRVz1D1TFXPUnWeqmerOl/VBfH04Ar4FA9oiaH9Scb+Mcb+ZGN/irF/rLF/nLE/1difZuxPN/ZnGPszjf1Zxv5sY/94Y3+OsX+CsX+isX+SsX+ysX+KsX+qsT/X2D/N2D/d2D/D2D/T2D/L2J9n7J9t7M839hfEmxuj+VJeMr+SZTP5vuB3NGFfgyx/qbFpfLpMipP1Ne4YQv4NdoN/QyfT8U9OIeTfECf41ySPJeNfozyOkH91TvCvTk4l419STiPk31AX+NeUlNOp+NeYlDMI+TfMBf7VJeVMKv6pWD6LkH/bOsC/JoV5NhH/GlVfxxPy71cO8K9OYZ5DxD9FpjyBkH/b2c+/JsB8Ig3/GqGvkwj5t739/KsDzCfT8A/IlKcQ8m8H6/nXtArzqST8a1zV11xC/qWs51/dKsynkfBvFZnydEL+7Wg7/5rSmM+g4F9juq8zCfk33Hb+1aUxn0XBvzSZch4h/3aynH/jAsxnE2BuCPqaT8i/nS3n35AA84I43VwinrPLl3+7dBD/kvkVSTjPJocQ8m+EI/wjnCeSQwn5t6sj/COc55DbEvJvN0f4R3ifLrcj5N/ujvCP8D5T7kDIv5GO8I/wPknuSMi/PRzhH+E4X+5EyL9fO8I/wnGq3IWQf3s6wj/CcZbclZB/eznCP8JxgtydkH97O8I/wjgn9yDk3yhH+Efop+WehPwb7Qj/CP2M3JuQf2Mc4R+hnUhCnZFc/Isb/LMp5+wcwrkw6IM6v1Uvqh4j5uFxxLKmxq0Xf6fGPdXyOVpN57mEekkoaznVcr2BBfyPZtCbGZbjBj92LgPumY7Yy3mE9kIoaznTAXs5h0Fvjrcc99FM9jLHEXs5n9BeCGUtKfkHsoUXsfT4E3wELLJ7fjzzwbQL4iKrUI9VKd4V0H1daPlYFT6cM4nBpk6y3JeADl3IgPtkR3zJRYR6SShrebLlevNrJr2Zazlu8BEXMOA+zRF7WUhoL4Sylqcxxt6Lgpi7EMXeRcyxl/Ldut9YHnvhg3XHMNjUmZb7EtCh3zDgPssRX3IxoV4SylqeZbne7MmkN/Mtxw0+YhED7gWO2MslhPZCKGu5gDH2XhzE3EtQ7L2UOfZSvOOt+7rM8tgLH4qdzGBT51nuS0CHLmPAfb4jvuRyQr0klLU833K92YtJby6yHDf4iEsZcC90xF4WE9oLoazlQsbYe3kQcxej2Ptb5thLuSbK/1kee+ED7VMYbOpiy30J6ND/MeC+xBFfcgWhXhLKWl5iud7szaQ3l1uOG3zEbxlwL3bEXq4ktBdCWcvFjLH3iiDmXoli7xLm2EuxNpfua6nlsXdUPLOeJCUPr7Dcl4AOLWXAfaUjvuQqQr0klLW80nK9GcWkN1dZjht8xBIG3Fc7Yi9XE9oLoazl1Yyx96og5l6NYu/vmGMv5VqW11gee0fHM2s3U/JwmeW+BHToGgbc1zriS5YR6iWhrOW1luvNaCa9ud5y3OAjfseA+wZH7OVaQnshlLW8gTH2Lgti7rUo9l7HHHsp1lTWff3e8tg7Jp75TgIlD2+y3JeADv2eAffNjviS6wn1klDW8mbL9WYMk97cajlu8BHXMeC+zRF7uYHQXghlLW9jjL3XBzH3BhR7b2SOvZTfIPiD5bF3n3jmm0SUPFxuuS8BHfoDA+47HfElNxHqJaGs5Z2W680+THpzj+W4wUfcyID7Xkfs5WZCeyGUtbyXMfbeFMTcm1HsvYU59lJ8C0f39UfLY+++8cz3/yh5eL/lvgR06I8MuB9wxJfcSqiXhLKWD1iuN/sy6c3DluMGH3ELA+5HHLGX2wjthVDW8hHG2HtrEHNvQ7H3dubYS/ntuDssj737xTPf2qXk4eOW+xLQoTsYcD/hiC9ZTqiXhLKWT1iuN/sx6c1TluMGH3E7A+6nHbGXOwnthVDW8mnG2Ls8iLl3oth7F3PspfiGqe7rbstj7/7xzHftKXn4jOW+BHTobgbczzriS+4h1EtCWctnLdeb/Zn05nnLcYOPuIsB9wuO2Mu9hPZCKGv5AmPsvSeIufei2Hsfc+yl/Ob3nyyPvQco+mYx2NRLlvsS0KE/MeB+2RFfcj+hXhLKWr5sud4cwKQ3r1qOG3zEfQy4X3PEXh4gtBdCWcvXGGPv/UHMfQDF3geZY+9swtj7kOWx90BF32wGm3rdcl8COvQQA+43HPElDxPqJaGs5RuW682BTHrztuW4wUc8yID7HUfs5RFCeyGUtXyHMfY+HMTcR1DsfZQ59h5PGHsfszz2HqToO57Bpt633JeADj3GgPsDR3zJ44R6SShr+YHlenMQk958bDlu8BGPMuD+xBF7eYLQXghlLT9hjL2PBzH3CRR7n2SOvXMIY++fLY+9Byv65jDY1KeW+xLQoT8z4P7MEV/yFKFeEspafma53hzMpDdfWo4bfMSTDLi/csRenia0F0JZy68YY+9TQcx9GsXevzDH3hMIY+9fLY+9hyj6TmCwqW8s9yWgQ39lwP2tI77kGUK9JJS1/NZyvTmESW9+sBw3+Ii/MOBe4Yi9PEtoL4SylisYY+8zQcx9FsXe55hj74mEsfdvlsfeQxV9JzLY1E+W+xLQob8x4F7piC95nlAvCWUtV1quN4cy6U2s3G7c4COeY8AdL3fDXl4gtBdCWUtK/pmx9/kg5r6AYu/fmWPvSYSx90XLY+9hir6TGGyq2HJfAjr0IgPuEkd8yUuEekkoa1liud4cxqQ35ZbjBh/xdwbcFY7Yy8uE9kIoa1nBGHtfCmLuyyj2vsIce08mjL3/sDz2jlX0ncxgU50t9yWgQ/9gwF3liC95lVAvCWUtqyzXm7FMelNtOW7wEa8w4O7miL28RmgvhLKW3Rhj76tBzH0Nxd5/MsfeUwhj778sj72HK/pOYbCpnpb7EtChfzHg7uWIL3mdUC8JZS17Wa43hzPpzXqW4wYf8U8G3Os7Yi9vENoLoazl+oyx9/Ug5r6BYu+bzLH3VMLY+5blsfcIRd+pDDa1oeW+BHToLQbcvR3xJW8T6iWhrGVvy/XmCCa96WM5bvARbzLg7uuIvbxDaC+EspZ9GWPv20HMfQfF3neZY+9cwtj7nuWxt17RN5fBpja13JeADr3HgLufI77kfUK9JJS17Ge53tQz6c3mluMGH/EuA+4tHLGXDwjthVDWcgvG2Pt+EHM/QLH3Q+bYexph7P3I8tjboOg7jcGmtrbcl4AOfcSAextHfMnHhHpJKGu5jeV608CkN9Jy3OAjPmTAXeuIvXxCaC+Espa1jLH34yDmfoJi77+ZY+/phLH3P5bH3kZF3+kMNjXIcl8COvQfBtyDHfElnxLqJaGs5WDL9aaRSW+GWo4bfMS/GXAPc8RePiO0F0JZy2GMsffTIOZ+hmLv58yx9wzC2PuF5bF3nKLvDAab2s5yXwI69AUD7u0d8SVfEuoloazl9pbrzTgmvdnRctzgIz5nwD3cEXv5itBeCGUthzPG3i+DmPsVir1fM8feMwlj738tj71Nir4zGWxqF8t9CejQfxlwj3DEl3xDqJeEspYjLNebJia92d1y3OAjvmbAPdIRe/mW0F4IZS1HMsbeb4KY+y2Kvd8xx96zCGPv95bH3vGKvrMYbGpPy30J6ND3DLj3csSX/ECol4SylntZrjfjmfRmtOW4wUd8x4B7jCP2soLQXghlLccwxt4fgpi7AsXeH5lj7zzC2Ps/y2PvBEXfPAab2s9yXwI69D8G3Ps74kt+ItRLQlnL/S3XmwlMenOQ5bjBR/zIgPtgR+xlJaG9EMpaHswYe38KYu5KFHt/Zo69ZxPGXlACKj5z2NSRCuvZDDZ1mOW+ZJUOJehxj3XEl8QI9ZJQ1nKs5XpzJJPe1FuOG3zEzwx+osERe4kT2guhrGUDY+wFHwExN57IxN5EQmQV6tg7nzD2FlkeeycqrPMZbKrJcl8COlTE4EPHO+JLign1klDWcrzlegP2wqE3Ey3HDT4iwYD7KEfspYTQXghlLY9ijL3FQcwtQbG3lDn2LiCMvWWWx96jFNYFDLH3GMt9CehQGYMvmeyILykn1EtCWcvJlusN2AuH3hxnOW7wEaUMuKc6Yi8VhPZCKGs5lTH2lgcxtwLF3so2Ym8yvyK7EcqsMkHPGw2/j8jwBH43RvudAjvBvOwX/N8J8bIzateefqta6bcK9dslpN0mQbsuQbsiVbtGvH51K9evRtfv1sr1u6Hrdw9pt2nQrnvQDujqERBH7dN2jWd4gPvNV+9mWO7Ld4uneUqNe6YjvrwnoS8nlLWk5F8C6Q0u1LpE2FeyGNHZKxD6OsHvusHvesHv+uq3Lmhbhs5LUdEzMDm4BDopyuabLpUi47N0m1JVK9D/seB4HJ8THEugY4mirG5WHSsKdorRseLgWElwrBpdoxjxopiaF4oblYhmXUyepNA2pqeInh4JfO4e9DWhafpeMyZNmjh+YtPUPZqOH1U/cWoMkajJLjLIjolsCOb/UOIhx5hYLGOIBt13UQg7S+ivnYR+S+n7HajDu8aQQvSXIr7rNr2C364iMzTA/NCy1H10NnijfxmwSOi3nIlHFQaPNP3liEe6zYYGj/Rxk0eliEeaNxWIRwxYaqHfSiYedTJ4pOmvRDzSbTYxeKSPmzwqRzzSvOmEeMSAZUBZcD0OHlUZPKpE+DSPdJstDR7p4yaPcB+aN1XoP72Nw1xnRIc+1gXxVR/rGmzjsFkdbHdCx+Ih100guvQx7S+7oGPFCKc+hkMoFNCDZsOlVPCbzK+wzNtuJjL3j7jffMfGx1t+77K90oSeDLjnOHLv8gvCexdCWcs5DPNQmne/COYC1g9+10NzDRswz0fVEMpuQ0LZxQKs0GdNwKuw+z1By4/asMFzb3Xx3sE2071YbS73Yt0RTeT3IAPTA0KOGwGmAWwybDBeivY1r/SgKCZo9bUM9RtD1ylDotPb3VBb3U7zQ8saD3B1QC9v5bwi47wq1KYkBH9K0OIvNegxB/nF6Bi+t48h2rS7Wylo9Y3hplLiAZkQ2VgwH0SIDDjsCgaZejA7bfqUqfUTmsY01Y/DLi1sjkD/xkJgxNExvJ0IOSZE9tgTT/eYZohdWgk6Zt7bsY9bTcC673xj4UYJ2piUla8p0vaxUTBOWEfVmkSaeaZAwrAl8ysySddXkpPOGsLnYyWIzj6BlvYNfjcOfjcJfjcNxu/9g/b91P5mqvZXdXNVt1B1S1W3UnVrVbdR9ZeqwqS2VLVW1QGqDlR1kKqDVR0C88GqDlV1mKrbqvorVbdTdXtVdwCsqu6o6nBVd1J1Z1V3UXWEqruqupuqu6s6UtU9VP21qnuqulfAeJ6xTe14PLYx9TOO/tO/NSJ8zIMdRAyNg9YXmf/jIXPSiZA56aKQOenikDnpEmNOmiV+DkwOgX4rqPtN1tZBv53I+02PtfAkSApdB0/C6QkN6rFWZ9QvntzBE0F6ez3U1pwE0oGmEzpfx9CqVs4rN86rEtmTNyb+lKDFb074mRNXxWgbxlraLrZGtNGPwWvH4QkpgfgnDHp1KUX0cIzRQBfXDfpSz1FGzWiYNLFx5/rp9ftObWo6YOL0yU3TpuFBkKZ9a4N2c4Ck/486QOKavI8h/um+S0J4XEZ/7STPPUXtuLAHB5r+sAcH/YLflh4cmA9SOiPeMD84kDyT7WkeRXlwsLXBo04t8GgNPDio5XlwkOZRlAcHAw0eVbXAo9YeHDA9BFn1cKULE4+6GjzS9HdBPNJttjV4pI+bPOqMfqvQOVDiqG8cJ+Oojf5/ZXDc7APa8/AkORD6rSbvN81rPf+jea3p19crQm12QZjxuZquYoNXnRF/dFseLMnaSoMeIVqP99WInh7k9NTW4Qds7aGnB6KnOzk9ab9PjzMdc3sGfRHOla0a1/cyeFVt8KoKtemJ+NeLgX8xdF3dt97X1/M0e5o9zZ5mT7On2dPsafY0e5o9zZ5mT7On2dPsafY0e5o9zZ5mT7On2dPsaU55mj3NnuacaAZ69PNeTWslatfNEhr1MfyODMNz2Fbzrnog/hQhOqDAM/sf0DGGnI46oK0aXS8lmr9AWoTa9Ixl2v4UHOuM/u+G8HQ2jjHlBGXleuq+8Quxmkac+6Dp6cZEj5avzmktCeEFRy5jDOHUfet9/BKFpqMUHdN8wS8ia/7hF5F13hd+mVjbEM5v1bqNfYD2T/jl5LjI5k1bLzZXol8zFw2/XNIdHdM4sb1pO+uJ+nBZlxnoGRRGjymHmMh+hwy3wblzus1GgQ/pKrjyTdP5U1r+Zq4aftdOt9kY0YTP1XSF5appPDh+MGCpw/HM9NEYi26zucFf+piWfmeAHmta/3siTNBvlxCsus02KB4lg21srzi27RDyvy4xYz+Ftnug669Dj3kV2esiOlPoOvja+B0FomtLfG2dv66vo48Xoe3tY5m2up3mh+a1ph14rMdbmHbzvM7GeVWoTa8Q/ClBi38dg551DJpBJgOQnmk94soHDBvzYz+qeaTb4HeIGfI3Q8cUmg59vdZiAB5H6ja7Ih+F7xdwrNNtcczlGp+b70nrfXyPZfr7sMVW8Jjd9CmkBMOgadNEtqOCQr3YBuELkrJvgo6uvQhf3OyohQIpacb07p3IDFBKQug3dQNvl6F2lC/Um9c1aakOoZPNYHDnVH2CMPdO0Pc7itBIuHCPSpDLaJURJkTzQk0/5RvfnHT2ZaKTVm61WY5otKL5lGC7zLgWyfUGJgfiN8VNfYGguPrt7hzeFMcRPY7eHsezCwnj7fFqdCyGsGtHXEOFXSaTeCZjNZ0icyeur6nfhCo32qYC2ujfIk+vdIJljvkh0PV0wTzthLBo/jG8FZ3EI1l9p1Vl0APX7oroJ7p21iha32mZb7AVoe2NRKZ0Rf/jmThdqhH/uob8j9+E72Scg2eAhcjoiEC8qUJt8J1zp1bo4rwbqTLoxW+xQwHZdsRMnfn2MJ451b/4DVsoICNzRlbbayejbUqw2YKMOguC5av5jAeRDDPpybBZvG4GPfiukNpeu6N+8SycPo5nEAeLTOmB/te8wnfQevYqjtri/7H/qTbOwTNkQmTPDmjeVKE2+K3b6lbowm8LpgQtH823UbsZmEC2myM6GN7UbdVvYB50Zbg2XvpVl9ZsrWsIPYS6naxC9OBrcTwNi/q2Ldbh6lZorKGjMYmfJOG3rndG9OI332tQe7wwkW6zB2q7a7CN327HT7/Mt9vxWFX/p59M6f6rQ/hB7fvwE0xsw3gsotuMQnhnI9rIx8ABbdgmakRGBpjmbuhYjWi+5Bx+e34/hC1m8LRGZMteH+9u9F8cwh/d5iD0Xxwdx/YW9pRHt8Ors+DMkFSwncyvNHvqgmnphY7rNoeLbH71bIHu8pBzG1o4V/NBjz11H50RLTgGdmvhmvipZFcDU7cQTLrNkQZdXVvov1PIuUe3cK7G1DkEk2lPWKf0KqBhGTOYB6lgO5lfaWZTWC7dQ/BORbyZFUJ/cQv047iDn5p2Z8CE40f3EHo72lfpvs2J2jBfFeZLdJuT0H9hS7ubcStrIxX85juxOIphGefRieYDgzgj3fn2NYaQBx31BIJyUjGO6NwnuBPcN5FxhkwTgANyWQYbpzm155NE1SHtyjJdkk7q4aV+yfpVE7M4FUr3D1gqstmzevKhzGibEnxLneGJTF1auynQtOEJFSwXhmW0kviGsaUUInyzSh2Q8dKSePJQH8fLkeml54XInkzUvMITVWFLa+H/O6HrVhrnhA1u8BLkmr6uRl9CZE+EmXRx3XjHRMvpdDhg4hsqjsnx1lIMMA8YlmFdZWtYvlDaM9GH6aFcPqpKhC8XyGDDEvuL9mDHOlwZQqMNE7FVIfRQPrmvMvigr8Vgn0n8EA7bo0TXpV8GXybxgxDt2xNoHwp+qPEr9N+gYBungFagY609BMAPvcqMc/HYBZ+LJ9l1H3g5SX1+DNFuYsJLU3Mtt4wnVjAtOF7pNsODX33DXNQC3WUh5+7SwrlCZMcjnEJuTtbFjWtCWWm0xTbZpZXzzO1OxjnY3xWH0IQfmNFPfGfruu47YdCI+VhitMETHrrNmOC3Jfl1Qn3p/s3JGJzKqI/rNvsb/Xdtof+ykHMPauFcIbL1Ay/nXYTOgRL2MG6l0RbrR2vnmdvmDTuONUUhNOExZ1dESyrYTuZTZDo5BN8fFIXQZ37LDt8LpQStH8G2BP2GfbsU6xduE+a7JyI8lSFtcbyJUd9wwyTB6A7Mlop6nTYmOVr9/kkyvyL3cSLDSWZlOO3nM5xWY/cZTj7DCfPHZzilSzK/4jOciOj3GU6t88dnOKVLMr/iM5x8hpPPcBI+wylFSJvPcPIZTj7Dic+mfIYTPV913x2a4eTKhJ3Octov0fx9Vyrage4xCfpsr/2JJ+o4JhL3Z8B9QIJe/tDnqUzy35eJDwcy8OFAxAddEgx60c6+ZBv/J/clzBw8yHJ76sukRyeV8+Km8HMHMeA+mRi3LnFiuRPKR3Jhpl7fhNJH7EfoIw6O4CPa8xCP2keArRzMYCuHMMSaQ9oRa/KlmzI+UOrRoRH42da1uPToUAY9OoxBjw4L9KijsvUplyqJIzrHBsp/uM/Wj1Z8tv7q0toEt8/W99n6ufLRZ+v7bP32YvfZ+j5b32frR2cozr722frZ5/hsfZ+t77P120cN9hu67w7N1hfGRooIGOUDr7UhU3+sg5n6R/hM/dXYfaa+z9TH/MHX9pn6+fHRZ+r7TH2fqZ8uKeEz9dtLh8/UTxefqZ9dfKZ+tsx8pn52/1j2+rjP1PeZ+rrN0S2cqzH5TP108Zn6lqxFmsyvkE7W6UyfIxiz9IHesQwZT/UMfKhnzFYHPhzOwIcGBj40dEC2eoRJ1jYzUQ8nzCBstDxbvYYpW32uA9nqjQy4T3MkW51QPvI0R7LVKX3EEYQ+YpwD2erjGGyliSHWNHVAtjplfKDUo/EOZKuPZ9CjCQx6NAFlq4c9gKbmDddybv5htpoQUDRfF2wX8sPsKoMmzQ/6rMP0DTMuKbRdHEJPwjJ6iiyjJ2YBPZVChL6FgjOq9DE9KZJAx8yEB6z/+BpmJifW/1L0K0OuFw+5XklIu47gJ75WSjR/Q6UzoqPEEnqKLKMnYRk9cYMe/H8x+j+B+sJv0MB+qXEetiH89o9pG+XCJyQJxFdcUmjbJyS1npCkH2QK4ROSTD62JyFpGKLDJyQ1p98nJLXOn6gJSWNFpviEpGw+tichaTSiwyckNaeHULd9QpJRWkpImoTojZKQNA21nRJsr80JSbMR3qWINlcSkvBDfo6EpLnov7hwPyFpnsjmV5SEpAUtnKv5sKYSki406IqSkLSohXM1prUtIWkx4s2SEPptTkhagraXIhpcSUhahv5rKSEJx62sjRQRMI6EpCMTzQcGnMslUj6ozrevMzvo4Xwbp7b5QP1IQswT6XRIYv7lSxeXvUxkeKh6FIMdHtUBiWCUS8lRPuif50iSDKUdHk1oh/OYE8qS+ZVVdng0gx1OYrDDSSF2GCemezShHh1DqEeuLz84OTD4KX75wWjFLz+4urQ2SeaXH/TLD+bKR7/8oF9+sL3Y/fKDfvlBv/xgdIbGhF9+UBe//KBffhCfZ2775Qdbpgb7Dd13hy4/SH3DDd/uOiaRDYig37ViCcLJDr61caxfgnA1dp/x6zN+MX+iZvz6JQhb5qNfgtBn/PolCNMlJfwShO2lw2f8povP+M0ufgnCbJlFzfgdhfD6JQgz/fslCJuf29DCuZoPfglCvwQhBSa/BKFDE3Y6y+lYxmUINe3U2V7HWb5cHEwkHseAeypDlttUxuUXpzDxYRoDH6Z1QNZthAnmNjPBpxBmDk53YPlFDj2ab/nyi4B5OgPuBY4sv0goH7nAkcxySh9xLKGPmGH58otgKzMYbGUmQ6yZ2QHLL1LGB0o9mmX58ougR7MY9Gg2gx7NRssvxkTzQs2bvkzZ+scHyj/HZ+tHKz5bf3VpbYLbZ+v7bP1c+eiz9X22fnux+2x9n63vs/WjMxRnX/ts/exzfLa+z9b32frtowb7Dd13h2brC2MjRQSM8oHX2pCpf7yDmfon+Ez91dh9pr7P1Mf8wdf2mfr58dFn6vtMfZ+pny4p4TP120uHz9RPF5+pn118pn62zHymfnb/PlPfZ+r7TH2fqZ8PX3XfHZqpL4yNFBGw4xgyfU5gzNIHeo9nyHg6kYEPJzJmqwMf5jDw4SQGPpzUAdnqESZZ28xEnUOYQXiy5dnqfZmy1c9zIFv9ZAbc5zuSrU4oH3m+I9nqlD7iBEIfcYoD2eqnMNjKqQyx5tQOyFanjA+UejTXgWz1uQx6dBqDHp2GstXDHkBT84ZrOTf/MFuI0xXN1wXbhfwwu8qgSfODPuuwfR+fx/QkLKOnyDJ6YhbQUylE6FsoOKNKH9OTIgl0zEx4wPqPr2FmcmL9L0W/MuR68ZDrlYS06wh+tufj8zGDxjVNT5Fl9CQsoydu0IP/L0b/J1Bf+A0a2C81zsM2hN/+MW2jXPiEJIH4iksKbfuEpNYTkvSDTCF8QpLJx/YkJA1DdPiEpOb0+4Sk1vkTNSFprMgUn5CUzcf2JCSNRnT4hKTm9BDqtk9IMkpLCUmTEL1REpKmobZTgu21OSFpNsK7FNHmSkISfsjPkZA0F/0XF+4nJM0T2fyKkpC0oIVzNR/WVELShQZdURKSFrVwrsa0tiUkLUa8WRJCv80JSUvQ9lJEgysJScvQfy0lJOG4lbWRIgLGkZB0eqL5wIBzuUTKB9X59nVRBz2cb+PUNh+on06I+Qw6HZKYf/nSxWUvZzA8VD2TwQ7P7IBEMMql5Cgf9C9yJEmG0g7PIrTDRcwJZcn8yio7PIvBDucx2OG8DrDDGkI92oSwr7OJVycwxxUcunU2sQ7oMj/RfNAoRMtjJbxdhtpRLslkXtekpTqEzmYySBESwyHM+Qn6fhck7B6oAO4FCXIZJTsqQ2sTRzK0apzI0KrNckTn+OVGVmP3T/f9033Mn6hP9/1yIy3z0S834p/u++VG0iUl/HIj7aXDP91PF/90P7v45UayZRb16f4ohNcvN5Lp3y830vzchhbO1Xzwy4345UYoMPnlRlp5up/3x9wStEwCp3hOyNP9OCPd+fZ1LiEPOuoJBOWkYhzReV5wJ3i+/5hStOI/prS6tHZT4D+m5D+mlCsf/ceU/MeU2ovdf0zJf0wp7IMc/mNKrTM0JrInVjAt/mNK/mNKYZMxRYg/+rhu4z+m1Pw6/mNK6YL1mfxjStQ33DBJcE4HZktFvc6a/KDSeQ6uQXWBz3Bajd1nOPkMJ8wfn+GULsn8is9wIqLfZzi1zh+f4ZQuyfyKz3DyGU4+w0n4DKcUIW0+w8lnOPkMJz6b8hlO9HzVfXdohpMrE3Y6y+kCxo8qAd3nMry7fqHlH7+BicQLGXBfxPDO/kWMH5M6n4kPCxn4sLAD1i6IMMHc5ro251OuIWK5PdUw6dHFln9MCjAvYsB9iSMfkyKUj7zEkXVyKH3EBYQ+4jeWf0wKbOU3HD6CIdZc3AEfk6KMD5R6dInlH5MCPbqEQY8uZdCjS9HHpGKieaHmDeVSJXFE52WB8l/us/WjFZ+tv7q0NsHts/V9tn6ufPTZ+j5bv73Yfba+z9b32frRGYqzr322fvY5PlvfZ+v7bP32UYP9hu67Q7P1hbGRIgJG+cBrbcjUv8zBTP3FPlN/NXafqe8z9TF/8LV9pn5+fPSZ+j5T32fqp0tK+Ez99tLhM/XTxWfqZxefqZ8tM5+pn92/z9T3mfo+U99n6ufDV923FWuRJvMrpJN1OtNnMWOWPtB7GUPG028Z+PBbxmx14MPlDHz4PwY+/F8HZKtHmGRtMxP1csIMwissz1bfhClb/XIHstWvYMC92JFsdUL5yMWOZKtT+ojFhD7iSgey1a9ksJUlDLFmSQdkq1PGB0o9WupAtvpSBj26ikGPrkLZ6mEPoKl5w7Wcm3+YLcTViubrgu1CfphdZdCk+UGfdZi+YcYlhbaLQ+hJWEZPkWX0xCygp1KI0LdQcEaVPqYnRRLomJnwgPUfX8PM5MT6X4p+Zcj14iHXKwlp1xH8xNdKieZvqHRGdJRYQk+RZfQkLKMnbtCD/y9G/ydQX/gNGtgvNc7DNoTf/jFto1z4hCSB+IpLCm37hKTWE5L0g0whfEKSycf2JCQNQ3T4hKTm9PuEpNb5EzUhaazIFJ+QlM3H9iQkjUZ0+ISk5vQQ6rZPSDJKSwlJkxC9URKSpqG2U4LttTkhaTbCuxTR5kpCEn7Iz5GQNBf9FxfuJyTNE9n8ipKQtKCFczUf1lRC0oUGXVESkha1cK7GtLYlJC1GvFkSQr/NCUlL0PZSRIMrCUnL0H8tJSThuJW1kSICxpGQdHWi+cCAc7lEygfVeSegdNDD+TZObfOB+tWEmH9Hp0MS8y9furjs5XcMD1WvYbDDazogEYxyKTnKB/1LHEmSobTDZYR2uIQ5oSyZX1llh8sY7PBaBju8NsQO48R0n0OoR9cR6pHryw/+PjD46/3yg9GKX35wdWltkswvP+iXH8yVj375Qb/8YHux++UH/fKDfvnB6AyNCb/8oC5++UG//CA+z9z2yw+2TA32G7rvDl1+kPqGG77ddV0iGxBBv2vFEoS/d/CtjRv8EoSrsfuMX5/xi/kTNePXL0HYMh/9EoQ+49cvQZguKeGXIGwvHT7jN118xm928UsQZsssasbvKITXL0GY6d8vQdj83IYWztV88EsQ+iUIKTD5JQgdmrDTWU43MC5DqGmnzva60fLl4mAi8UYG3H9gyHL7A+Pyi9cz8eEmBj7c1AFZtxEmmNvMBL+eMHPwZgeWX+TQo6ssX34RMN/MgPtqR5ZfJJSPvNqRzHJKH3EDoY+4xfLlF8FWbmGwlT8yxJo/dsDyi5TxgVKPbrV8+UXQo1sZ9Og2Bj26DS2/GBPNCzVvapiy9W8PlP8On60frfhs/dWltQlun63vs/Vz5aPP1vfZ+u3F7rP1fba+z9aPzlCcfe2z9bPP8dn6PlvfZ+u3jxrsN3TfHZqtL4yNFBEwygdea0Om/u0OZuov95n6q7H7TH2fqY/5g6/tM/Xz46PP1PeZ+j5TP11Swmfqt5cOn6mfLj5TP7v4TP1smflM/ez+faa+z9T3mfo+Uz8fvuq+OzRTXxgbKSJgNzJk+ixnzNIHem9nyHi6k4EPdzJmqwMf7mDgw10MfLirA7LVI0yytpmJegdhBuHdlmer1zBlqy9zIFv9bo61nR3JVieUj7zWkWx1Sh+xnNBH3ONAtvo9DLZyL0OsubcDstUp4wOlHt3nQLb6fQx69CcGPfoTylYPewBNzRuu5dz8w2wh7oc3e4PtQn6YXWXQpPlBn3XYvo/PY3oSltFTZBk9MQvoqRQi9C0UnFGlj+lJkQQ6ZiY8YP3H1zAzObH+l6JfGXK9eMj1SkLadQQ/2/Px+ZhB45qmp8gyehKW0RM36MH/F6P/E6gv/AYN7Jca52Ebwm//mLZRLnxCkkB8xSWFtn1CUusJSfpBphA+IcnkY3sSkoYhOnxCUnP6fUJS6/yJmpA0VmSKT0jK5mN7EpJGIzp8QlJzegh12yckGaWlhKRJiN4oCUnTUNspwfbanJA0G+FdimhzJSEJP+TnSEiai/6LC/cTkuaJbH5FSUha0MK5mg9rKiHpQoOuKAlJi1o4V2Na2xKSFiPeLAmh3+aEpCVoeymiwZWEpGXov5YSknDcytpIEQHjSEi6P9F8YMC5XCLlg+q8l9bqoIfzbZza5gP1+wkxP0CnQxLzL1+6uOzlAYaHqg8y2OGDHZAIRrmUHOWD/hsdSZKhtMOHCO3wRuaEsmR+ZZUdPsRghw8z2OHDHbwU36bEGHR5JNF80CNEy7Eeb5ehdpRLCpnXNWmpDqGzmQxShMRwCPORBH2/jybsDrSA+9EEuYySHWWEmzAZ4WPeCNsmhkOYjzEY4eOWGyHgfpzBCDloPZcptf4Jy18peDSQETXuJy3HPUbRdxwD7j8z46bQR5AN9Z0coZ7LJwn92lOW6yHoy1MMevi05bh7K/qeZooNusQZeZpvX39J8I5Z8qUPXjX7C4Ne3mT5zEBfJtw3O/KqGaF85M2Wv1bYm0nWt1qu4xsz4b7NER0nlI+kxNxRkwt9mSYX/uonF9omhkOYf2WYXHjG8skFwP2MwzN8GzMZ4bPeCNsmhkOYzzIY4XOWGyHgfs6RGb5nAlqpRz1/s/xOG2b3/saA+3liB4aXbgfnDg5o4+B30+B3k+AXyguB3lHjghnR5xn49XfCO349ItaFWmf6EMq2f9DPi6rPl1R9WdVXVP2Hqq+q+pqq/1T1X6q+ruobqr6p6luqvq3qO6q+q+p7qr6v6geqfqjqR6p+rOonqv5b1f+o+qmqn6n6uapfqPqlql+p+rWq/1X1G1W/VfU7Vb9X9QdVV6j6YyJ9l6Gfub+YyCRAwv5Lxv7Lxv4rxv4/jP1Xjf3XjP1/Gvv/MvZfN/bfMPbfNPbfMvbfNvbfMfbfNfbfM/bfN/Y/MPY/NPY/MvY/NvY/Mfb/bez/x9j/1Nj/zNj/3Nj/wtj/0tj/ytj/2tj/r7H/jbH/rbH/nbH/vbH/g7G/wtj/MdHyAC0V/CbzK1k2na8ve5Gwr+WW51o1jU+XlxJkfY17mZB/d7rBv6Gv0PFP/oOQf3c5wb8m+SoZ/xrla4T8u9sJ/tXJf5LxLyn/Rci/e1zgX1NSvk7Fv8akfIOQf/e6wL+6pHyTin8qlr9FyL/7HOBfk8L8NhH/GlVf7xDy708O8K9OYX6XiH+KTPkeIf/ut59/TYD5fRr+NUJfHxDy7wH7+VcHmD+k4R+QKT8i5N+D1vOvaRXmj0n417iqr08I+feQ9fyrW4X53yT8W0Wm/A8h/x62nX9NacyfUvCvMd3XZ4T8e8R2/tWlMX9Owb80mfILQv49ajn/xgWYvyTA3BD09RUh/x6znH9DAsxf54+5Vi9c/V9C/j1uN/+kxvxN3pjrxuu+viXk3xNW86+uQWP+Ln/+rV44/XtC/j1pNf+GrMb8Q96YB63uawUh//5sNf/kasw/JuiepSwnXGfgKTvWfGirSMLnDPIuQv497Qj/COfJ5T2E/PuLI/wjnOeV9xHy76+O8I9wnlLeT8i/ZxzhH+E8m3yQkH/POsI/wnki+TAh/55zhH+E8xzyUUL+/c0R/hHep8vHCfn3vCP8I7zPlE8S8u8FR/hHeJ8knyLk398d4R/hOF/+hZB/LzrCP8JxqnyGkH8vOcI/wnGWfI6Qfy87wj/CcYJ8npB/rzjCP8I4J/9OyL9/OMI/Qj8tXyLk36uO8I/Qz8hXCPn3miP8I7QTSagzkot/cYN/Nr1z8D/CZwHQB/X7V/Bu298T9O+g/ZSglTU17n6JzLtXlLhjFXbjBn38iQF3vKJjfGO+dK4ktEdCWcu45XoD9vI/Br0pthz3i0z2UuKIvfxMaC+EspaU/NPvhOtxBPgIePf750TmHfDVL4wHhXrM8RLhmAM+EE3FZw6b2iyRec+ZkofllvsS0CGQDTXuCkd8SZxQLwllLSss1xuwFw696Ww5bvARggF3lSP2kiC0F0JZyyrG2As+AmJuoigTe4uYYy/lO/LFlsfe/onMmiKUPKy23JeADhUz+JJujviSEkK9JJS17Ga53oC9cOhNT8txg48oYsDdyxF7KSW0F0JZy16MsbckiLmlKPaWMcfeVwhjb7nlsXfzRGb9Lkoerme5LwEdKmfwJes74ksqCPWSUNZyfcv1BuyFQ282tBw3+IgyBty9HbGXSkJ7IZS17M0YeyuCmFuJYm8n5thLubZZZ8tj7xaJzFqZlDzsY7kvAR3qzOBL+jriS6oI9ZJQ1rKv5XoD9sKhN5tajht8RCcG3P0csZcuhPZCKGvZjzH2VgUxtwuKvV2ZY++rhLG32vLYu2Uisy41JQ83t9yXgA5VM/iSLRzxJd0I9ZJQ1nILy/UG7IVDb7a2HDf4iK4MuLdxxF66E9oLoazlNoyxt1sQc7uj2NuDOfZSrknd0/LYu1Ui8w0ISh5Ky30J6FBPBl9S64gv6UWol4SylrWW6w3YC4feDLIcN/iIHgy4BztiL+sQ2guhrOVgxtjbK4i566DYuy5z7P0nYexdz/LYu3Ui870lSh4OtdyXgA6tx+BLhjniS9Yn1EtCWcthlusN2AuH3mxnOW7wEesy4N7eEXv5BaG9EMpabs8Ye9cPYu4vUOzdgDn2Un5LaEPLY+82icy3DSl5uKPlvgR0aEMGXzLcEV/Sm1AvCWUth1uuN2AvHHqzi+W4wUdswIB7hCP2shGhvRDKWo5gjL29g5i7EYq9Ncyx93XC2NvH8tj7y0TmO8KUPNzdcl8COtSHwZeMdMSX9CXUS0JZy5GW6w3YC4fe7Gk5bvARNQy493LEXjYmtBdCWcu9GGNv3yDmboxi7ybMsZfyG7CbWh57kwrrGwyxd7TlvgR0aFMGXzLGEV/Sj1AvCWUtx1iuN2AvHHqzn+W4wUdswoB7f0fsZTNCeyGUtdyfMfb2C2LuZij29meOvW8Sxt7NLY+9UmF9kyH2HmT7GglKLpsz+JKDHfElWxDqJaGs5cGW6w3YC4feHGY5bvAR/Rlwj3XEXrYktBdCWcuxjLF3iyDmboli71bMsfctwti7teWxt1ZhfYsh9tbbnq+q5LI1gy9pcMSXbEOol4Sylg2W6w3YC4feNFmOG3zEVgy4xztiL78ktBdCWcvxjLF3myDm/hLF3iRz7H2bMPZKy2PvAIX1bYbYO9H2uUMlF8ngS45yxJfUEuoloazlUZbrDdgLh94cYzlu8BFJBtyTHbGXAYT2QihrOZkx9tYGMXcAir0DmWPvO4Sxd5DlsXegwvoOQ+w9znJfAjo0iMGXTHXElwwm1EtCWcuptutNgkdvZliOG3zEQAbcMx2xlyGE9kIoazmTMfYODmLuEBR765hj77uEsXeo5bF3kML6LkPsPd5yXwI6NJTBl8xxxJcMI9RLQlnLOZbrDdgLh96cZDlu8BF1DLhPdsRetiW0F0JZy5MZY++wIOZui2Lvr5hj73uEsXc7y2PvYIX1PYbYO9dyXwI6tB2DLznNEV+yPaFeEspanma53oC9cOjNmZbjBh/xKwbcZzliLzsQ2guhrOVZjLF3+yDm7oBib4o59r5PGHt3tDz2DlFY32eIvfMt9yWgQzsy+JIFjviS4YR6SShrucByvQF74dCb8yzHvconMuA+3xF72YnQXghlLc9njL3Dg5i7E4q9OzPH3g8IY+8ulsfeOoX1A4bYe5HlvgR0aBcGX7LQEV8yglAvCWUtF9r+rCLBozcXW44bfMTODLgvccRediW0F0JZy0sYY++IIObuimLvbsyx90PC2Lu75bF3qML6IUPsvdxyXwI6tDuDL1nsiC8ZSaiXhLKWiy3XG7AXDr25wnLc4CN2Y8B9pSP2sgehvRDKWl7JGHtHBjF3DxR7f80cez8ijL17Wh57hymsHzHE3qss9yWgQ3sy+JKrHfElexHqJaGs5dWW6w3YC4feLLMcN/iIXzPgvtYRe9mb0F4IZS2vZYy9ewUxd28Ue0cxx96PCWPvaMtj77YK68cMsfd6y30J6NBoBl9ygyO+ZAyhXhLKWt5gud6AvXDozU2W4wYfMYoB982O2Ms+hPZCKGt5M2PsHRPE3H1Q7N2XOfZ+Qhh797M89v5KYf2EIfbearkvAR3aj8GX3OaIL9mfUC8JZS1vs1xvwF449Ga55bjBR+zLgPtOR+zlAEJ7IZS1vJMx9u4fxNwDUOw9kDn2/psw9h5keezdTmH9N0PsvcdyXwI6dBCDL7nXEV9yMKFeEspa3mu53oC9cOjN/ZbjBh9xIAPuBxyxl0MI7YVQ1vIBxth7cBBzD0Gx91Dm2Psfwth7mOWxd3uF9T8Msfdhy30J6NBhDL7kEUd8yVhCvSSUtXzEcr0Be+HQm8ctxw0+4lAG3E84Yi+HE9oLoazlE4yxd2wQcw9HsfcI5tj7KWHsrbc89u6gsH7KEHufstyXgA7VM/iSpx3xJQ2Eekkoa/m05XoD9sKhN89Yjht8xBEMuJ91xF4aCe2FUNbyWcbY2xDE3EYUe8cxx97PCGNvk+WxN6WwfsYQe5+33JeADjUx+JIXHPEl4wn1klDW8gXL9QbshUNvXrIcN/iIcQy4X3bEXiYQ2guhrOXLjLF3fBBzJ6DYeyRz7P2cMPZOtDz27qiwfs4Qe1+13JeADk1k8CWvOeJLjiLUS0JZy9cs1xuwFw69ed1y3OAjjmTA/YYj9nI0ob0Qylq+wRh7jwpi7tEo9k5ijr1fEMbeYyyPvcMV1i8YYu/blvsS0KFjGHzJO474ksmEekkoa/mO5XoD9sKhN+9bjht8xCQG3B84Yi9TCO2FUNbyA8bYOzmIuVNQ7D2WOfZ+SRh7j7M89u6ksH7JEHs/ttyXgA4dx+BLPnHEl0wl1EtCWctPLNcbsBcOvfnUctzgI45lwP2ZI/YyjdBeCGUtP2OMvVODmDsNxd7pzLH3K8LYO8Py2LuzwvoVQ+z90nJfAjo0g8GXfOWIL5lJqJeEspZfWa43YC8cevON5bjBR0xnwP2tI/Yyi9BeCGUtv2WMvTODmDsLxd7ZzLH3a8LYe7zlsXcXhfVrhtj7g+W+BHToeAZfssIRXzKHUC8JZS1XWK43YC8cevOT5bjBR8xmwL3SEXs5gdBeCGUtVzLG3jlBzD0Bxd4TmWPvfwlj70mWx94RCut/GWJvrNJuXwI6dBKDL4lXuuFLTibUS0JZy7jlegP2wqE3xZbjBh9xIgPuEkfs5RRCeyGUtaTknxl7Tw5i7iko9p7KHHu/IYy9cy2PvbsqrN8wxN5yy30J6NBcBl9S4YgvOY1QLwllLSss1xuwFw696Ww5bvARpzLgrnLEXk4ntBdCWcsqxth7WhBzT0ex9wzm2PstYew90/LYu5vC+i1D7K223JeADp3J4Eu6OeJLziLUS0JZy26W6w3YC4fe9LQcN/iIMxhw93LEXuYR2guhrGUvxth7VhBz56HYezZz7P2OMPbOtzz27q6wfscQe9ez3JeADs1n8CXrO+JLFhDqJaGs5fqW6w3YC4febGg5bvARZzPg7u2IvZxDaC+Espa9GWPvgiDmnoNi77nMsfd7wth7nuWxd6TC+j1D7O1juS8BHTqPwZf0dcSXnE+ol4Syln0t1xuwFw692dRy3OAjzmXA3c8Re7mA0F4IZS37Mcbe84OYewGKvRcyx94fCGPvRZbH3j0U1h8YYu/mlvsS0KGLGHzJFo74koWEekkoa7mF5XoD9sKhN1tbjht8xIUMuLdxxF4WEdoLoazlNoyxd2EQcxeh2Psb5ti7gjD2Xmx57P21wrqCIfZKy30J6NDFDL6k1hFfcgmhXhLKWtZarjdgLxx6M8hy3OAjfsOAe7Aj9nIpob0QyloOZoy9lwQx91IUey9jjr0/Esbeyy2PvXsqrD8yxN6hlvsS0KHLGXzJMEd8yWJCvSSUtRxmud6AvXDozXaW4wYfcRkD7u0dsZffEtoLoazl9oyxd3EQc3+LYu//tRF7k/kV2YtQZv9XRM+bmqC//iLNkz7B7+YF9ruVqlcE/gDz5YqiwuQH5suVRWn/o30l/Go7EegYlFTwm8yvyP6C3o9S09hH0NqjLksUv7sE22XoeIrqegOTA0qgk8D3mbLEPpPwmknoN0Hdr5JDqeqjNOirEmg3cFWjYzGEsYiBlhjCqPvW+/p6Fap2DraPrW88esepE2Yc0zR5+jSsBLoxPhZmgPGQ//A5cQS4mBlwzACsr1eJtovQsbjRrtygfTWxFISKEKZQ9X1lEV2UX0IY5UEQJaJ5ofaEvRM8o14qHRjcMH6cHDeogZMHVxbx8ICazg0TbtBZLOzWKV2w460MtpcqXbhK1atV/Z2q16i6TNVrVb1O1d+rer2qN6jaLziHJ9JLiSO96QvAD8Z0ZAx+a4LjiWA/YRwvCvaLUESF48XBfnFRNj9Wjy6C43BsdcBAx3RgiKNjOjAk0DGNoQgd09FfXxv2NwiOsUT6gcnBTAG1oQzhIex39R2fCOhOYb4hXpVr2QjaQUIZ6jeGrqOPF6HtX6C2up3mh9YnTTuMpLROlLdyXpFxXhVqUxKCPyVo8Zca9JQaNIMMugbbMGItQfqtaaugp62hUmT7Hs0/YdCrSwUzr6D/9YK+miYfN6NpRtOoGQ2TJjaOmDG5cfrEKZN3qp80CTtdTXylQbw5Etb/YyeIb33wsB3PChWjbXxuacixsALXxUzTxzQ95eiYpqcCHUugbd2ebZScEM3vB4Wgj+5XMY2WiPgh9QbmxY2BVvyhKCP0lpRJ80wfA77+bPynf2Po/J9F67d0sRb6qQyhozrkGJviaLDApDeMaySIr3VV/rdbtcHtlryR8NbtD0xKTX27Son5ppC+GpKN4wbJhsHjhsim+kF1jY1DB0hZWz+4fnBDbd34poZBsm5Qneqzsb62Tl2utr5RNiXrBzfhSUZcqJ3PTcQT6brcXJSJFiUh9OuSCNkuQ+1WEmI1r2vSUh1CJ+scDIcwby6i7/cWQiPhwn1LEbmMQmmlcIy3MDxt3bGDnrYmcyyaTkpd+iPhk9sdiZ+2QqAC+voEPOyIkeTVdo8kdanFvLg1sNvb/EiyWVk9kgQm/YTA31bUciSluvbVBIbaND5dbiU0+tscGVlSYr4d9SXrBtTWDhkA7erGJeXAcY21dbW14xoGJhuT9Y21TUMHyqHjB9YOHNA4rrFB9VkvxyfH1zcOHV+XpqujRpa3M40s7/Ajy7aJ4RDmHQwjy+WWjywB93JHRpa3BbRS93snsSGDo4U+4yIT0OCJ0FLRcSOlax2cc7sr0MO7/UipOcM02LuCOTe9D8yqMa5JPVK6lnAO7i5Ch3i3IyMlSsz3ODgHdw/TSOleP1JqmxgOYd7LMFK6z/KREuC+z5GR0t0BrdT97uTIHBylLv2JcA5uJ4Y5uD918BzcdQ7Owd0f2O0DfmTZrKweWd4fzMHhQj2SvI5wzu1+QiN/wJGRJCXmBx2cc3uQaST5kB9Jtk0MhzAfYhhJPmz5SBJwP+zISPKBgFbqfh9hmHN7JJhz66iR0O8dHAk9GujdY34k1KysHgk9ajyNfKwDnkb+nnBk9CihA3zMkZERJebHHRwZPc40MnrCj4zaJoZDmE8wjIyetHxkBLifdGRk9FhAK3W/f2YYGf25g0dG1zv49PGpQO+e9iOj5gzTYJ8ynj4+3QFPH68nfPr4FKEDfNqRkREl5r84+PTxL0wjo7/6kVHbxHAI868MI6NnLB8ZAe5nHBkZPR3QSt3vLo48faTUpWcJnz7uwvD08dng6SMu1AGsN+GapkuZgja1vf+BQIfqBiZrm1Qgbk02eX/rj26FEenKgGpDQn18jtC+tU0+FzIop+YB5SpINzhikx31kDhffhKupiMfcwQz4apU8hpHMMcI5fy7DrLBfDH/jYBOvUIY0IbXP4S+4WbstuAXFuZ4PhjHQrunESb4H3QOfpcF7e8uyl5Pszj43TBod2VRYa8v6n/9r//1v/43+3dLVV9AcUbPR+j48nwQN14Ifrup+vdgLoh6jFuj+tha0MftFx25t6PE/JIjmGOEmF92BHOcEPMrjmBOEGL+hyOYiwgxv+oI5mJCzK85grmEEPM/HcG8JSHmfzmCeXNCzK8XIOY3ChDzmwWI+S1HML9I+Bzh7QKU8zsFiPndAsT8XgFifr8AMX9QgJg/LEDMHxUg5o8LEPMnBYj53wWI+T8FiPnTAsT8WQFi/rwAMX9RgJi/LEDMXxUg5q8LEPN/CxDzNwWI+dsCxPxdAWL+vgAx/1CAmFcUIOYfCxDz/woQ808FiHllAWL+uQAxw8sPhYY5VoCY4wWIOVGAmIsKEHNxAWIuKUDMpQWIuawAMZcXIOaKAsRcWYCYOxUg5s4FiLmqADF3KUDMXQsQc3UBYu5WgJi7FyDmHgWIuWcBYu5VgJjXKUDM6xYg5vUKEPP6BYj5FwWIeYMCxLxhAWLuXYCYNypAzDUFiLlPAWLuW4CYNy5AzJsUIOZNHcG8DuF62P0cwbwuIebNHMG8HiHm/o5gXp8Q8+YF6MO2KEDMWxYg5q0KEPPWBYh5mwLE/MsCxJwsQMyyADHXFiDmAQWIeWABYh5UgJgHFyDmIQWIua4AMQ8tQMzDChDztgWI+VcFiHm7AsS8fQFi3qEAMacKEPOOBYh5eAFi3qkAMe9cgJh3KUDMIwoQ864FiHm3AsS8uyOYNyB85j6yAOW8hyOYawgx/7oA5bxnAWLeqwAx712AmEcVIObRBYh5TAFi3qcAMe9bgJj3K0DM+xcg5gMKEPOBBYj5oALEfHABYj6kADEfWoCYDytAzGMLEPPhBYj5iALEXF+AmBsKEHNjAWIeV4CYmwoQ8/gCxDyhADEfWYCYJxYg5qMKEPPRBYh5UgFiPqYAMU8uQMxTChDzsQWI+bgCxDy1ADFPK0DM0wsQ84wCxDyzADHPKkDMswsQ8/EFiHlOAWI+oQAxn1iAmE9yBPPfi+gwn1yAcj6lADGfWoCY5xYg5tMKEPPpBYj5jALEfGYBvkd3liOYnyMck8wrQN0+uwAxzy9AzAsKEPM5BYj53ALEfJ4jmEsJMZ/vCOYyQswXOIK5nBDzhY5griDEfJEjmCsJMS90BHMnQsyLHMHcmRDzbxzBXEWI+WJHMHchxHyJI5i7EmK+1BHM1YSYL3MEczdCzJc7grk7IebFjmDuQYj5t45g7kmI+f8cwdyLEPMVrnxfkhDzla58X5IQ8xJXvi9JiHmpK9+XJMR8lSOYf0GI+WpX1jQlxPw7RzBvSIj5Gkcw9ybEvMwRzBsRYr6WEHNM9ZEI+toc4Y8FPID/1GNkoS4pSlSFeXqYt4Z5XJjXhHk+mPeCeSCYF4F5ArhvhvtIuK+C+wwYd8M4FMZlME6BuA1xDPw6+Dmwe7AD0AvgU42qfVTtq+rGqm6i6qaq9lN1M1X7IzpfCH5fUkS+rOorqv5D1VdVfU3Vf6r6L1VfV/UNVd9U9S1V31b1HVXfVfU9Vd9X9QNVP1T1I1U/VvUTVf+t6n9U/VTVz1T9XNUvVP1S1a9U/VrV/6r6jarfqvqdqt+r+oOqK1T9UdX/qfqTqitV/TlgZkzVuKoJVYtULVa1RNVSVctULVe1QtVKVTup2lnVKlW7qNpV1WpVu6naXdUeqvZUtZeq66i6rqrrqbq+qr9QdQNVN1S1t6obqVqjah9V+6q6sarw3Xj4jjp8Vxy+sw3fnYbvMMN3ieE7vfDdWviOK3zXFL7zCd+9hO9AwncR4TuB8N08+I4cfFcNvjMG392C71DBd5ngO0Xw3R74jg1812XVd05Uhe9gwHch4DsJ8N0AWEcf1pWHddZh3XFYhxvWpYZ1mmHdYljHF9a1hXVeYd1TWAcU1sWEdSJh3URYRxDW1YN15mDdNViHDNblgnWqYN0mWMcI1vWBdW5g3RdYBwXWBYF1MmDdCFhHAdYVgPfs4b1zeA8b3kuG93ThvVV4jxPea4T3/OC9N3gPDN6LgveE4L0ZeI8E3quA9wwg7x7y0CEvG/KUIW8X8lghrxPyHCHvD/LgIC8M8qQgbwjyaCCvBPIsIO8AnsPDc2l4TgvPLeE5HjzXguc88NwDngPAvDjME8O8KcwjwrwazDPBvAvMQ8B9Odynwn0b3MfAuB7GuTDug3EQjAsgTkLcAD8KfuXWWMa2NjL8wl4zJk2aOH5i09SacVOaptVMnjK95pj66Y1H1sysnzSjqWbi5JpZE6dPbpo2DRp/E5zUN/gdNXXKzImTJ9RMXt3JxMmNk2ZMmzhlcs34+omTmsZBq9Lg8r8IzmqsnzSpZvqUmvpp05qmTj/8mPrZhzdMnH74tIlzmuDv8mjNu0Zr3j1a83WjNV8/WvM+0ZpvEq35FtGabxOt+aBozYdEa759tOY7Rms+Ilrz3aI13zta8zHRmh8Yrfmh0ZpPjNb86GjNp0ZrPiNa8znRmp8Yrfnp0ZqfFa35udGaXxit+aXRml8erfnSaM1/F63576M1vyFa81ujNb8jWvN7ozV/IFrzp4Pmvwya7zVl8tZNsydOm14/eXrNsTMaJk1srBlXP72+ZlJT/XgdzyHET956TtPUKXDKX4MuNgm6GIXOmjZJjQXGTZm8mR4RoIHAMzme92yO5z0XnLdZ9nlpTMbAZfqRTfjUv+V+6vO5n3pMcP+1qT41GCkdi7sIGyxNTphCnY6u1Thl6tSmacdOmTwO9AKuOb1+6oQm+GPy9Kn1jdPhlClBF31Du2homjRFERKcPq1p8rimqdDqyaJ06w0NiifD2WGUvhacsEFwQv306U3HHDt9lcKOGwfMOLJmysymqeMnTZkF//8naN9O7f4sWvNvojX/Plrzn6I1/zlac7hHjNC8PFrzLtGad4/WfP1ozTeI1nzjaM37RWu+ZbTmW0drPjBa8yHRmm8XrfmO0ZrvFa35qGjND4jW/OBozQ+P1rw+WvMjozU/Olrz46I1nxGt+YnRmp8crfmZ0ZqfHa35edGaXxCt+SXRml8erfmSaM1/F635LUHzPIaBtwZdRB2W3ZbjebfneN4dwXk5DMiW537qnbmfOqY0fcqm+tT2DgMnlUbSgcVB8/aMxWBQqwd5Y4Lf9YLfHadOrT9eETSuaXbNlBnTa6aMr2mYMmPyuGn4pINzOak+l5OOzOWk70RuvPgxl4vFYjmctFEsNwqTOZ43MBcih0U56Yeg0aYih5O2yuWkAbmcNCyXk3bO5aTeEUWlz+ubC9f753LSiIgU/hy02zf47dP8vGkzGlbdhLZ88oH5nDw2+O0e/O4eDlA3j+Rx9EkTol3jqFyucaKIxvl4IKkd20ebbh5Jb/VJo3Okbb9otB2YC21HRqQtEZyXk8YmDEpzOrmdGqubR9JYfdKEaNc4KpdrRNXYHtE0tkcuGtsjR43tEU1je+SisT1y1Nie+Whsz3w0tmc0je2Zi8b2jKaxPXPR2J45auymxnmRmKdPPjWfk89qH1d08/lRuKJPuiDaNRbmco1rInI+Gc1XJHPxFckcfUUymq9I5uIrkjn6CpmPr5D5+AoZzVfIXHyFjOYrZC6+QuboK4ZH09jhuWjs8Bw1dng0jR2ei8YOz1Fjd8pHY3fKR2N3iqaxO+WisTtF09idctHYnXLU2H3yiW775BPd9okW3fbJJbrtEy267ZNLdNsnx+hWn4/O1+ej8/XRdL4+F52vj6bz9bnofH2OOj8umpcel4uXHpejlx4XzUuPy8VLj8vRSzflo7FN+WhsUzSNbcpFY5uiaWxTLhrblKPGzoymsTNz0diZOWrszGgaOzMXjZ2Zo8bOykdjZ+WjsbOiaeysXDR2VjSNnZWLxs7KUWPn5TOumJfPuGJetHHFvFzGFfOijSvm5TKumJfjuGJhNF+xMBdfsTBHX7Ewmq9YmIuvWJijr1iUj69YlI+vWBTNVyzKxVcsiuYrFuXiKxbl6Cuuiaax1+SisdfkqLHXRNPYa3LR2Gty1Nhl+Wjssnw0dlk0jV2Wi8Yui6axy3LR2GU5auzyfKLb8nyi2/Jo0W15LtFtebTotjyX6LY8x+h2epDBPDLKxfRJ/8vxYiKWw8VKopz0YpAW3FPkcNIGuZy0cS4nbRHlpDeCkzbN5aStcjlpQC4nDcvlpJ1zOSlq5oc+L1Lmhz6pfy4nRc38eC84L6cIpE8+MJ+T2xmBdPP6KHLTJ02Ido2jcrlG1Aj0YXDeju2j7cNc9FafFHXMpM9r55jpQ0MPItEWdcz0UT4a+1E+GvtRNI39KBeN/Siaxn6Ui8Z+lKPG/hBNY3/IRWN/yFFjf4imsT/korE/5KixK/LR2BX5aOyKaBq7IheNXRFNY1fkorErctTYiuLs8yIxT598aj4nt3OUr5tHGuXrky6Ido2FuVzjmoic7xmc105foZtH8hX6pKi+Qp/XTl+hm0fyFfqkqL6iV3BeTr6il0FpTie301fo5pF8hT5pQrRrHJXLNaL6is2iaexmuWjsZjlq7GbRNHazXDR2sxw1tn8+Gts/H43tH01j++eisf2jaWz/XDS2f44aW5dPdKvLJ7rVRYtudblEt7po0a0ul+hWl2N0G5GPzo/IR+dHRNP5Ebno/IhoOj8iF50fkaPO7x7NS++ei5fePUcvvXs0L717Ll569xy99Mh8NHZkPho7MprGjsxFY0dG09iRuWjsyBw19pBoGntILhp7SI4ae0g0jT0kF409JEeNPTQfjT00H409NJrGHpqLxh4aTWMPzUVjD81RYyflM66YlM+4YlK0ccWkXMYVk6KNKyblMq6YlOO4YlY0XzErF18xK0dfMSuar5iVi6+YlaOvmJ2Pr5idj6+YHc1XzM7FV8yO5itm5+IrZufoK+ZH09j5uWjs/Bw1dn40jZ2fi8bOz1FjF+SjsQvy0dgF0TR2QS4auyCaxi7IRWMX5Kixi/OJbovziW6Lo0W3xblEt8XRotviXKLb4hyim/h/8GDKs9TlCwA=", "debug_symbols": "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Hc+it/23NtXbi52c4jZ6239rn0Vv+29tLtdWMZQ8mDFt/619Fr3tv7XPorf9t/ZJ9Nn239pSrpbjUL+YpG7R2/5b+yx6239rn0Vv+m+tLLdfJ5c4yuMPX96W/vysfvmzLEFGywHtqkpZ6l8++0MV03/D36aK6d7gbaqY7jn+mColXDuxIiNVTPcyb1PFdI/0NlVM915/cF65qfLlp8xNlWK6p5uhShnUSjHdK76mSrtGkVp6okq4jJJrG3fp426fjj/buGK6CX2fLMa72+UuS34iS5LrP5zSXZYYh78Wb4uD9csQumqirslGE+Od7Vs0Md7XvkUT413tWzQx3tO+RRPjHe07NKnG+9m3aGK8m32LJsZb2bdo4n3sVhN1TTaaeB+71cT72K0m3sduNfE+dquJ97EbTZr3sVtNvI/dauJ97FYT72O3mqhrstHE+9itJt7HbjXxPnarifexW028j/27JmnxPnarifexW028j91q4n3sVhN1TTaaeB+71cT72K0m3sduNfE+dquJ97EbTYL3sVtNvI/dauJ97FYT72O3mqhrstHE+9itJt7HbjXxPnarifexW028j91oYvue3zdp4n3sVhPvY7eaeB+71URdk40m3sduNfE+dquJ97FbTbyP3WrifexGE9v3+L1JE+9jt5p4H7vVxPvYrSbqmmw08T52q4n3sVtNvI/dauJ97FYT72M3mti+V+hNmngfu9XE+9itJt7HbjVR12SjifexW028j91q4n3sVhPvY7eaeB+70cT2PTxv0sT72K0m3sduNTlOH1vC9aTcr2dwXzT58UX1LF/0OB1nvd0BVos8qfLH5yQn2/cmvU2V43Sde6pynL5zT1WO03nuqIrte6nepspxus89VTlO//m4BbF+5dab0q+uykAVb1dHqni7OlLF29WRKt6ujlTxdnWgivUrt3ZrQazfovWm9B+nA91TFW9XR6qoqzJQxdvVkSrero5U8XZ1pMpx2tUnLYh3oIP0H+iSrD1V8XZ1pIq3qyNVvF0dqaKuykAVb1dHqhynXX3cghzoFqw90+8LpiNVvF0dqHKgu7D2VMXb1ZEq3q6OVPF2daSKnqQFOdBFV3um3xdMR6p4uzpSxdvVkSrerm5VyQe68mpPVbxdHalyku2o+UB3We2ZfnVVBqp4uzpSxdvVkSrero5U8XZ1pIq3qwNVDnSz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" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "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", "debug_symbols": "7Z3djtU2FIXf5Vyjyj/b3javUvVi2lIJCQ0IppUqxLv3IE7CIIJSMh57rXjf8ZM9/rI82csrJ8f5eHnz9o+7h9dv7z9cXn68uF9Cvrz89ePlw7u7+8//8OHh7v3D5aWE/OLy6v7P65/Uf3px+ev1m1eXl0H0028vPhfpgaLotopyXoryZpE/UhSOFMUjRXKgKG8KIdUvRa5+U/Tiu2O9l3Q7+PrHvB7tpdyG8M8/RHjqEJLCcrCkHL8OEfzG0RrjcrTGmr7+bOdvQBENSNCAEhpQRgNSNKCCBlTBgNShAXk0ILROrWidWtE6taJ1akXr1IrWqRWtUytapy5onbqgdeqC1qkLWqcuaJ26oHXqgtapC1qnLmiduqB16tr5sk+u3g5Ovnz9yX7BESyczr/QKcYFJ8oGTsHCqVA43jkwHg/GE8B4IhhPg+bjHvHIXnMOsvTmkD59d/PYuwTGk/vy+NW7vDz+yet8KRhPAeOpWDzegfF4MJ4AxhM789RwOzh4t8UjYDwJjCeD8SgYTwHjqVg8oXN/DmH53DlI3OLxYDwBjCeC8QgYTwLjyWA8nftzyEv/iT5s8RQwnmftz1/GiK7DGL7DGKHDGLHDGNJhjNRhjNxhDO0wRukwRofrXDpc59LhOpcO17l0uM6lw3UuHa5z6XCdS4frXDpc59LhOk9Pv85zWcfQ4HbWMLsf8Pnk4YgCHFGEIxI4ogRHlOGIFI7o6X1Vpa5EWnaIii6fsVWXdo69mvCST518k78OnWmd5Uyf/q0SmjP105xpmOZM4zRnKtOcaZrmTPM0Z6rTnOk0a6Q8zRpJp1kj6TRrJJ1mjaTTrJEafB+P5UynWSPpNGsknWaNpJ3XSHXdWMM7n598G0wrNX5x3PieGz9w40dufOHGT9z4mRtfufG5Xbdwu27ldt3K7bqV23UbfLG6uLLgF917mFXKcnASeTq9UNMnavpMTa/U9IWavhLThwZf3x9J76npAzU9s9de785R0zN7bXDMXhscs9cGx+y1ocHmCtWvj3rWrDtEOS9Z5vHmHEfpG2zFMJLeU9MHavpITS/U9ImaPlPTKzV9oaan9tpA7bWB2msDtdcGaq9tsB3ISPoGXluXTxSSi3ufKPiwbkXqgzzai3TzgZ2gqrejg9aNL6KGBpuNjOWvyPwxyrp3SNS697OlLs9t+RR3H9zyK7cPce+3ftgjYaHB1iU2Q887Q95mCHyGgs0Q+AxFmyHwGRKbIfAZgl5L2wxdZwg6LdgMXWdIbYbAZ6jYDIHPkN1TAJ8hsXsK6DNk9xTQZ8juKaDPkN1TQJ8hsRkCnyG7p4A+Q3ZPAX2G7J4C+gzZPQX0GbJ7Cv9rhtp+vTYku1EwRHZL/0Nkt0g/RHbL6UNkF5N9hOyWqIfIbjF5iOyWfYfIboF2iOyWUkfIni2lDpHdUuoQ2S2lDpHdUuoQ2WVa2cN6B93H3dvtbbddyfOG1JGqz5tRR6o+b0Qdqfq8CXWk6vMG1IGq67z5dKTq88bTkarPm05Hqj5vOB2pupjqA1S3bDpCdcumI1S3bDpCdcumI1S3bDpA9XKmbJrWo32qcefothsZljOlzZE6nik/jtTxTIlwpI5iOjbR8UypbaSOZ8phI3U8U7IaqeOZstJIHc+UfgbqWC3PtNHR8kwbHS3PtNHR8kwbHcV0bKKj5Zk2OkKvH6/LsnUXixr27raybKZRodeap9Q8Ouh16Uk1h17DnlRz6PXuSTWHXhufVHMxzbtrjv2yuHNqjv2Cu3NqDv3ZxEk1txzaX3PLod0195ZD+2tuObS/5pZD+2tuObS/5mKad9fccmh/zS2H9tfccmh/zafNoW03jop+2nDZWMgwbWJsLeS0MbC1kNNmu9ZCThvYWgspJmQbIaeNVq2FnDYvtRZy2hDUWkhLNo2EtGTTRshoyaaRkJZsGglpyaaRkGdKNuO2h4lRTMcmOp4p14zU8UyxZqSOZ0o1I3U8U6gZqeOZMs1AHeVMkWakjmdKNCN1PFOgGamj5Zk2Oorp2ERHyzNtdLQ800ZHyzNtdLQ800TH1N2v1X89V93RsTp3O7iKW4+tcYEXZvjEDJ+Z4ZUZvjDDV2L4/m/vbgnvmeEDMzyzw/Z/q3FLeGaHzcwOm5kdNjM7bGZ2WGV2WGV2WGV2WGV22P7vZmwJz+ywyuywyuywyuywyuywhdlhC7PDFmaHLcwO2//NWC3hmR22MDtsYXbYwuywhdlhK7PDVmaHrcwOW5kdtv+7WlrCMztsZXbYyuywldlhK7HDiiN2WHHEDiuO2GHFETusOGKHFUfssOKIHVYcscOKI3ZYccwO65kd1jM7rGd2WM/ssP33p24Jz+ywntlhPbPDemaH9cwOG5gdNjA7bGB22MDssP33Hm0Jz+ywgdlhA7PDBmaHDcwOG5kdNjI7bGR22MjssP03wWsJz+ywkdlhI7PDRmaHjcwOK8wOK8wOK8wOK8wO239bppbwzA4rzA4rzA4rzA4rzA6bmB02MTtsYnZY5j2dhHlPJ2He00mY93QS5j2dhHlPJ2He00mY93QS5j2dhHlPJ2He00m67+kUdd068zrKDvzulpXSfVun1vyZnF/J+Qs5f+Xm777LU2t+T84fyPkjOT+5/yq5/yq5/yq5/yq5/yq5/xZy/y3k/lvI/beQ++/z7gd1GyM9+xhp+1t6GpZ3SWhI34xxq/KHqp7uOSksB1/vNMedOU/r2zaSf/SyDb+eewHjqVg8Db5f0pbHg/GEzjxxfWlLils8EYxHwHgSGE8G41Ewnt79OcaFJ8oWT8XiiQ6Mx4PxBDCeCMYjYDwJjCeD8SgYD1h/jmD9WcD6s4D1ZwHrzwLWnwWsPwtYfxaw/ixg/VnA+rOA9ecE1p8TWH9OYP05gfXnBNafE1h/TmD9OYH15wTWnxNYf85g/TmD9ecM1p8zWH/OYP05g/XnDNaff/BMYl4+VUwurFXLg8jpBw8C7hT5I0XhSFE8UiRHitKRos1fgVTWiapbRXqkqBwpqgeKth9N2SvyR4rCkaLN34hUdb3q8kaRHClKR4rykSI9UlSOFNUDRduv08lpLcpbRf5IUThSFI8UyZGidKQoHyna/I3IulwauWxcGtuvw9grqj9flLdf/7BX5I8UhSNF8eeKrn/55+7967vf37z6cC34/H9/3//x8Prt/e2vD/+++/I/n/4D" }, { "name": "constructor", "is_unconstrained": true, "custom_attributes": ["aztec(public)", "aztec(initializer)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "target_contract", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "reward_token", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 37 }], "reward_token": [{ "start": 38, "end": 39 }], "target_contract": [{ "start": 37, "end": 38 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240] }, "bytecode": "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", "debug_symbols": "7d3djl3Zkp7ne9nHgrHid8TQrRg+aNsyIEBoCVLbgCHo3r3aKrL2VrNFzsqKNz9u8MgtK3OOoZwdkczk87L+61/+w3/8P/7hn/79f/zH//KXf/tf//L6X/zYX/7t//pf//Jf/tM//OM////5L//0D//5n/7yb1//5i//7h//z/f/97/9m7/8X//+P/y7v/xbz/Pf/rd/8/9/hj/+jHj8Gfn4M+rxZ/TjzziPP2Mef8b98c/4N//i4+Z8+ciZ+vqxlvPb0+e1+nRbfbqvPj1Wn56rT6/Vp/fq08/q02f16auzeldn9a7O6l2d1fuh/33PnN8+MvN+/dj5soBvbz78Q/8bk+fLw8te/+Lh8XptPtw2H+6bD4/Nh+fmw2vz4b358LP58Nl8+OaE2uZKD7PVp/vq02P16bn69Fp9eq8+/aw+fVafvvnHr/DVWfXVWfXVWfXFPyGFn8WHx+afkGLzT0ix+Sek2PwTUmz+CSk2/4QUm39Cis0/IcXmn5Bi809IuTmhuTmhuTmhuTmhuTmhuTmhuTmhuTmhuTmhuTmh9WBCf/uMD43dcf/tI0/8/i2988vDffPhHxo7q/vbR9rYX38hH3zob/dIkXsUdo/48mKs/vlhXx78si9XaZ2rXOoq/eovH9uvb12lXzpXMZ2ruM5VQucqqXOV0rlK61zl6FxldK6is22PzrY9Otv26Gzbo7Ntj862PTrb9uhs26OzbY/Otj0623Z0tu3obNvR2bajs21HZ9uOzrYdnW07Ott2dLbt6Gzbq7Ntr862vTrb9ups26uzba/Otr062/bqbNurs22vzLbNl8y2zZfMts2XzLbNl8y2zZfMts2XzLbNl8y2zZfMts2XzLbNl862NZ1tazrb1nS2relsW9PZtqazbU1n25rOtjWdbWs629Z1tq3rbFvX2baus21dZ9u6zrZ1nW3rOtvWdbat62zb0Nm2obNtQ2fbhs62DZ1tGzrbNnS2behs29DZtqGzbVNn26bOtk2dbZs62zZ1tm3qbNvU2baps21TZ9umzrYtnW1bOtu2dLZt6Wzb0tm2pbNtS2fbls62LZ1tq9OSpU5LljotWeq0ZKnTkqVOS5Y6LVnqtGSp05KlTkuWOi1Z6rRkqdOSpU5LljotWeq0ZKnTkqVOS5Y6LVnqtGSp05KlTkuWOi1Z6rRkqdOSpU5LljotWeq0ZKnTkqVOS5Y6LVnqtGSp05KlTkuWOi1Z6rRkqdOSpU5LljotWeq0ZKnTkpVOS1Yvbpgrvl7l5LeuUjpXof7X1n2+/FOO7//xfusqV+YqWJTzA1cxnau4zlWoPyR4+JcJ8pj4m6s8++jfLp4/68VL8uInwn776BO3vnXx/lkvfn7Wi8/PevH7k16cC3iOfXnq+3+0b10ldK6SOlcpnau0zlWwH99Ofv3Yc745QaNzlStzFS7g+f5VTOcqrnOV0LlK6lyldK7Cbdv79Z+GH/dvXQXbK9Nff+sw/a3fOnCpyvevYjpXcZ2rhM5VUucqpXOV1rnK0bnK6FxFZ9uWzrYtnW1bOtu2dLZt6Wzb0tm2pbNtS2fbls62LZ1t2zrbtnW2bets29bZtq2zbVtn27bOtm2dbds627Z1tu3R2bZHZ9senW17dLbt0dm2R2fbHp1te3S27dHZtkdn247Oth2dbTs623Z0tu3obNvR2bajs21HZ9uOzrYdnW17dbbt1dm2V2fbXp1te3W27dXZtldn216dbXt1tu2V2bb9ktm2/ZLZtv2S2bb9ktm2/ZLZtv2S2bb9ktm2/ZLZtv2S2bb90tm2prNtTWfbms62NZ1tazrb1nS2relsW9PZtqazbU1n27rOtnWdbes629Z1tq3rbFvX2baus21dZ9u6zrZ1nW0bOts2dLZt6Gzb0Nm2obNtQ2fbhs62DZ1tGzrbVqcla52WrHVastZpyVqnJWudlqx1WrLWaclapyVrnZasdVqy1mnJWqcla52WrHVastZpyVqnJWudlqx1WrLWaclapyVrnZasdVqy1mnJWqcla52WrHVastZpyVqnJWudlqx1WrLWaclapyVrnZasdVqy1mnJWqcla52WrHVastZpyVqnJWudlqy5VOna14+9ad+6SulcBftnfF/3/Pax7/9xvnWVK3MVLMr5gauYzlVc5yrYPw1v8+Vj3bP/5ir/8qO/+484N5bw/OkXr5/14v2zXvz8rBefn/Xi9+e8+MGypv/ZxX+7iutcReGbxG9XUVj7v11FYZH/dhWF1fzbVRSW7W9XkfmvNR2d/1rT0fmvNR2d/1rT0fmvNR3uv9b0/aukzlVK5yqtc5WjcxWdbWs629Z1tq3rbFvX2baus21dZ9u6zrZ1nW3rOtvWdbat62zb0Nm2obNtQ2fbhs62DZ1tGzrbNnS2behs29DZtqGzbVNn26bOtk2dbZs62zZ1tm3qbNvU2bZcNXPny1/C+Ot1vnEVrpr5/lVM5yquc5XQuUrqXKV0rtI6Vzk6V5nPuMq3/lvOp67MVfqlcxXTuQpHtKK/XqW+9Z0Z60N+4Cqtc5Wjc5XRucqVucrhKM3ry3/L2c3mW1cxnau4zlVC5yqpc5XSuUrrXOXoXGV0rnJlrjIy0P6MDLQ/IwPtD/bfGvqBq6TOVUrnKq1zlaNzFZms6ehkTUcnazo6WdPRyZrO1dm2V2fbXp1te3W27dXZtldn216ZbTsvmW07L5ltOy+ZbTsvmW07L5ltOy+ZbTsvmW07L5ltOy+ZbTsvnW1rOtvWdLat6Wxb09m2prPiTGfFmc6KM50VZzorjqsbwr/8YzoeE9+6SutcZed/bX97+Gw+/EP/q/XdfxVgPpYV/MDzbfn5vvz8WH5+Lj+/lp/fy88/y8+f5ecvz28uz+/H9Hm+fzz77UPf/+P5+tHny3r7mCj//uNj9/G5+/jafXzvPv7B5P72GfP4M+7Tz3gCsH/7DHv8Gf74M+LxZ+Tjz6jHn9GPP+PxO6/H77wev/N+/M778Tvvx++8H7/zfvzO+/E778fvvB+/8378zvvxOz+P3/l5/M7P43d+Hr/z8/idn8fv/Dx+5+fxOz+P3/l5/M7n8Tufx+98Hr/zefzO5/E7n8fvfB6/83n8zufxO5/H7/w+fuf38Tu/j9/5ffzO7+N3fh+/8/v4nd/H7/w+fuf36Tu/r9fjz7DHn+GPPyMef0Y+/ox6/Bn9+DPO48+Yx5/x+J3b43duj9+5PX7n9vid2+N3bo/fuT1+5/b4ndvjd26P37k/fuf++J3743fuj9+5P37n/vid++N37o/fuT9+5/74ncfjdx6P33k8fufx+J3H43cej995PH7n8fidx+N3Ho/feT5+5/n4nefjd56P33k+fuf5+J3n43f++Pdw9/Hv4e7j38Pdx7+Hu49/D3cf/x7uPv493H38e7j7+Pdw9/Hv4e7j38Pdx7+Hu49/D3cf/x7uPv493H38e7j7+Pdw9/Hv4e7j38Pdx7+Hu49/D3cf/x7uPv493H38e7j7+Pdw9/Hv4e7j38Pdx7+Hu49/D3cf/x7uPv493H38e7j7+Pdw9/Hv4e7j38Pdx7+Hu49/D3cf/x7uPv493H38e7j7+Pdw9/Hv4e7j38Pdx7+Hu49/D3cf/x7uPv493H38e7j7+Pdw9/Hv4e7j38Pdx7+Hu49/D2evx7+Ie3+KPf8Uf/4p8fxT8vmn1PNP6eefcp5/yjz/lOdv356/fXv+9u3527fnb9+ev317/vbt+du352/fnr99e/72/fnb9+dv35+/fX/+9v352/fnb9+fv31//vb9+dv3528/nr/9eP724/nbj+dvP56//Xj+9uP524/nbz+ev/14/vbz+dvP528/n7/9fP728/nbz+dvP5+//Xz+9vP528/nb7+ev/16/vbr+duv52+/nr/9ev726/nbr+dvv56//Xr+9vv52+/nb7+fv/1+/vb7+dvv52+/n7/9fv72+/nb7+dv/zx/++f52z/P3/55/vbP87d/nr/98/ztn+dv/zx/++f525/nb3+ev/15/vbn+duf529/nr/9ef725/nbn+dvf56//fv87d/nb/8+f/sf+xdxTn355+PPzd8/9vX16bn69Fp9eq8+/aw+fVaffhefbh/7Z12++3RbfbqvPj1Wn56rT6/Vp/fq08/q02f16auzaquzaquzaquzaquzaquzaquzaquz+rF/ZKPjyz+G0PX709//a/6tfznhfPnnJOL1+3Ojvt5kZG5yVW7ysf/s7Z96E5O5icvcJGRukjI3KZmbtMxNZHasy+xYl9mxIbNjQ2bHhsyODZkdGzI7NmR2bMjs2JDZsSGzY0Nmx6bMjk2ZHZsyOzZldmzK7NiU2bEps2NTZsemzI5NmR1bMju2ZHZsyezYktmxJbNjS2bHlsyOLZkdWzI7tmR2bMvs2JbZsS2zY1tmx7bMju2lHfvl8b37+LP7+Nl9/F19/HntPt52H++7j4/dx+fu43en9uxO7dmd2rM7tWd3amd3amd3amd3amd3amd3amd3amd3amd3amd3aj/2XzXtri+PP/eDf+L62H/U9E+9icncxGVuEjI3SZmblMxNWuYmR+YmI3MTlR3rL5Ud6y+VHesvlR3rL5Ud6y+VHesvlR3rL5Ud6y+VHesvlR3rL5kdazI71mR2rMnsWJPZsSazY01mx5rMjjWZHWsyO9ZkdqzL7FiX2bEus2NdZse6zI51mR3rMjvWZXasy+xYl9mxIbNjQ2bHhsyODZkdGzI7NmR2bMjs2JDZsSGzY0Nmx6bMjk2ZHZsyOzZldmzK7NiU2bEps2NTZsemzI5NmR1bMju2ZHZsyezYktmxJbNjS2bHlsyOLZkdWzI7tmR2bMvs2JbZsS2zY1tmx7bMjm2ZHdsyO7ZldmzL7NiW2bFHZscemR17ZHbskdmxR2bHHpkde2R27JHZsUdmxx6ZHTsyO3ZkduzI7NiR2bEjs2NHZseOzI4dmR07MjtWpvNymc7LZTovl+m8XKbzcpnOy2U6L5fpvFym83KZzstlOq+Q6bxCpvMKmc4rZDqveKns2JDpvEKm8wqZzitkOq+Q6bxCpvMKmc4rZDqvkOm8QqbzCpnOK2Q6r5DpvEKm8wqZzitkOq+Q6bxCpvMKmc4rZDqvkOm8QqbzCpnOK2Q6r5DpvEKm8wqZzitkOq+Q6bxCpvMKmc4rZDqvkOm8QqbzCpnOK2Q6r5DpvEKm8wqZzitkOq+Q6bxCpvMKmc4rZDqvkOm8QqbzCpnOK2Q6r5DpvEKm8wqZzitkOq+Q6bxCpvMKmc4rZDqvkOm8QqbzCpnOK2Q6r5DpvEKm8wqZzitkOq+Q6bxCpvMKmc4rZDqvkOm8QqbzCpnOK2Q6r5DpvEKm8wqZzitkOq+Q6bxCpvMKmc4rZDqvkOm8QqbzCpnOK2Q6r5DpvEKm8wqZzitkOq+Q6bxCpvMKmc4rZDqvkOm8QqbzCpnOK2U6r5TpvFKm80qZzitfKjs2ZTqvlOm8UqbzSpnOK2U6r5TpvFKm80qZzitlOq+U6bxSpvNKmc4rZTqvlOm8UqbzSpnOK2U6r5TpvFKm80qZzitlOq+U6bxSpvNKmc4rZTqvlOm8UqbzSpnOK2U6r5TpvFKm80qZzitlOq+U6bxSpvNKmc4rZTqvlOm8UqbzSpnOK2U6r5TpvFKm80qZzitlOq+U6bxSpvNKmc4rZTqvlOm8UqbzSpnOK2U6r5TpvFKm80qZzitlOq+U6bxSpvNKmc4rZTqvlOm8UqbzSpnOK2U6r5TpvFKm80qZzitlOq+U6bxSpvNKmc4rZTqvlOm8UqbzSpnOK2U6r5TpvFKm80qZzitlOq/8YOd1/bePPK/+m5t8efzZffzsPv6uPv6D7dR3H2+7j/fdx8fu43P38bX7+N2pvbtTe3en9q5Obb1eu4+33cf77uNj9/G5+/jafXzvPv7sPn52H787tR/rO77zp6j6WLPx3af76tNj9em5+vRafXqvPv2sPn1Wn343n+6rs+qrs+qrs+qrs+qrs+qrs+qrs+qrs+qrs+qrsxqrsxqrsxqrsxqrs/oxv/2xj/tyhfr8K/TnX+F8/hXm869wP/0KH1PZf84V7POv4J9/hfj8K3z+dszP3475+dsxP3875udvx/z87Vifvx3r87djff52rM/fjvX527E+fzvW52/H+vztWMh2PP7117Px+99Yd369xVW4Rb8kbmESt3CJW4TELVLiFiVxi5a4xZG4hcTubIndeSR255HYnUdidx6J3XkkdueR2J1HYnceid15JHbnkdidI7E7R2J3zsLu/PLo2Ht07j269h7de48+e4+evUfftUff196jbe/Re9N496bx7k3j3ZvGuzeNd28a79403rVp7Ndr79G292jfe3TsPTr3Hl17j/703w7369N/O9yvT/+7s359+t+dtX363521ffrfnbV9+t+dtX3635215edf4dP/7qzt87ejff52tM/fjvb529E/fzv6529H//zt6J+/Hf3zt6N//nb0z9+O/vnb0T9/O/rnb8dQ+N1uh8LvdjsU/l6sQ+HvxZrx+9+9hcLfi3Uo/L1Yh8Lfi3Uo/L1Yh8Lfi3VK7M6U2J0psTtTYnemxO5Mid2ZErszJXZnSuzOlNidJbE7S2J3lsTuLInduWH/vzx6729jqvceffYePXuP3vu70d77u9He+7vR3vu70d77u9Hem8bem8bem8bem8bem8bem8azN41nbxrP3jSevWk8e9N49qbx7E3j2ZvGszeNZ28aZ28aZ28a90xt75na3jO1vWdqe8/U9p6p7T1T23umtvdMbe+Z2t4ztb1nanvP1Paeqe09U9t7prb3TG3vmdqzZ2rPnqk9T0ztl0+J55+Szz+lnn9KP/+U8/xT5vmn3Mef8sRcfvkUe/4pz9++PX/79vzt2/O3b8/fvj1/+/b87dvzt+/P374/f/v+/O3787fvz9++P3/7/vzt+/O378/fvj9/+/H87cfztx/P3348f/vx/O3H87cfz99+PH/78fztx/O3n8/ffj5/+/n87efzt5/P334+f/v5/O3n87efz99+Pn/7H/t7S+/f/9XU/Pqx9vr98bb7eN99fOw+PncfX7uP793Hn93Hz+7j7+rje3dqe3dqP/Z3h5aZv33oP/9nYX8/wPJbH+3Hvnz031zH8ut1Qus6qXWd0rpOa13naF1ntK5zpa7zsb/b/fOvY1rX0drKR2srH62tfLS28tHaykdrKx+trXy0tvJobeXR2sqjtZVHayuP1lYera08H9zKM18OKJvvXKfiy23qvP7qh774epmjdJlRuswVusx9KV3GlC7jSpcJpcuk0mVK6TJKG/gqbeCrtIGv0Aael9AGnpfQBp6X0Aael9AGnpfQBp6X0Aael9AGnpfQBp6X0Aael9IGNqUNbEob2JQ2sCltYFPawKa0gU1pA5vSBjalDWxKG9iVNrArbWBX2sCutIFdaQO70gZ2pQ3sShvYlTawK23gUNrAobSBQ2kDh9IGDqUNHEobOJQ2cCht4FDawKG0gVNpA6fSBk6lDZxKGziVNnAqbeBU2sCptIFTaQOn0gYupQ1cShu4lDZwKW3gUtrApbSBS2kDl9IGLqUNXEobuJU2cCtt4FbawK20gVtpA7fSBm6lDdxKG7iVNnArbeCjtIGP0gY+Shv4KG3go7SBj9IGPkob+Cht4KO0gY/SBh6lDTxKG3iUNvAobeBR2sCjtIGVmrhRauJGqYkbpSZulJq4UWriRqmJG6UmbpSauFFq4kapiRulJm6UmrhRauKuUhN3lZq4q9TEXaUm7r6ENvBVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVepibtKTdxVauKuUhN3lZq4q9TEXaUm7io1cVeoifOXUBP3vozOBn5fRmcDvy+js4Hfl9HZwO/L6Gzg92V0NvD7Mjob+H0ZnQ38vozSBhZq4t6XUdrAQk3c+zJKG1ioiXtfRmkDCzVx78sobWChJu59GaUNLNTEvS+jtIGFmrj3ZZQ2sFAT976M0gYWauLel1HawEJN3PsyShtYqIl7X0ZpAws1ce/LKG1goSbufRmlDSzUxL0vo7SBhZq492WUNrBQE/e+jNIGFmri3pdR2sBCTdz7MkobWKiJe19GaQMLNXHvyyhtYKEm7n0ZpQ0s1MS9L6O0gYWauPdllDawUBP3vozSBhZq4t6XUdrAQk3c+zJKG1ioiXtfRmkDCzVx78sobWChJu59GaUNLNTEvS+jtIGFmrj3ZZQ2sFAT976M0gYWauLel1HawEJN3PsyShtYqIl7X0ZpAws1ce/LKG1goSbufRmlDSzUxL0vo7SBhZq492WUNrBQE/e+jNIGFmri3pdR2sBCTdz7MkobWKiJe19GaQMLNXHvyyhtYKEm7n0ZoQ1sSk2cKTVxptTEmVITZy+hDWxKTZwpNXGm1MSZUhNnSk2cKTVxptTEmVITZ0pNnCk1cabUxJlSE2dKTZwpNXGm1MSZUhNnSk2cKTVxptTEmVITZ0pNnCk1cabUxJlSE2dKTZwpNXGm1MSZUhNnSk2cKTVxptTEmVITZ0pNnCk1cabUxJlSE2dKTZwpNXGm1MSZUhNnSk2cKTVxptTEmVITZ0pNnCk1cabUxJlSE2dKTZwpNXGm1MSZUhNnSk2cKTVxptTEmVITZ0pNnCk1cabUxJlSE2dKTZwpNXGm1MSZUhNnSk2cKTVxptTEmVITZ0pNnCk1cabUxJlSE2dKTZwpNXGm1MSZUhNnSk2cKTVxptTEmVITZ0pNnCk1cabUxJlSE2dKTZwpNXGm1MSZUhNnSk2cKTVxptTEmVITZ0pNnCk1cabUxLlSE+dKTZwrNXGu1MT5S2gDu1IT50pNnCs1ca7UxLlSE+dKTZwrNXGu1MS5UhPnSk2cKzVxrtTEuVIT50pNnCs1ca7UxLlSE+dKTZwrNXGu1MS5UhPnSk2cKzVxrtTEuVIT50pNnCs1ca7UxLlSE+dKTZwrNXGu1MS5UhPnSk2cKzVxrtTEuVIT50pNnCs1ca7UxLlSE+dKTZwrNXGu1MS5UhPnSk2cKzVxrtTEuVIT50pNnCs1ca7UxLlSE+dKTZwrNXGu1MS5UhPnSk2cKzVxrtTEuVIT50pNnCs1ca7UxLlSE+dKTZwrNXGu1MS5UhPnSk2cKzVxrtTEuVIT50pNnCs1ca7UxLlSE+dKTZwrNXGu1MS5UhPnSk2cKzVxrtTEuVIT50pNnCs1ca7UxLlSE+dKTZwrNXGu1MS5UhPnSk2cKzVxodTEhVITF0pNXCg1cfES2sCh1MSFUhMXSk1cKDVxodTEhVITF0pNXCg1caHUxIVSExdKTVwoNXGh1MSFUhMXSk1cKDVxodTEhVITF0pNXCg1caHUxIVSExdKTVwoNXGh1MSFUhMXSk1cKDVxodTEhVITF0pNXCg1caHUxIVSExdKTVwoNXGh1MSFUhMXSk1cKDVxodTEhVITF0pNXCg1caHUxIVSExdKTVwoNXGh1MSFUhMXSk1cKDVxodTEhVITF0pNXCg1caHUxIVSExdKTVwoNXGh1MSFUhMXSk1cKDVxodTEhVITF0pNXCg1caHUxIVSExdKTVwoNXGh1MSFUhMXSk1cKDVxodTEhVITF0pNXCg1caHUxIVSExdKTVwoNXGh1MSFUhMXSk1cKDVxodTEhVITF0pNXCg1caHUxIVSExdKTVwqNXGp1MSlUhOXSk1cvoQ2cCo1canUxKVSE5dKTVwqNXGp1MSlUhOXSk1cKjVxqdTEpVITl0pNXCo1canUxKVSE5dKTVwqNXGp1MSlUhOXSk1cKjVxqdTEpVITl0pNXCo1canUxKVSE5dKTVwqNXGp1MSlUhOXSk1cKjVxqdTEpVITl0pNXCo1canUxKVSE5dKTVwqNXGp1MSlUhOXSk1cKjVxqdTEpVITl0pNXCo1canUxKVSE5dKTVwqNXGp1MSlUhOXSk1cKjVxqdTEpVITl0pNXCo1canUxKVSE5dKTVwqNXGp1MSlUhOXSk1cKjVxqdTEpVITl0pNXCo1canUxKVSE5dKTVwqNXGp1MSlUhOXSk1cKjVxqdTEpVITl0pNXCo1canUxKVSE5dKTVwqNXGp1MSlUhOXSk1cKjVxqdTEpVITV0pNXCk1caXUxJVSE1cvoQ1cSk1cKTVxpdTElVITV0pNXCk1caXUxJVSE1dKTVwpNXGl1MSVUhNXSk1cKTVxpdTElVITV0pNXCk1caXUxJVSE1dKTVwpNXGl1MSVUhNXSk1cKTVxpdTElVITV0pNXCk1caXUxJVSE1dKTVwpNXGl1MSVUhNXSk1cKTVxpdTElVITV0pNXCk1caXUxJVSE1dKTVwpNXGl1MSVUhNXSk1cKTVxpdTElVITV0pNXCk1caXUxJVSE1dKTVwpNXGl1MSVUhNXSk1cKTVxpdTElVITV0pNXCk1caXUxJVSE1dK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a7tTa7tTa7tTa7tTa7tTa7tTa7tTa7tTa7tT67tT67tT67tT67tT67tT67tT67tT67tT67tT67tTG7tTG7tTG7tTG7tTG7tTG7tTG7tTG7tTG7tTG7tTm7tTm7tTm7tTm7tTm7tTm7tTm7tTm7tTm7tTm7tTW7tTW7tTW7tTW7tTW7tTW7tTW7tTW7tTW7tTW7tT27tT27tT27tT27tT27tT27tT27tT27tT27tT27tTe3an9uxO7dmd2rM7tWd3as/u1J7dqT27U3t2p/bsTu3sTu2ujbJdG2W7Nsp2bZTt2ijbtVG2a6Ns10bZro2yXRtluzbKdm2U7doo27VRtmujbNdG2a6Nsl0bZbs2yndtlO/aKN+1Ub5ro/yVu4+v3cf37uPP7uNn9/G7U7tro3zXRvmujfJdG+W7Nsp3bZTv2ijftVG+a6N810b5ro3yXRvluzbKd22U79oo37VRvmujfNdG+a6N8l0b5bs2yndtlO/aKN+1Ub5ro3zXRvmujfJdG+W7Nsp3bZTv2ijftVG+a6N810b5ro3yXRvluzbKd22U79oo37VRvmujfNdG+a6N8l0b5bs2yndtlO/aKN+1Ub5ro3zXRvmujfJdG+W7Nsp3bZTv2ijftVG+a6N810b5ro3yXRvluzbKd22U79oo37VRvmujfNdG+a6N8l0b5bs2yndtlO/aKN+1Ub5ro3zXRvmujfJdG+W7Nsp3bZTv2ijftVG+a6N810b5ro3yXRvluzbKd22U79oo37VRvmujfNdGxa6Nil0bFbs2KnZtVLxy9/G1+/jeffzZffzsPn53andtVOzaqNi1UbFro2LXRsWujYpdGxW7Nip2bVTs2qjYtVGxa6Ni10bFro2KXRsVuzYqdm1U7Nqo2LVRsWujYtdGxa6Nil0bFbs2KnZtVOzaqNi1UbFro2LXRsWujYpdGxW7Nip2bVTs2qjYtVGxa6Ni10bFro2KXRsVuzYqdm1U7Nqo2LVRsWujYtdGxa6Nil0bFbs2KnZtVOzaqNi1UbFro2LXRsWujYpdGxW7Nip2bVTs2qjYtVGxa6Ni10bFro2KXRsVuzYqdm1U7Nqo2LVRsWujYtdGxa6Nil0bFbs2KnZtVOzaqNi1UbFro2LXRsWujYpdGxW7Nip2bVTs2qjYtVGxa6Ni10bFro2KXRsVuzYqdm1U7Nqo3LVRuWujctdG5a6NylfuPr52H9+7jz+7j5/dx+9O7a6Nyl0blbs2KndtVO7aqNy1Ublro3LXRuWujcpdG5W7Nip3bVTu2qjctVG5a6Ny10blro3KXRuVuzYqd21U7tqo3LVRuWujctdG5a6Nyl0blbs2KndtVO7aqNy1Ublro3LXRuWujcpdG5W7Nip3bVTu2qjctVG5a6Ny10blro3KXRuVuzYqd21U7tqo3LVRuWujctdG5a6Nyl0blbs2KndtVO7aqNy1Ublro3LXRuWujcpdG5W7Nip3bVTu2qjctVG5a6Ny10blro3KXRuVuzYqd21U7tqo3LVRuWujctdG5a6Nyl0blbs2KndtVO7aqNy1Ublro3LXRuWujcpdG5W7Nip3bVTu2qjctVG5a6Ny10blro3KXRtVuzaqdm1U7dqo2rVR9crdx9fu43v38Wf38bP7+N2p3bVRtWujatdG1a6Nql0bVbs2qnZtVO3aqNq1UbVro2rXRtWujapdG1W7Nqp2bVTt2qjatVG1a6Nq10bVro2qXRtVuzaqdm1U7dqo2rVRtWujatdG1a6Nql0bVbs2qnZtVO3aqNq1UbVro2rXRtWujapdG1W7Nqp2bVTt2qjatVG1a6Nq10bVro2qXRtVuzaqdm1U7dqo2rVRtWujatdG1a6Nql0bVbs2qnZtVO3aqNq1UbVro2rXRtWujapdG1W7Nqp2bVTt2qjatVG1a6Nq10bVro2qXRtVuzaqdm1U7dqo2rVRtWujatdG1a6Nql0bVbs2qnZtVO3aqNq1UbVro2rXRtWujapdG1W7Nqp2bVTt2qjatVG1a6N610b1ro3qXRvVuzaqX7n7+Np9fO8+/uw+fnYfvzu1uzaqd21U79qo3rVRvWujetdG9a6N6l0b1bs2qndtVO/aqN61Ub1ro3rXRvWujepdG9W7Nqp3bVTv2qjetVG9a6N610b1ro3qXRvVuzaqd21U79qo3rVRvWujetdG9a6N6l0b1bs2qndtVO/aqN61Ub1ro3rXRvWujepdG9W7Nqp3bVTv2qjetVG9a6N610b1ro3qXRvVuzaqd21U79qo3rVRvWujetdG9a6N6l0b1bs2qndtVO/aqN61Ub1ro3rXRvWujepdG9W7Nqp3bVTv2qjetVG9a6N610b1ro3qXRvVuzaqd21U79qo3rVRvWujetdG9a6N6l0b1bs2qndtVO/aqN61Ub1ro3rXRvWujepdG9W7Nqp3bdTZtVFn10adXRt1dm3UeeXu42v38b37+LP7+Nl9/O7U7tqos2ujzq6NOrs26uzaqLNro86ujTq7Nurs2qiza6POro06uzbq7Nqos2ujzq6NOrs26uzaqLNro86ujTq7Nurs2qiza6POro06uzbq7Nqos2ujzq6NOrs26uzaqLNro86ujTq7Nurs2qiza6POro06uzbq7Nqos2ujzq6NOrs26uzaqLNro86ujTq7Nurs2qiza6POro06uzbq7Nqos2ujzq6NOrs26uzaqLNro86ujTq7Nurs2qiza6POro06uzbq7Nqos2ujzq6NOrs26uzaqLNro86ujTq7Nurs2qiza6POro06uzbq7Nqos2ujzq6NOrs26uzaqLNro86ujTq7Nurs2qiza6POro06uzbq7Nqos2ujzq6NOrs26uzaqLNro2bXRs2ujZpdGzW7Nmpeufv42n187z7+7D5+dh+/O7W7Nmp2bdTs2qjZtVGza6Nm10bNro2aXRs1uzZqdm3U7Nqo2bVRs2ujZtdGza6Nml0bNbs2anZt1OzaqNm1UbNro2bXRs2ujZpdGzW7Nmp2bdTs2qjZtVGza6Nm10bNro2aXRs1uzZqdm3U7Nqo2bVRs2ujZtdGza6Nml0bNbs2anZt1OzaqNm1UbNro2bXRs2ujZpdGzW7Nmp2bdTs2qjZtVGza6Nm10bNro2aXRs1uzZqdm3U7Nqo2bVRs2ujZtdGza6Nml0bNbs2anZt1OzaqNm1UbNro2bXRs2ujZpdGzW7Nmp2bdTs2qjZtVGza6Nm10bNro2aXRs1uzZqdm3U7Nqo2bVRs2ujZtdGza6Nml0bNbs2aj5mo779cf/90fdjLup//mjbe7TvPTr2Hp17j669R/feo8/eo2fv0XvTaHvT+EHrdI7/9qHv/zG+fvT5/fm+/PxYfn4uP7+Wn9/Lzz/Lz5/l59/d538QPX3/+cvz68vz68vz68vz68vz68vz68vz68vz+0Q//fYpT0TTl0+x55/izz8lnn9KPvwUe30wV8+c3z4y83792Pmrx+fu42v38b37+LP7+Nl9/F19/Mf+Sub7j7fdx/vu4z/2jfL15SPr9e3H5+7ja/fxvfv4s/v42X38XX38B/9K5ruPt93H++7jd6d2dqd2dqd2dqd2dqf2Y38lk+fLvi97ffPxd/XxH/srme8/3nYf77uPj93H5+7ja/fxvfv4s/v43am9q1P7wVz9+4+33cf77uNj9/G5+/jafXzvPv7sPn52H787tbY7tbY7tbY7tbY7tbY7tbY7tbY7tbY7tbY7tbY7tb47tb47tb47tb47tb47tb47tb47tb47tbH6W9gPBt/ff7zvPj52H5+7j6/dx/fu48/u42f38at/d/LR4Ps7v+z6aPD93cf77uNj9/G5+/jafXzvPv7sPn52H7/6dycfDb6/+/jdqa3dqa3dqa3dqa3dP2PW7p8xa/fPmLX7k2Ht/mTYuz8Z9u5Phr37k2Hv/mT4QV303cfvTm3vTm3vTm3vTm3vTu3ZndqzO7Vnd2rP7tSe3ak9u1N7dqf27E7t2Z3aszu1szu1szu1szu1szu1szu1szu1szu1szu1u7podnXR7Oqi2dVFs6uLZlcXza4u+leS6ejz5feTr/z6afaK3z9v/uDn3T/0ef9KwfwDn2d/8PO++XXxr58Xf/N55/fPmz/4efePfd63McIPfJ79wc/zP/h53/y6tPdvn9c93/68+8c+79t/3fsDn2d/8PP8D35e/MHPyz/4efUHP6//4Od9873btS//GILd+v0Xbp2/f+L9g58Yf/DNxx988/EH33z8wTcff/DNxx988/H0zb//T//PP/znf/8P//t/+Hf/5f0Z//x/+X//4//xT//+P/7jb//Hf/p//9N//7/5b/8f" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "19": { "source": "// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n/// A hint for decomposing a single field into two 16 byte fields.\nunconstrained fn decompose_unsafe(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    // Take hints of the decomposition\n    let (xlo, xhi) = decompose_unsafe(x);\n    let borrow = lt_unsafe(PLO, xlo, 16);\n\n    // Range check the limbs\n    xlo.assert_max_bit_size(128);\n    xhi.assert_max_bit_size(128);\n\n    // Check that the decomposition is correct\n    assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n    // Check that (xlo < plo && xhi <= phi) || (xlo >= plo && xhi < phi)\n    let rlo = PLO - xlo + (borrow as Field) * TWO_POW_128;\n    let rhi = PHI - xhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n\n    (xlo, xhi)\n}\n\nunconstrained fn lt_unsafe(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.__to_le_radix(256, num_bytes);\n    let y_bytes = y.__to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nunconstrained fn lte_unsafe(x: Field, y: Field, num_bytes: u32) -> bool {\n    lt_unsafe(x, y, num_bytes) | (x == y)\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    // Decompose a and b\n    let (alo, ahi) = decompose(a);\n    let (blo, bhi) = decompose(b);\n\n    let borrow = lte_unsafe(alo, blo, 16);\n\n    // Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if a == b {\n        false\n    } else if lt_unsafe(a, b, 32) {\n        assert_gt(b, a);\n        false\n    } else {\n        assert_gt(a, b);\n        true\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_unsafe, decompose, lt_unsafe, assert_gt, gt, lt, TWO_POW_128, lte_unsafe, PLO, PHI};\n\n    #[test]\n    fn check_decompose_unsafe() {\n        assert_eq(decompose_unsafe(TWO_POW_128), (0, 1));\n        assert_eq(decompose_unsafe(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose_unsafe(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_lt_unsafe() {\n        assert(lt_unsafe(0, 1, 16));\n        assert(lt_unsafe(0, 0x100, 16));\n        assert(lt_unsafe(0x100, TWO_POW_128 - 1, 16));\n        assert(!lt_unsafe(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_lte_unsafe() {\n        assert(lte_unsafe(0, 1, 16));\n        assert(lte_unsafe(0, 0x100, 16));\n        assert(lte_unsafe(0x100, TWO_POW_128 - 1, 16));\n        assert(!lte_unsafe(0, TWO_POW_128, 16));\n\n        assert(lte_unsafe(0, 0, 16));\n        assert(lte_unsafe(0x100, 0x100, 16));\n        assert(lte_unsafe(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(lte_unsafe(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n", "path": "std/field/bn254.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "30": { "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self]);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self.lo as Field, self.hi as Field]);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n", "path": "std/hash.nr" }, "33": { "source": "// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n", "path": "std/merkle.nr" }, "35": { "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n", "path": "std/option.nr" }, "64": { "source": "use crate::{\n    context::Context, history::public_value_inclusion::prove_public_value_inclusion,\n    oracle::{storage::{storage_read, storage_write}}, state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T> Storage<T> for SharedImmutable<T> {}\n\nimpl<T> SharedImmutable<T> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(\n            self.context.private.is_none(), \"SharedImmutable can only be initialized from public functions\"\n        );\n        // TODO(#4738): Uncomment the following assert\n        // assert(\n        //     self.context.public.unwrap_unchecked().is_deployment(), \"SharedImmutable can only be initialized during contract deployment\"\n        // );\n\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let fields_read: [Field; 1] = storage_read(initialization_slot);\n        assert(fields_read[0] == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        storage_write(initialization_slot, [0xdead]);\n\n        let fields_write = T::serialize(value);\n        storage_write(self.storage_slot, fields_write);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public read only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.public.is_none(), \"Private read only supported in private functions\");\n        let private_context = self.context.private.unwrap();\n\n        // Read the value from storage (using the public tree)\n        let fields = storage_read(self.storage_slot);\n\n        // Loop over the fields and prove their inclusion in the public tree\n        for i in 0..fields.len() {\n            // TODO: Update membership proofs to use current header (Requires #4179)\n            // Currently executing unnecessary computation:\n            // - a membership proof of the value in the public tree of the header \n            prove_public_value_inclusion(\n                fields[i],\n                self.storage_slot + i as Field,\n                (*private_context).this_address(),\n                (*private_context)\n            )\n        }\n        T::deserialize(fields)\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr" }, "70": { "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::{AztecAddress},\n    header::Header, utils::field::full_field_less_than\n};\nuse dep::std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::{get_public_data_witness}};\n\nfn _public_value_inclusion(\n    value: Field,\n    storage_slot: Field,\n    contract_address: AztecAddress,\n    header: Header\n) {\n    // 1) Compute the leaf slot by siloing the storage slot with the contract address\n    let public_value_leaf_slot = pedersen_hash(\n        [contract_address.to_field(), storage_slot],\n        GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n    );\n\n    // 3) Get the membership witness of the slot\n    let witness = get_public_data_witness(\n        header.global_variables.block_number as u32,\n        public_value_leaf_slot\n    );\n\n    // 4) Check that the witness matches the corresponding public_value\n    let preimage = witness.leaf_preimage;\n\n    // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n    // 1. The value is the same as the one in the witness\n    // 2. The value was never initialized and is zero\n    let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n    let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n    let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n    let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n    if is_in_range {\n        assert_eq(value, 0, \"Non-existant public data leaf value is non-zero\");\n    } else {\n        assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot don't match witness\");\n        assert_eq(preimage.value, value, \"Public value does not match the witness\");\n    }\n\n    // 5) Prove that the leaf we validated is in the public data tree\n    assert(\n        header.state.partial.public_data_tree.root\n        == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n    );\n    // --> Now we have traversed the trees all the way up to archive root and that way verified that a specific\n    // `value` was really set in a given contract storage slot at block `block_number` in public data tree.\n}\n\npub fn prove_public_value_inclusion(\n    value: Field, // The value that we want to prove is in the public data tree\n    storage_slot: Field, // The storage slot in which the value is stored\n    contract_address: AztecAddress, // The contract we want to look into\n    context: PrivateContext\n) {\n    _public_value_inclusion(\n        value,\n        storage_slot,\n        contract_address,\n        context.historical_header\n    );\n}\n\npub fn prove_public_value_inclusion_at(\n    value: Field, // The value that we want to prove is in the public data tree\n    storage_slot: Field, // The storage slot in which the value is stored\n    contract_address: AztecAddress, // The contract we want to look into\n    block_number: u32, // The block at which we'll prove that the note exists\n    context: PrivateContext\n) {\n    let header = context.get_header_at(block_number);\n\n    _public_value_inclusion(value, storage_slot, contract_address, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/public_value_inclusion.nr" }, "71": { "source": "use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::{PrivateContext, ContextInterface},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\nfn _nullifier_inclusion(nullifier: Field, header: Header) {\n    // 1) Get the membership witness of the nullifier\n    let witness = get_nullifier_membership_witness(header.global_variables.block_number as u32, nullifier);\n\n    // 2) Check that the witness we obtained matches the nullifier\n    assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n    // 3) Compute the nullifier tree leaf\n    let nullifier_leaf = witness.leaf_preimage.hash();\n\n    // 4) Prove that the nullifier is in the nullifier tree\n    assert(\n        header.state.partial.nullifier_tree.root\n        == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n    );\n    // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n    //     was included in the nullifier tree.\n}\n\npub fn prove_nullifier_inclusion<TContext>(\n    nullifier: Field,\n    context: TContext\n) where TContext: ContextInterface {\n    _nullifier_inclusion(nullifier, context.get_header());\n}\n\npub fn prove_nullifier_inclusion_at(\n    nullifier: Field,\n    block_number: u32, // The block at which we'll prove that the nullifier exists in the nullifier tree\n    context: PrivateContext\n) {\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n\npub fn prove_note_is_nullified<Note, N>(\n    note: Note,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n\n    _nullifier_inclusion(nullifier, context.historical_header);\n}\n\npub fn prove_note_is_nullified_at<Note, N>(\n    note: Note,\n    block_number: u32,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr" }, "72": { "source": "use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext,\n    note::{utils::compute_note_hash_for_consumption, note_interface::NoteInterface},\n    oracle::get_membership_witness::get_note_hash_membership_witness\n};\n\npub fn _note_inclusion<Note, N>(note: Note, header: Header) where Note: NoteInterface<N> {\n    // 1) Compute note_hash\n    let note_hash = compute_note_hash_for_consumption(note);\n\n    // 2) Get the membership witness of the note in the note hash tree\n    let witness = get_note_hash_membership_witness(header.global_variables.block_number as u32, note_hash);\n\n    // 3) Prove that the commitment is in the note hash tree\n    assert_eq(\n        header.state.partial.note_hash_tree.root, compute_merkle_root(note_hash, witness.index, witness.path), \"Proving note inclusion failed\"\n    );\n}\n\npub fn prove_note_inclusion<Note, N>(note: Note, context: PrivateContext) where Note: NoteInterface<N> {\n    _note_inclusion(note, context.historical_header);\n}\n\npub fn prove_note_inclusion_at<Note, N>(\n    note: Note,\n    block_number: u32, // The block at which we'll prove that the note exists\n    context: PrivateContext\n) where Note: NoteInterface<N> {\n    let header = context.get_header_at(block_number);\n\n    _note_inclusion(note, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/note_inclusion.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "91": { "source": "use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u64 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nfn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u64, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "94": { "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n/// - Pack arguments will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr" }, "99": { "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, \n    address::AztecAddress, \n    constants::ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr" }, "100": { "source": "use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr" }, "103": { "source": "use dep::protocol_types::{address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr" }, "107": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "108": { "source": "use dep::protocol_types::{constants::{ARCHIVE_HEIGHT, NOTE_HASH_TREE_HEIGHT}, utils::arr_copy_slice};\n\nglobal NOTE_HASH_TREE_ID = 1;\nglobal ARCHIVE_TREE_ID = 4;\n\n// Note: We have M here because we need to somehow set it when calling get_membership_witness function and one way to\n// do it is to set M here and then set type of the return param, e.g.:\n//\n// `let witness: MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> = get_membership_witness(...);`\n//\n// Another way to do it would be to add \"type_hint: [Field; T]\" as argument to `get_membership_witness` but that's\n// a bit too boilerplatey for my taste.\nstruct MembershipWitness<N, M> {\n    index: Field,\n    path: [Field; N],\n}\n\n#[oracle(getMembershipWitness)]\nfn get_membership_witness_oracle<M>(\n    _block_number: u32,\n    _tree_id: Field,\n    _leaf_value: Field\n) -> [Field; M] {}\n\nunconstrained pub fn get_membership_witness<N, M>(\n    block_number: u32,\n    tree_id: Field,\n    leaf_value: Field\n) -> MembershipWitness<N, M> {\n    let fields: [Field; M] = get_membership_witness_oracle(block_number, tree_id, leaf_value);\n    MembershipWitness { index: fields[0], path: arr_copy_slice(fields, [0; N], 1) }\n}\n\n// Note: get_nullifier_membership_witness function is implemented in get_nullifier_membership_witness.nr\n\nunconstrained pub fn get_note_hash_membership_witness<N, M>(\n    block_number: u32,\n    leaf_value: Field\n) -> MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> {\n    get_membership_witness(block_number, NOTE_HASH_TREE_ID, leaf_value)\n}\n\n// There is no `get_public_data_membership_witness` function because it doesn't make sense to be getting a membership\n// witness for a value in the public data tree.\n\nunconstrained pub fn get_archive_membership_witness(\n    block_number: u32,\n    leaf_value: Field\n) -> MembershipWitness<ARCHIVE_HEIGHT, ARCHIVE_HEIGHT + 1> {\n    get_membership_witness(block_number, ARCHIVE_TREE_ID, leaf_value)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_membership_witness.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "114": { "source": "use dep::protocol_types::{\n    hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, ContextInterface},\n    oracle::get_contract_instance::get_contract_instance,\n    history::nullifier_inclusion::prove_nullifier_inclusion,\n};\n\npub fn mark_as_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(*context);\n    ContextInterface::push_new_nullifier(context, init_nullifier, 0);\n}\n\npub fn assert_is_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_contract_initialization_nullifier(*context);\n    prove_nullifier_inclusion(init_nullifier, *context);\n}\n\npub fn compute_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    let address = context.this_address();\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(context)\n    )\n}\n\npub fn compute_unsiloed_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    context.this_address().to_field()\n}\n\npub fn assert_initialization_matches_address_preimage<TContext>(context: TContext) where TContext: ContextInterface {\n    let address = context.this_address(); \n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert((instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\");\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash([init_selector.to_field(), init_args_hash], GENERATOR_INDEX__CONSTRUCTOR)\n}", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "131": { "source": "pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr" }, "132": { "source": "struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "145": { "source": "use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field(),\n            portal_contract_address.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr" }, "146": { "source": "use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::ToField\n};\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address,\n                deployer\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n    let deployer = AztecAddress::from_field(7);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address,\n        deployer\n    );\n\n    let expected_computed_address_from_preimage = 0x027ea2b41ced2ec9a98305984e96dd28518536a4628883ccdc06e38aa8997220;\n    assert(address.to_field() == expected_computed_address_from_preimage);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "163": { "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_private == other.is_private\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr" }, "168": { "source": "use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, abis::side_effect::Ordered\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    portal_contract_address : EthAddress,\n\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        assert(self.msg_sender.to_field() == 0);\n        assert(self.storage_contract_address.to_field() == 0);\n        assert(self.portal_contract_address.to_field() == 0);\n        assert(self.function_selector.to_field() == 0);\n        assert(self.is_delegate_call == false);\n        assert(self.is_static_call == false);\n        assert(self.side_effect_counter == 0);\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, call_context: CallContext) -> bool {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        call_context.msg_sender.eq(self.msg_sender)\n            & call_context.storage_contract_address.eq(self.storage_contract_address)\n            & call_context.portal_contract_address.eq(self.portal_contract_address)\n            & call_context.function_selector.eq(self.function_selector)\n            & (call_context.is_delegate_call == self.is_delegate_call)\n            & (call_context.is_static_call == self.is_static_call)\n            & (call_context.side_effect_counter == self.side_effect_counter)\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender.to_field(),\n            self.storage_contract_address.to_field(),\n            self.portal_contract_address.to_field(),\n            self.function_selector.to_field(),\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.side_effect_counter as Field,\n        ]\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        CallContext {\n            msg_sender: AztecAddress::from_field(serialized[0]),\n            storage_contract_address: AztecAddress::from_field(serialized[1]),\n            portal_contract_address: EthAddress::from_field(serialized[2]),\n            function_selector: FunctionSelector::from_field(serialized[3]),\n            is_delegate_call: serialized[4] as bool,\n            is_static_call: serialized[5] as bool,\n            side_effect_counter: serialized[6] as u32,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let _hashed = context.hash();\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr" }, "184": { "source": "use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem, side_effect::SideEffect\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x02e15f4157b5e2cb0a7ec3dfec18c6812ef16e1da319b364e5a11e337dfca414;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x0f22ddeca80a2c6f455165f1d2d1950c5e1b772bdc312742d1de089b424f0f5f;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr" }, "186": { "source": "use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr" }, "196": { "source": "global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr" }, "198": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::AztecAddress,\n    constants::{\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs{\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    prover_address: AztecAddress,\n\n    reverted: bool,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.reverted as Field);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            reverted: reader.read() as bool,\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x083ac560a513d670a7f50f0a3052d42cb9816b7b643e62025b8278652ad637ab;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr" }, "201": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "211": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "212": { "source": "use crate::traits::{Empty, Hash};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u64,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr" }, "227": { "source": "use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    portal_contract_address : EthAddress,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt) &\n        self.portal_contract_address.eq(other.portal_contract_address)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.portal_contract_address.to_field(),\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            portal_contract_address: EthAddress::from_field(serialized[4]),\n            public_keys_hash: PublicKeysHash::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.portal_contract_address,\n                self.deployer\n            )\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr" }, "241": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.owner.to_field(), self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "246": { "source": "use dep::aztec::{\n    protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress},\n    context::PrivateContext\n};\n\nstruct Token {\n  address: AztecAddress,\n}\n\nimpl Token {\n    pub fn at(address: AztecAddress) -> Self {\n        Self { address }\n    }\n\n    fn mint_public(self: Self, context: &mut PrivateContext, to: AztecAddress, amount: Field) {\n        let _ret = context.call_public_function(\n            self.address,\n            FunctionSelector::from_signature(\"mint_public((Field),Field)\"),\n            [to.to_field(), amount]\n        );\n    }\n\n    pub fn transfer(\n        self: Self,\n        context: &mut PrivateContext,\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field\n    ) {\n        let _ret = context.call_private_function(\n            self.address,\n            FunctionSelector::from_signature(\"transfer((Field),(Field),Field,Field)\"),\n            [from.to_field(), to.to_field(), amount, nonce]\n        );\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/claim_contract/src/interfaces.nr" }, "247": { "source": "contract Claim {\n    mod interfaces;\n\n    use dep::aztec::{\n        history::note_inclusion::prove_note_inclusion,\n        protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress},\n        state_vars::SharedImmutable\n    };\n    use dep::value_note::value_note::ValueNote;\n    use interfaces::Token;\n\n    struct Storage {\n      // Address of a contract based on whose notes we distribute the rewards\n      target_contract: SharedImmutable<AztecAddress>,\n      // Token to be distributed as a reward when claiming\n      reward_token: SharedImmutable<AztecAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(target_contract: AztecAddress, reward_token: AztecAddress) {\n        storage.target_contract.initialize(target_contract);\n        storage.reward_token.initialize(reward_token);\n    }\n\n    #[aztec(private)]\n    fn claim(proof_note: ValueNote, recipient: AztecAddress) {\n        // 1) Check that the note corresponds to the target contract and belongs to the sender\n        let target_address = storage.target_contract.read_private();\n        assert(\n            target_address == proof_note.header.contract_address, \"Note does not correspond to the target contract\"\n        );\n        assert_eq(proof_note.owner, context.msg_sender(), \"Note does not belong to the sender\");\n\n        // 2) Prove that the note hash exists in the note hash tree\n        prove_note_inclusion(proof_note, context);\n\n        // 3) Compute and emit a nullifier which is unique to the note and this contract to ensure the reward can be\n        // claimed only once with the given note.\n        // Note: The nullifier is unique to the note and THIS contract because the protocol siloes all nullifiers with\n        // the address of a contract it was emitted from.\n        context.push_new_nullifier(proof_note.compute_nullifier(&mut context), 0);\n\n        // 4) Finally we mint the reward token to the sender of the transaction\n        let reward_token = Token::at(storage.reward_token.read_private());\n        reward_token.mint_public(&mut context, recipient, proof_note.value);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/claim_contract/src/main.nr" } } }
