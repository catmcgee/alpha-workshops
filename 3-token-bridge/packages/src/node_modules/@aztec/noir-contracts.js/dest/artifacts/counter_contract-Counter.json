{ "noir_version": "0.25.0+d1ed549202e5a840845298c931418e173eb5437c", "name": "Counter", "functions": [{ "name": "increment", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "owner": [{ "start": 33, "end": 34 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406] }, "bytecode": "H4sIAAAAAAAA/+2dCXxdRdXAz3tZmr1NU7qwvhYoe3mTrS8FymuhZe8KBUpp+5K8tIE0qclroYCAgICAgICg7DuIfuqnooiC4icoKCgoKCgoKCgoVVB2KN+c5E7vedObtiZn4sxvMr/f+b1775s7c/5nZs6Zu8egLy2JAzwX61vGH7kKBVISZL0wWFbrRdp6sZa/RFuv1tZrtPVttPVx2noiEJoClSEd/NYlG+vrs1Nrs6JOZJK1Tc2phmR9Q3NjSqREQ6qhtTZVV5dN1aemNjU3TU02ifq6rGhraKprS/alSaSs5CBTjNgA00QpG6RM8vR3byk7B21G7bLzsF1gF+gbb6o/06T38eTgkmAsK0n13RX6fAKm4gj9VSqIWC4h+TYws9K6dF2qI/TcpA3SjMqYaMxdDZQ7GficqinuyfxttNFpx0ln2EB+R0jZLehMcdg0cXNuy8gWoe5gyxZqgdpi9+B3DwgdAXUI8QibqW1o14+1/9RvjOz/MeS3kZ4n1k855RF6VEdsM+YEFCwa6QUCj8ZKaHUWMNdNO9MAB3VtMKjF7sDnIPYAM508zmw/TuY9I8pqTra0NojmxtapIptpSLW0NNUJUZtpzDQ216bass0NItWQkmW2ZGpTsrraTIvIJjON2aGaOewJZmYOe8HwzGGLyphozL0MlLs32D1zQO69+dsoUlcOx7i3gXKviZlxuFwBS+nJ2Zf2Ab4+xGk/NQFA/SbC0M0sTQVdbj13Y9SziOg5JfjdV5Ud/IqAYUywXot9T0q9lAYpjVKmSklJaZIyTcp+UvaXcoCU6VIODHSeIWWmlIOkHCxllpQTAgOVEF3SXIz1ItMbQAv7ytL7UZz8p34T0Dcr3pg32I7b1HiOBdvw6GcChP/HtXp69wm2FZBthYV5RfduKwpWVJuUQGiTNHDZI9mIZZZyl5sU9SUQHk3wldvnDyogtE2a1FNKbFWp2oavbkHrVkdTqh61vZAsjyd5VT5lDzWRU7rj/2Vkub/9SrT9qkiesgj+NPDyl2v6UP0xFZFlnASqMTCe6Mbej5MiVQ75k2NlP9D0BaKH+h3Brk9SYFvsEJS1Ipubs6ajo72tPdt9VHZVc7a7Z2X76mPbc53Znh46O1YA4zUAeuhO/6cOjC4XRGxTsPzG7+sYI0g9abJeYknd/E4uWVsO+YEK0+Y6HXVQBpxjXTmpY2v0KSf6lPHrI0wFASxXOVnGo9pklMMt1WxFHW4Fsd9/y+EO6zw0OldBONaprnQM2aCj2kYnAwbG4Gb9brnZupO9k2atLpx4zCD1GvBndchcSupLEz1UfYUkz26xMO+sYFsl5McBxRDVjyr4GTbbjyqIjmVEN6WP6fitJutDOXdQnKrssoi6TccwvnJFivrWon7at5DkWRj8joKtP1ApIcvKRqZ8Xn/tQ+s2ME56x3rVVthR5TlBs2OVpndphB2p3zbI0jsPG2nIRqM0Gyn9RxIbqTzNmo3Udt1G1A9VkX2UjQyw1GK51YZsNFqzkdK/mthI5WnXbKS26zYaSWykbKPyxknZo8i+cZJH/b8h2K6XgflLtPU0j03yxrXy+WVa/SaP2ahPUTrQlCbLNFbz9w9R/58es1UTfUy0jaFx0BvvaoKyuI/Zxmi2KtVsVUXy1BD7jTFgvxjkX/1Mk3VV37DOwzoP6zys87DOwzoP6zys87DOwzoP6zys87DOg9cZ9VHH9/Scm8pXZomOahs932HguHuz12mqiX2KyDIE608R3Qycq65H3UaS+tJED3qOVeVZT/I+EyxXkv/pNYuo62AGzidt9npKKdGxguim9DFxzX1z11PKhqBuxanKrhjCurfEXQ6bXt+hfaWSbFNtV0W26edUcZsavyPJNuUHaZvHI3ShNwGqX3U9kfouNSboeFXXZUaTbYq3hpTh8vgwoE99lD5Fmj7UhxdredS+hSTPu8HvKDB1Xrbvup5qV/161Giik8rzIdGJ7qv0irqup3hoHDfAUk/nFbrfpywqTzyWb1/+uN13w6qpax3bECYstyKCVeUZQe4ZKI2FbaTaicbL8RH/qxTT1tNkWdkPmcfxM/eekx9P9EyTemjdE4iuTHULWre6b1LVo7YXkuVxsTCvyqfsoWytdMcxMjZYprrr+5Vr+1WRPGMj+NPAyz9O02ecpjO2SQXpZ+PJTfc1hnQa24+NioiNVB56jcvAtd7IeYrSQ9W3uRhA56YqT4L4KHoMQmO7rccgNURHnZEeB7h879JQ6VOo6UPvqSnW8tC5hMojtFhXxa5331xCP+6i910qnVSeBqIT3VfpFTWXUDwqbwnk34uQZmHpu7+iWmNR9h1FWFSe/TT7mrjnwxCroPeDqLlEWQTrxnkM8fEzyVxBtQm9l3F+xP8qbW4uQX21AV+WpPMn1b5jIuoeS3Rlqjtv7qbmEqoeOqdTy/PIXEKPd8rWSnccH8rvUt31/UZq+9E4WRPBnwZefv383xhN5957W0k/m0/mEvy+q0+nmn5sVEhspPJE3b9Nj9Wj7vc0dRzc372M9FxDGVlWOm7uXmd9bLIqjCctBOQPeIBNXx0x2KePGZ9iFfvylZUcqldHcD7FS/WdDcOvjtiiMiYac7aBcg8BvgFnivsQ/jYaskGYBDOD8FAYHoRbVMZEYx5qoNzDwO5BiIUext9GQzYIBZgZhIfD8CDcojImGvNwA+UeAXYPQuQ+gr+NjOiKEfsw4H+J0pHAO5BxEKoBiTMNHIjJ4FcEv5iOCn65ebA9jzRQ7hzGtlSHZdCPDZKDS2IKX1lJdR5hrpR5UuZLWQB9zyMeLeUYKYukHCvlOCnHS1kMfc/ZLZFyopSlUpZJWS4lA33Pl8UhfGvkXAjP28SDeuj6fG19gba+UFs/Wls/RltfpK0fq60fp60fr60v1tZP0NaXaOsnautLtfVl2vpybT2jrTdD/wExHfwmB5fy+tBgx85cxrK+GOP10/3Zb6B6Ztv60jy+slrnM9rvWjfs17SAryyxkNF+1zlhv6w4mq2sFnEMo/2ud8J+KbGIraykOJbRfje4YL9sUhzHVVZLUhzPaL8bXbBfKikWc5UlY/kJjPa7yQH7ZSXzEqayWmRZJzLa72YH7JeSzEuZypJqimWM9rvFfvtlkXk5T1ktWFaG0X632m+/FDI3A9+xDD1mGKz9bhsi+yUHlwTjPF9cx2i/2x2xH+M8VdzAaL87HLEf4zxL3MRovzsdsR/jPEHcwmi/uxyxH2OcE7cx2u9uR+zH6KfFHYz2+5Ij9mP0M+IuRvvd44j9GMeJYOwzwpT94pr9bDrn3sLYrlgG9/UuvJY4B/iv+bUCb1tzc+NHPeYa4H4gZjc39sdWA9wPWn5srPTMMtqSsa3Fg5b3GxwvLQb6zUOWc881NF5+5Mh4aWO0JWNbC077qXtv1DwCfQTea9MG4T03KyA/cc855jGWtRLsnnPgx7TmAf+YethyX4J9aKUB7kcc8SXtjLZkbGvxiOX9ps5Qv3nUcm70ESsMcD/myHg5idGWjG0tHjMYe9FHYMw9CcLYezLkJ+7Yy3mPWAfYHXvrIbwnlNOGj1vuS7APdRjgfsIRX7KK0ZaMbS2esLzf1BvqN09azo0+4mQD3E85Ml46GW3J2NbiKYOxF30ExtxOCGNvF+Qn7ti7gLGs1WB37MWPRy8A/jH1tOW+BPvQagPczzjiSz7BaEvGthbPWN5vGgz1m2ct50Yf0WWA+zlHxks3oy0Z21o8ZzD2oo/AmNsNYeztgfzEHXs5n+3Jgd2xtxHCZx05bfi85b4E+1DOAPcLjviSNYy2ZGxr8YLl/abRUL950XJu9BE9BrhfcmS8rGW0JWNbi5cMxl70ERhz10IYe0+B/MQde49mLOtUsDv2ToXwvQKcNnzZcl+CfehUA9yvOOJL1jHakrGtxSuW95uphvrNq5Zzo484xQD3a46Ml9MYbcnY1uI1g7EXfQTG3NMgjL2nQ37ijr2c72Q4A+yOvSkI3+HDacPXLfcl2IfOMMC93hFf8klGWzK2tVhveb9JGeo3b1jOjT7idAPcbzoyXs5ktCVjW4s3DcZe9BEYc8+EMPaeBfmJO/YuYizrbLA79jZB+L48Thu+ZbkvwT50tgHutx3xJZ9itCVjW4u3Le83TYb6zXuWc6OPOMsA9/uOjJdzGG3J2NbifYOxF30ExtxzIIy950J+4o69nO/SOw/sjr3TIHw3LacNP7Lcl2AfOs8A9wZHfMmnGW3J2NZig+X9ZpqhfhOL282NPuJcA9zxuBvj5XxGWzK2teC0nx570UdgzD0fwth7AeQn7th7HGNZF4LdsXc/CN8Dz2nDIst9CfahCw1wFzviSz7DaEvGthbFlveb/Qz1m1LLudFHXGCAu8yR8XIRoy0Z21qUGYy96CMw5l4EYey9GPITd+zlfAf6JWB37N0fwm+ucNqw0nJfgn3oEgPcVY74ks8y2pKxrUWV5f1mf0P9ptpybvQRFxvgHu3IeLmU0ZaMbS1GG4y96CMw5l4KYey9DPITd+xdzFjW5WB37D0Awu+bcdpwG8t9Cfahyw1wj3XEl3yO0ZaMbS3GWt5vDjDUbyZYzo0+4jID3Ns6Ml6uYLQlY1uLbQ3GXvQRGHOvgDD2Xgn5iTv2cn676iqwO/ZOh/Bbopw23MFyX4J96CoD3Ds64ks+z2hLxrYWO1reb6Yb6jcTLedGH3GlAe5JjoyXqxltydjWYpLB2Is+AmPu1RDG3msgP3HH3iWMZX0B7I69B0L43W5OG+5quS/BPvQFA9yTHfElX2S0JWNbi8mW95sDDfWbPSznRh9xjQHuPR0ZL9cy2pKxrcWeBmMv+giMuddCGHuvg/zEHXs5vzl8Pdgde7GcEw2MqX0s9yXYh643wD3FEV9yA6MtGdtaTLG836QN9RthOTf6iOsMcNc6Ml5uZLQlY1uLWoOxF30ExtwbIYy9N0F+4o69SxnLuhnsjr0zZBlLgX9MNVjuS7AP3WyAu9ERX3ILoy0Z21o0Wt5vZhjqN02Wc6OPuMkA9zRHxsutjLZkbGvBaT899qKPwJh7K4Sx9zbIT9yxdxljWbeD3bF3pixjmYExdYDlvgT70O0GuKc74kvuYLQlY1uL6Zb3m5mG+s0My7nRR9xmgHumI+PlTkZbMra14LSfHnvRR2DMvRPC2HsX5Cfu2Lucsay7we7Ye5AsYznwj6lZlvsS7EN3G+Ce7Ygv+RKjLRnbWsy2vN8cZKjfHGY593Lo87vc3Ic7Ml7uYbQlY1uLww3GXvQRGHPvgTD2fhnyE3fszTCW9RWwO/YeLMvIGBhTR1nuS7APfcUA9xxHfMn/MNqSsa3FHMv7zcGG+s18y7nRR3zZAPcCR8bLVxltydjWYoHB2Is+AmPuVyGMvV+D/MQde5sZy/o62B17Z8kymg2MqWMs9yXYh75ugHuRI77kfxltydjWYpHl/WaWoX5zvOXc6CO+ZoB7sSPj5RuMtmRsa8FpPz32oo/AmPsNCGPvNyE/6bE3ObgkxjC22TfBTN/iHgPfYrSf3obfCtpuIoRteG8wPmKwaeL2G/cCb/9U6dtSioLl4gj9VSqIWC4h+TYA7/yM1qXrUh2h5yZtkGZUxkRjfttAud8BvsFkivs7/G20WaeSHFzKs2lykKkgQk9M90kpDZZLNPuw1F2fFL2DuxAi0wgInUA5yaecXzXZpvQuk1IVLK/I5hZkOlu7Vs1uz3a0UrJ4BK2esMYCLX85WVb/lYLBYa78vapM9/f3Qej3vxsoQuPDvcH/3yX57g/Ki7K6zfEhQt0Bld2cqm0WWdHU0JrM1Erf0lpX3xCD/Fgy2DoikjBl44nAb2NuHe8DN9zq/WBmPvM9KaODZUOudCp1pXTOhIk6LpWHOrhYYahbIb9utVhuEXe5sr3KCWtRoDiGjTLCXRwRNoq1sFES7MetX4xwq7LVuqqvDMK5Y2dXrr1t3UHd2Uwu2zqnK5elnUjtQLdRJx4nywUkb6G2DVNxxP4qfyyiHEwlEHbeNJgxUgzyjaTqKyfLI8i2uJbPaDQGzVCcZX8PzHhI7iP4BPBN5r/P3ImQFctEHYfqCJgz+tKjRjXwHpDyoJQfSNkh2GYogtTTCKLbLiqC4ECsIToZiBzCUOSoM+TxN55lg0DvNKmHOjV1YBUD3jFQQsqNwaYHcIVkeTTJq/Ipe6i2VrpXQhg0SjezX6G2XxXJUxzBnwZe/hGaPiM0nYvINoy6auZDzx6Z6G90tgXEfqDpC0RPpQ/7uMIvJkDoT+SB8rw1zR3tLUdk183obJ2X6c61ZzpmtLZ2Z3t6opxSgQbQ36xhS8fc5QS0gGzTZyfU+dAzAmof2jGNH4srRdAz4zH1g8HvdlJ+CJseg/8w+P8Hwe9IKQ9pOnJf42aMSuIhvrJ6TzXpxyYA/FGZ0asaPd505fyISRs84EhbPcio5/D5pr5kSkfO8000yCk//SMp/ydFGdnQjDxDZ+S0Dkxbe06nPPwb4mTbxsBLtm0MvKRO9llyfbLB1KkE1HUChLobOCJJGZoh1g4fkQCMJ3l9OiKpDJbxiKREO19pUjfdb5VouuFRwqhgObuqPTers6V73Wp5bvLIrhV0ok3tD5ptKQsmGvfo6ceiiH2p/fTJflTq70AEudQ54TSY699psl5G6q7gr7u2nNRB+WlKk+UKok+5AVsY4uz1X5UaU5nGVEXyUP9SaYAzRupVZav1yoi6Ge9B6bVF1VbYoipCn6ohtoWqr5xso9dl6P/qN66x0PmMym/8FD/3ZDQhy5gM/DeW/ZhPR6OXDDiZH3aEOcbI/IgjzHFG5p84wlzAyPxTR5gLGZkfdYS5iJH5MUeYixmZf+YI8y6MzD93hHkSI/PjHjI/4SHzLzxk/qUjzD9mZH7Sw3Z+ykPmX3nI/GsPmZ/2kPkZD5l/4yHzbz1kftZD5uc8ZP6dh8y/95D5eQ+ZX/CQ+Q8eMv/RQ+YXPWR+yUPmP3nI/GcPmV/2kPkVD5n/4iHzXz1kftVD5tc8ZP6bh8x/95D5dQ+Z13vI/A8Pmf/pIfMbHjK/6SHzvzxk/reHzG95yPy2h8zveMj8rofM73nI/L6HzB94yPyhh8wfecjM+YCmK8wfe8iMD2D6xhzzkDnuIXOBh8yFHjIXechc7CHzCA+ZSzxkLvWQucxD5nIPmSs8ZK70kLnKQ+aRHjKP8pC52kPm0R4y13jIPMZD5m08ZB7rIfM4D5nHe8g8wRHm+xmZt3WEOcHIvJ2HfXt7D5l38JB5Rw+Zd/KQOeEh80QPmSd5yLyzh8y7eMi8q4fMkz1k3s1D5t09ZN7DQ+Y9PWTey0PmvT1k3sdD5ikeMu/rIXPSQ2bhIXOth8x1HjLXe8jc4CFzo4fMUz1kTnnI3OQh8zQPmffzkHl/D5kP8JB5uofMB3rInPaQeYaHzDM9ZD7IQ+aDPWSe5SHzbA+ZD/GQ+VAPmQ/zkPlwD5mP8JD5SA+Zj/KQeY6HzHM9ZJ7nIfN8D5kXeMi80EPmoz1kPsZD5kUeMh/rIfNxHjIf7yHzYg+ZT/CQeYmHzCd6yLzUQ+ZlHjIv95A54yFzs4fMLR4yt3rInPWQuc1D5hUeMq/0kLndQ+aTPGQ+2UPmDg+ZV3nI3Okhc5eHzKs9ZP6Eh8zdHjL3eMic85B5jYfvrl3rCPP3GZlP8bBvn+oh8zoPmU/zkPl0D5nP8JD5k44wj2BkPtMR5hJG5rMcYS5lZD7bEeYyRuZPOcJczsh8jiPMFYzM5zrCXMnIfJ4jzFWMzJ92hHkkI/P5jjCPYmS+wBHmakbmCx1hHs3I/BlHmGsYmS9yhHkMI/PFjjBvw8h8iSPMYxmZP+sI8zhG5ksdYR7PyHyZI8wTGJkvd4R5W0bmzznCvB0j8xWOMG/PyHylI8w7MDJf5QjzjozMn3eEeSdG5qsZmWVRUBCUNYnwxwIb4H+FUoqkFEvB8/R43hrP4+J5TTzPh+e98DwQnhfB8wR43IzHkXhchccZOO/GeSjOy3CegnEb4xj6dfRzOO5xHGC/QDslpEwkujwV/D4s5REpP5HyUymPSnlMys+k/FzK41KekPILKb+U8mSw76+k/FrK01KekfIbKb+V8qyU56T8TsrvpTwv5QUpf5DyRykvSnlJyp+k/FnKy1JekfIXKX+V8qqU16T8TcrfpbwuZb2Uf0j5p5Q3pLwp5V9S/i3lLSlvS3lHyrtS3pPyvpQPpHwo5SMpG6R8HDRATEpcSoGUQilFUoqljJBSIqVUSpmUcikVUiqlVEkZKWWUlGopo6XUSMFvw+O30vHb4fgtbfy2NH5rGb89jN/ixW/T4rda8dul+C1P/LYlfusRv32I3wLEb+Pht+Lw22n4LTH8thZ+awq/vYTfIsJv8+C3avDbLfgtE+xY+K0L/PYDfgsBvw2A78rHd8fju9Tx3eL4rm189zS+ixnfTYzv6sV31/a+y1UKvusT332J74LEdyPiuwLx3Xn4Ljl8txq+awzfvYXvosJ3M+G7ivDdPfguG3y3C77rBN/9ge/CwHdD4LsS8N0B+Cw9PluOz1rjs8f4LC4+m4rPauKzi/gsHz7bhs964bNP+CwQPhuDz4rgsxP4LAHeW4/3muO913gvMt6bi/eq4r2beC8j3tuH97rhvV94LxTeG4T3yuC9I3gvBd5bgNfa8dozXovFa5N4rQ6vXeG1HLy2gef68dw3ngvGc6N4rhDPneG5JDy3guca8Ngbj0Xx2AyPVXDujnNZnNvhXAdjP8ZCjA3oK9F3jCRja8fgd4/gd86ajo72tvZsd6K1K9uT6OzKJVZlci0rE2szHWuyifbOxCntuc5sTw8EnRqTchzzurvWtneuSHRuLKS9s6VjTU97V2eiLdPekW2FoMtj2j/4XZjr6s6syCZ6OmRlyd4qMx0dXadkW6ckFpL/ehKr1vTkEj25THcu0dbdtSohpvSOlFhfOdsH5WVyueyq1blEriuRaW1FfVcmutZmu9tkmTGSb0HwOyH4ndHdnVknNW7NnproWpNLdLUlmrvWdLb20J0WD2SnzEB2WjmQnd6Bgdnig4FUpgz/H+200wBbKznA/eoHouS0rd0J/h/Cv3HfvQICAA==", "debug_symbols": "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" }, { "name": "get_counter", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "owner": [{ "start": 0, "end": 1 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [1] }, "bytecode": "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", "debug_symbols": "1f3drufJsR7o3YuOBaMyIyIzY27F8IH8BQxgyIZHNmAYc+9uwZtNya42qUdc4d8c7eZmBXOR9UZ29bPe/K//57/7P/2f/3f/4T/9j//n//g//bv/4f/57379r86/+x/+1//Pf/c//V/+w3/8z//6f/pP/+H/+p/+3f/w69//u//Df/zf//F//+d//+/+j//j/+n/8O/+h13vf/73/1+/rnP/26/sOn/+2rV+/ebX7nv/7dfGr7//50b9z/+bf//Hl3G/8WW8b3wZ/Y0vY/36yNexPvJ17I98HfGRryM/8nXUR76Oj1ym6yO36frIdbo+cp/uj9yn+yP36f7Ifbo/cp/uj9yn+yP36f7Ifbo/cp/uj9yn+yP3aXzkPo2P3Kfxkfs0PnKfxkfu0/jIfRofuU/jI/dpfOQ+jY/cp/mR+zQ/cp/mR+7T/Mh9mh+5T/Mj92l+5D7Nj9yn+ZH7ND9yn9ZH7tP6yH1aH7lP6yP3aX3kPq2P3Kf1kfu0PnKf1kfu0/rIfXo+cp+ej9yn5yP36fnIfXo+cp+ej9yn5yP36fnIfXo+cp+ej9yn9yP36f3IfXo/cp/ej9yn9yP36f3IfXq/Upb6yH16P3Kf3o/cp+8j9+n7yH36PnKfvo/cp+8j9+n7yH36PnKfvq+0Tz9yn76P3Kf9kfu0P3Kf9kfu0/7IfdofuU/7I/dpf+Q+7Y/cp/2VOv9n+vxfKfT/+kqj/9dXKv2/vtLp//WRS3X9+kqr/9dXav2/vtLr//WVYv+vr9ys33kq9ZWb9TOPpT7zWuozz6U+817qMw+mPvNi6jNPpr7yZmp95dHU+sqrqfWVZ1PrK++m1lceTq2vvJxaX3k6tb7ydmp95fHU+srrqfWV51PrK++n1lceUK2vvKBaX3lCtb7yhmp95RHV+sorqvWVZ1TrK++o1lceUq2vvKRaX3lKtb7ylmp95THV+sprqvWV51TrK++p1lceVK2vvKhaX3lStb7ypmp95VHV+sqrqvWVZ1XrK++q1lceVq2vvKxaX3latb7ytmp95XHV+srrqvWV51XrK++r1lceWK2vvLBaX3litb7yxmp95ZHV+sorq/WVZ1brK++s1lceWq2vvLRaX3lqtb7y1mp95bHV+sprq/WV51brK++t1lceXK2vvLhaX3lytb7y5mp95dHV+sqrq/WVZ1frK++u1lceXq2vvLxaX3l6tb7y9mp95fHV+srrq/WV51frK++v1lceYK2vvMBaX3mCtb7yBmt/5Q3W/sobrP2VN1j7K2+w9q+P3Kz7K2+w9lfeYO2vvMHaX3mDtb/yBmt/5Q3W/sobrP2VN1j7K2+w9lfeYO2vvMHaX3mDtb/yBmt/5Q3W/szPrfrMD676zk+u+srN+pmfXfWZH171mZ9e9ZkfX/WZn1/1mR9g9ZU3WPsrb7D2V95g7a+8wdpfeYO1v/IGa3/lDdb+yhus/ZU3WPsrb7D2V95g7a+8wdpfeYO1v/IGa3/lDdb+yhus/ZU3WPsrb7D2V95g7a+8wdpfeYO1v/IGa3/lDdb+yhus/ZU3WPsrb7D2V95g7a+8wdpfeYO1v/IGa3/lDdb+yhus/ZU3WPsrb7D2V95g7a+8wdpfeYO1v/IGa3/lDdb+yhus/ZU3WPsrb7D2V95g7a+8wdpfeYO1v/IGa3/lDdb+yhus/ZU3WPsrb7D2V95g7a+8wdpfeYO1v/IGa3/lDdb+yhus/ZU3WPsrb7D2V95g7a+8wdpfeYO1v/IGa3/lDdb+yhus/ZU3WPsrb7D2V95g7a+8wdpfeYO1v/IGa3/lDVZ85Q1WfOUNVnzlDVZ85Q1W/PrIzRpfeYMV/51vsM7f/sP7rf/OL+R+5Qt5X/lC+iNfyH/nG6x/4ReyvvKF7K98IfGVLyS/8oXUV76Qr9ys6ys36/rKzbq+crPur9ys+ys36/7Kzbq/crPur9ys+ys36/7Kzbq/crPur9ys+ys3a3zlZo2v3KzxlZs1vnKzxldu1vjKzRpfuVnjKzdrfOVmja/crPmVmzW/crPmV27W/MrNml+5WfMrN2t+5WbNr9ys+ZWbNb9ys9ZXbtb6ys1aX7lZ6ys3a33lZq2v3Kz1lZu1vnKz1ldu1vrKzXq+crOer9ys5ys36/nKzXq+crOer9ys5ys36/nKzXq+crOer9ys9ys36/3KzXq/crPer9ys9ys36/3KzXq/crPer9ys9ys36/3Kzfq+crO+r9ys7ys36/vKzfq+crO+r9ys7ys36/vKzfq+crO+r9ys/ZWbtb9ys/ZXbtb+ys3aX7lZ+ys3a3/lZu2v3Kz9lZu1P3Kz5q+P3Kz56yM3a/76yM2avz5ys+avj9ys+esjN2t+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfuUNVn7lDVZ+5Q1WfeUNVn3lDVZ95Q1WfeUNVv36yM1aX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVV95g1VfeYNVX3mDVb9/g7XWPf82tVbnP/pyVv3tyznvz197fvfV3Ij1b7/2Rtff/4N/rf/3F3R+/xbr/59f0PraF7S/9gXF176g/NoXVF/7gs7XvqD7tS/ofe0L+tpNvb52U6+v3dTrazf1+tpNvb52U69/wU29fmX8+av/iz90/fZL+mf/zJf9t6+8fr3/4tf2377w87/UL/z+L/ULf/9L/cL7R7/w//ch+9fEIWvikD1xSEwckhOH1MQhZ+KQO3HImzhkYuNjYuNjYuNjYuNjYuNjYuNjYuNjYuNjYuNjYuNjYuNzYuNzYuNzYuNzYuNzYuNzYuNzYuNzYuNzYuNzYuNrYuNrYuNrYuNrYuNrYuNrYuNrYuNrYuNrYuNrYuPPxMafiY0/Ext/Jjb+TGz8mdj4M7HxZ2Ljz8TGn4mNvxMbfyc2/k5s/J3Y+Dux8Xdi4+/Ext+Jjb8TG38nNv5NbPyb2Pg3sfFvYuPfxMa/iY1/Exv/Jjb+TWz8m9j4ntj4ntj4ntj4ntj4ntj4ntj4ntj4ntj4ntj4Htj4++vXxCFr4pA9cUhMHJITh9TEIWfikDtxyJs4ZGLj18TGr4mNXxMbvyY2fk1s/JrY+DWx8Wti49fExk907u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7uROfuTnTu7kTn7k507u5E5+5OdO7eROfuTXTu3kTn7k107t6vnDikJg45E4fciUPexCETGz/RuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOduzfRuXsTnbs30bl7E527N9G5exOdu57o3PVE564nOnc90bnrXzlxSE0cciYOuROHvIlDJjZ+onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527nujc9UTnric6dz3RueuJzl1PdO56onPXE527P/5/v0ZOWSOn7JFTYuSUHDmlRk45I6fckVPeyCkju79Gdn+N7P4a2f01svtrZPfXyO6vkd1fI7u/RnZ/jez+Htn9PbL7e2T398ju75Hd3yO7v0d2f4/s/h7Z/T2y+zGy+zGy+zGy+zGy+zGy+zGy+zGy+zGy+zGy+zGy+zmy+zmy+zmy+zmy+zmy+zmy+zmy+zmy+zmy+zmy+zWy+zWy+zWy+zWy+zWy+zWy+zWy+zWy+zWy+zWy+2dk98/I7p+R3T8ju39Gdv+M7P4Z2f0zsvtnZPfPyO7fkd2/I7t/R3b/juz+Hdn9O7L7d2T378ju35HdvyO7/0Z2/43s/hvZ/Tey+29k99/I7r+R3X8ju/9Gdv+N7H6P7H6P7H6P7H6P7H6P7H6P7H6P7H6P7H6P7P5Ir2+N9PrWSK9vjfT61kiv749fMHJKjZxyRk65I6e8kVNGdn+k17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fWuk17dGen1rpNe3Rnp9a6TXt0Z6fXuk17dHen17pNe3R3p9+1eOnFIjp5yRU+7IKW/klJHdH+n17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV7fHun17ZFe3x7p9e2RXt8e6fXtkV5fjPT6YqTXFyO9vhjp9cWvHDmlRk45I6fckVPeyCkjuz/S64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+M9PpipNcXI72+GOn1xUivL0Z6fTHS64uRXl+O9PpypNeXI72+HOn15a8cOaVGTjkjp9yRU97IKSO7P9Lry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX470+nKk15cjvb4c6fXlSK8vR3p9OdLry5FeX430+mqk11cjvb4a6fXVrxw5pUZOOSOn3JFT3sgpI7s/0uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV5fjfT6aqTXVyO9vhrp9dVIr69Gen010uurkV7fGen1nZFe3xnp9Z2RXt/5lSOn1MgpZ+SUO3LKGzllZPdHen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dGen1npNd3Rnp9Z6TXd0Z6fWek13dHen13pNd3R3p9d6TXd3/lyCk1csoZOeWOnPJGThnZ/ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen13ZFe3x3p9d2RXt8d6fXdkV7fHen1vZFe3xvp9b2RXt8b6fW9XzlySo2cckZOuSOnvJFTRnZ/pNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen1vpNf3Rnp9b6TX90Z6fW+k1/dGen090uvrkV5fj/T6eqTX179y5JQaOeWMnHJHTnkjp4zs/kivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivr0d6fT3S6+uRXl+P9Pp6pNfXI72+Hun19Uivryd6ffvXRK/vj1PWyCl75JQYOSVHTqmRU87IKXfklDdyysjur5HdXyO7v0Z2f43s/hrZ/TWy+2tk99fI7q+R3V8ju79Hdn+P7P4e2f09svt7ZPf3yO7vkd3fI7u/R3Z/j+x+jOx+jOx+jOx+jOx+jOx+jOx+jOx+jOx+jOx+jOx+jux+jux+jux+jux+jux+jux+jux+jux+jux+jux+jex+jex+jex+jex+jex+jex+jex+jex+jex+jez+Gdn9M7L7Z2T3z8jun5HdPyO7f0Z2/4zs/hnZ/TOy+3dk9+/I7t+R3b8ju39Hdv+O7P4d2f07svt3ZPfvyO6/kd1/I7v/Rnb/jez+G9n9N7L7b2T338juv5HdfyO73yO73yO73yO73yO73yO73yO73yO73yO73yO7P9LrWyO9vjXS61sjvb410uv74xeMnFIjp5yRU+7IKW/klJHdH+n1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fGun1rZFe3xrp9a2RXt8a6fWtkV7fHun17ZFe3x7p9e2RXt/+lSOn1MgpZ+SUO3LKGzllZPdHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk17dHen17pNe3R3p9e6TXt0d6fXuk1xcjvb4Y6fXFSK8vRnp98StHTqmRU87IKXfklDdyysjuj/T6YqTXFyO9vhjp9cVIry9Gen0x0uuLkV5fjPT6YqTXFyO9vhjp9cVIry9Gen0x0uuLkV5fjPT6YqTXFyO9vhjp9cVIry9Gen0x0uuLkV5fjPT6YqTXFyO9vhjp9cVIry9Gen0x0uuLkV5fjPT6YqTXFyO9vhjp9cVIry9Gen0x0uuLkV5fjPT6YqTXFyO9vhjp9cVIry9Gen0x0uuLkV5fjPT6YqTXFyO9vvirXl/230/p/+qUvw1uHQwdTB0sHTw6eHXw6WDj4F9VyP7xoCbnanKuJudqcq4m52pyribnanKuJudpcp4m52lynibnaXKeJudpcp4m52lynianNTmtyWlNTmtyWpPTmpzW5LQmpzU5jcnJX790cOng1sHQwdTB0sGjg1cHnw5qcpYmZ2lyliZnaXKWJmdpcpYmZ2lyliZnaXK2JmdrcrYmZ2tytiZna3K2JmdrcrYmZ2tyQpMTmpzQ5IQmJzQ5ockJTU5ockKTE5qc1OSkJic1OanJSU1OanJSk5OanNTkpCanNDmlySlNTmlySpNTmpzS5JQmpzQ5pck5mhw15FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0N+ashPDfmpIT815KeG/NSQnxryU0NuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415EZDjl9oyH8MLh3cOhg6mDpYOnh08Org00FNztLkLE3O0uQsTc7S5CxNztLkLE3O0uQsTc7W5GxNztbkbE3O1uRsTc7W5GxNztbkbE1OaHJCkxOanNDkhCYnNDmhyQlNTmhyQpOTmpzU5KQmJzU5qclJTU5qclKTk5qc1OSUJqc0OaXJKU1OaXJKk1OanNLklCanNDlHk3M0OUeTczQ5R5NzNDlHk3M0OUeTczQ5V5NzNTlXk3M1OVeTczU5V5NzNTlXk3M1OU+T8zQ5T5PzNDlPk/M0OU+T8zQ5T5PzNDmtyWlNTmtyWpPTmpzW5LQmpzU5rclRQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+fweZm/E+rfBG11/H/y1/jb4e5j9ZwaXDm4dDB1MHSwdPDp4dfDpoCYnNTmpyUlNTmpyUpOTmpzU5KQmJzU5qckpTU5pckqTU5qc0uSUJqc0OaXJKU1OaXKOJudoco4m52hyjibnaHKOJudoco4m52hyribnanKuJudqcq4m52pyribnanKuJudqcp4m52lynibnaXKeJudpcp4m52lynibnaXJak9OanNbktCanNTmtyWlNTmtyWpPTmJz765cOLh3cOhg6mDpYOnh08Org00FNztLkLE3O0uQsTc7S5CxNztLkLE3O0uQsTc7W5GxNztbkbE3O1uRsTc7W5GxNztbkqCFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIjYacv9CQ/xj8bXJ2/vq3uX3X38fi/jm2bSxsLG2sbOzY2LWxZ2NNY78X4388ZilZlpJlKVmWkmUpWZaSZSlZlpJlKdmWkm0p2ZaSbSnZlpJtKdmWkm0p2ZaSbSkJS0lYSsJSEpaSsJSEpSQsJWEpCUtJWErSUpKWkrSUpKUkLSVpKUlLSVpK0lKSlpKylJSlpCwlZSkpS0lZSspSUpaSspSUpeRYSo6l5FhKjqXkWEqOpeRYSo6l5FhKjqXkWkqupeRaSq6l5FpKrqXkWkqupeRaSq6l5FlKnqXkWUqepeRZSp6l5FlKnqXkWUqepaQtJW0paUtJW0raUtKWkraUtKWkLSVNKVm/ftnYsrFtY2FjaWNlY8fGro09G7OUmL0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwe02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbLX+kX2+sfYsrFtY2FjaWNlY8fGro09G7OULEvJspQsS8mylCxLybKULEvJspQsS8mylGxLybaUbEvJtpRsS8m2lGxLybaUbEvJtpSEpSQsJWEpCUtJWErCUhKWkrCUhKUkLCVpKUlLSVpK0lKSlpK0lKSlJC0laSlJS0lZSspSUpaSspSUpaQsJWUpKUtJWUrKUnIsJcdSciwlx1JyLCXHUnIsJcdSciwlx1JyLSXXUnItJddSci0l11JyLSXXUnItJddS8iwlz1LyLCXPUvIsJc9S8iwlz1LyLCXPUtKWkraUtKWkLSVtKWlLSVtK2lLSlhKz12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMdY8xprHWPMYax5jzWOseQ7+BtiaGmseY81jrHmMNY+x5jHWPMaax1jzGGseY81jrHmMNY+x5jHWPMaax1jzGGseY81jrHmMNY+x5jHWPMaax1jzGGseY81jrHmMNY+x5jHWvMaa11jzGmteY81rrHmNNa+x5jXWvMaa11jzGmteY81rrHmNNa+x5jXWvMaa11jzGmteY81rrHmNNa+x5jXWvMaa11jzGmteY81rrHmNNa+x5jXWvMaa11jzGmteY81rrHmNNa+x5jXWvMaa11jzGmteY81rrHmNNa+x5jXWvMaa11jzGmteY81rrHmNNa+x5jXWvMaa11jzGmteq5Req5Req5Res9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavTfZ6fpG9/jG2bGzbWNhY2ljZ2LGxa2PPxiwly1KyLCXLUrIsJctSsiwly1KyLCXLUrIsJdtSsi0l21KyLSXbUrItJdtSsi0l21KyLSVhKQlLSVhKwlLye3uNzn8bi67fjpWNHRu7NvZs7LcpyfzbWJ73u7Hf2+s/Hls2tm0sbCxtrGzs2Ni1sWdjlpKylJSlpCwlZSkpS0lZSspSUpaSspSUpeT8o5S8+1+N/fv/Xxd//v3ijz8PWD99wP7pA+KnD8ifPqB++oDz0wfcnz7g/fQB/cMH3J/e5PvTm3x/epPvT2/y/elNvj+9yfenN/n+9Cbfn97k+9Ob/H56k99Pb/L76U1+P73J76c3+f30Jr+f3uT305v8fnqT309vcv/0JvdPb3L/9Cb3T29y//Qm909vcv/0JvdPb3L/9Cb3D2/y+vXrpw9YP33A/ukD4qcPyJ8+oH76gPPTB9yfPuD99AE/vcnrpzd5/fQmr5/e5PXTm7x+epPXT2/y+ulNXj+9yeunN3n99Cbvn97k/dObvH96k/dPb/L+6U3eP73J+6c3ef/0Ju+f3uT905scP73J8dObHD+9yfHTmxw/vcnx05scP73J8dObHD+9yfHTm5w/vcn505ucP73J+dObnD+9yfnTm5w/vcn505ucP73J+dObXD+9yfXTm1w/vcn105tcP73J9dObXD+9yfXTm1w/vcn105v80x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v9dMdr/XTHa/10x2v/dMdr/3THa/90x2v/dMdr/0rf/qA+ukDzk8fcH/6gPfTB/z0Jv90x2v/dMdr/3THa/90x2v/dMdr/3THa/90x2v/dMdr/3THa/90x2v/dMdr/3THa/++41W/+t+GKvZ/dcDfxsLG0sbKxo6NXRt7NtY09vtO0j8eWzZmKQlLSVhKwlISlpKwlISlJCwlaSlJS0laStJSkpaStJSkpSQtJWkpSUtJWUrKUlKWkrKUlKWkLCVlKSlLSVlKylJyLCXHUnIsJcdSciwlx1JyLCXHUnIsJcdSci0l11JyLSXXUnItJddSci0l11JyLSXXUvIsJc9S8iwlz1LyLCXPUvIsJc9S8iwlz1LSlpK2lLSlpC0lbSlpS0lbStpS0paSppTEr182tmxs21jYWNpY2dixsWtjz8YsJctSsiwly1KyLCXLUrIsJctSsiwly1KyLCXbUrItJWavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZ6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZK/3F9nrH2PLxraNhY2ljZWNHRu7NvZszFKyLCXLUrIsJctSsiwly1KyLCXLUrIsJctSsi0l21KyLSXbUrItJdtSsi0l21KyLSXbUhKWkrCUhKUkLCVhKQlLSVhKwlISlpKwlKSlJC0laSlJS0laStJSkpaStJSkpSQtJWUpKUtJWUrKUlKWkrKUlKWkLCVlKSlLybGUHEvJsZQcS8mxlBxLybGUHEvJsZQcS8m1lFxLybWUXEvJtZRcS8m1lFxLybWUXEvJs5Q8S8mzlDxLybOUPEvJs5Q8S8mzlDxLSVtK2lLSlpK2lLSlpC0lbSlpS0lbSsxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1et9nrNnvdZq/b7HWbvW6z1232us1ew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXsPsNcxew+w1zF7D7DXMXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7T7DXNXtPsNc1e0+w1zV7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2en7Pmn94yL+N/YEOvx1bNvbb/0lunH8b++O7xr8dKxs7NnZt7NlYy9j9PTT+47H4B2Pn92O//X17629jL+9vx8rGjo1dG3s29vvft3f/HHu/G/s9/f3jsWVj28bCxtLGysaOjV0bezZmKdmWkm0p2ZaSbSnZlpJtKdmWkm0p2ZaSbSkJS0lYSsJSEpaSsJSEpSQsJWEpCUtJWErSUpKWkrSUpKUkLSVpKUlLSVpK0lKSlpKylJSlpCwlZSkpS0lZSspSUpaSspSUpeRYSo6l5FhKjqXkWEqOpeRYSo6l5FhKjqXkWkqupeRaSq6l5FpKrqXkWkqupeRaSq6l5FlKnqXkWUqepeRZSp6l5FlKnqXkWUqepaQtJW0paUtJW0raUtKWkraUtKWkLSVNKXm/ftnYsrFtY2FjaWNlY8fGro09G7OUmL0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbLX94vs9Y+xZWPbxsLG0sbKxo6NXRt7NmYpWZaSZSlZlpJlKVmWkmUpWZaSZSlZlpJlKdmWkm0p2ZaSbSnZlpJtKdmWkm0p2ZaSbSkJS0lYSsJSEpaSsJSEpSQsJWEpCUtJWErSUpKWkrSUpKUkLSVpKUlLSVpK0lKSlpKylJSlpCwlZSkpS0lZSspSUpaSspSUpeRYSo6l5FhKjqXkWEqOpeRYSo6l5FhKjqXkWkqupeRaSq6l5FpKrqXkWkqupeRaSq6l5FlKnqXkWUqepeRZSp6l5FlKnqXkWUqepaQtJW0paUtJW0raUtKWkraUtKWkLSVmr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/b6zF6f2esze31mr8/s9Zm9PrPXZ/baZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr032+ge9/rKxZWPbxsLG0sbKxo6NXRt7NmYpWZaSZSlZlpJlKVmWkmUpWZaSZSn5C3u95x+MNY39BaL+w7FtY2FjaWNlY8fGro3Zb/e23+6/QNR/OGYpCUtJWErCUhKWkrCUhKUkLCVhKUlLSVpK0lKSlpK0lKSlJC0laSlJS0laSspSUpaSspSUpaQsJWUpKUtJWUrKUlKWkmMpOZaSYyk5lpJjKTmWkmMpOZaSYyk5lpJrKbmWkmspuZaSaym5lpJrKbmWkmspuZaSZyl5lpJnKXmWkmcpeZaSZyl5lpJnKXmWkraUtKWkLSVtKWlLSVtK2lLSlpK2lDSlZP36ZWPLxraNhY2ljZWNHRu7NvZszFKyLCXLUrIsJctSsiwly1KyLCXLUmKIugxR17aUmL0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWavy+x1mb0us9dl9rrMXpfZ6zJ7XWav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYav2fNs+vfxs4fv/R3Y8/GWsby96z5j8eWjW0bCxtLGysbOzZ2bezZmKVkWUqWpWT9o9+3/P3Y73/fbvxt7NVvx46NXRt7NtY09nto/Mdjy8a2jYWNpY1ZSralZFtKtqVkW0rCUhKWkrCUhKUkLCW/h8Zz9r+N3fXrt2PHxp6NNY39Xgz/8diysW1j9GflNMNLM7w0w0szvDTDSzO8NMNLM7w0w0szvDTDSzO8NMNLM7w0w0szvDTDSzO8NMNLM7w0w0szvDTDSzO8NMNLM7w0w0szvDTDSzO8NMNLM7w0w0szvDTDSzO8NMNLM7w0w0szvDTDSzO8NMNLM7w0w0szvDTDSzO8tP5kWn8yrT+Z1p9M60+m9SfL+pNl/cmy/mRZf7J+pY2VjR0buzb2bMxSYv3Jsv5kWX+yrD9Z1p8s60+W9SfL+pNl/cmy/mRZf7KsP1nWnyzrT5b1J8v6k2X9ybL+ZFl/sqw/WdafLOtPlvUny/qTZf3Jsv5kWX+yrD9Z1p8s60+W9SfL+pNl/cmy/mRZf7LMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXsvstcxey+y1zF7L7LXMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb0+s9dn9vrMXp/Z6zN7fWavz+z1mb2+39trZLx/m4u858/Bs/+c2zgXOJc4Vzh3cO7i3MO5trnfI+w/MYd5CcxLYF4C8xKYl8C8BOYlMC+BeUnMS2JeEvOSmJfEvCTmJTEviXlJzEtiXgrzUpiXwrwU5qUwL4V5KcxLYV4K81KYl4N5OZiXg3k5mJeDeTmYl4N5OZiXg3k5mJeLebmYl4t5uZiXi3m5mJeLebmYl4t5uZiXh3l5mJeHeXmYl4d5eZiXh3l5mJeHeXmYl8a8NOalMS+NeWnMS2NeGvPSmJfGvLTlpX/9wrmFcxvnAucS5wrnDs5dnHs4h3lZmJeFeVmYl4V5WZiXhXlZmJeFeVmYl4V52ZgX9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t893165cB738eXDq4dTB0MHWwdPDo4NXBp4OanKXJWZqcpclZmpylyVmanKXJWZqcpclZmpytydmanK3J2ZqcrcnZmpytydmanK3J2Zqc0OSEJic0OaHJCU1OaHJCkxOanNDkhCYnNTmpyUlNTmpyUpOTmpzU5KQmJzU5qckpTU5pckqTU5qc0uSUJqc0OaXJKU1OaXKOJudoco4m52hyjibnaHKOJudoco4m52hyribnanKuJudqcq4m52pyribnanKuJudqcp4m52lynibnaXKeJudpcp4m52lynibnaXJak9OanNbktCanNTmtyWlNTmtyWpOjhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIRw35qCEfNeSjhnzUkI8a8lFDPmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhnzVkK8a8lVDvmrIVw35qiFfNeSrhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrITw35qSE/NeSnhvzUkJ8a8lNDfmrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxoyOsXGvIfg0sHtw6GDqYOlg4eHbw6+HRQk7M0OUuTszQ5S5OzNDlLk7M0OUuTszQ5S5OzNTlbk7M1OVuTszU5W5OzNTlbk7M1OVuTE5qc0OSEJic0OaHJCU1OaHJCkxOanNDkpCYnNTmpyUlNTmpyUpOTmpzU5KQmJzU5pckpTU5pckqTU5qc0uSUJqc0OaXJKU3O0eQcTc7R5BxNztHkHE3O0eQcTc7R5BxNztXkXE3O1eRcTc7V5FxNztXkXE3O1eRcTc7T5DxNztPkPE3O0+Q8Tc7T5DxNztPkPE1Oa3Jak9OanNbktCanNTmtyWlNTmty1JCXGvJSQ15qyEsN+Y9/ftDB0sGjg1cHnw5qctSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvJVJtzLpVibdyqT790x6q9e/Dd4T78/BP5bi75OPJ1snfy+l/9Tk4snNk8GTyZPFk4cnOUPFGSrO0OEMHc7Q4QwdztDhDB3O0OEMHc7Q4QwdztDlDF3O0OUMXc7Q5QxdztDlDF3O0OUMXc7Q4ww9ztDjDD3O0OMMPc7Q4ww9ztDjDD3OUHOGmjPUnKHmDDVnqDlDzRlqzlBzhlozFL9+8eTiyc2TwZPJk8WThycvTz6e5AwtztDiDC3O0OIMLc7Q4gwtztDiDC3O0OIMbc7Q5gxtztDmDG3O0OYMbc7Q5gxtztDmDAVnKDhDwRkKzlBwhoIzFJyh4AwFZyg4Q8kZSs5QcoaSM5ScoeQMJWeInTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062amTnTr/wqnf3v82+f74JtXvJ4MnkyeLJw9PXp58PNk6+RdO/c9MLp7kDC3O0OIMLc7Q4gwtztDiDC3O0OYMbc7Q5gxtztDmDG3O0OYMbc7Q5gxtzlBwhoIzFJyh4AwFZyg4Q8EZCs5QcIaCM5ScoeQMJWcoOUPJGUrOUHKGkjOUnKHkDBVnqDhDxRkqzlBxhoozVJyh4gwVZ6g4Q4czdDhDhzN0OEOHM3Q4Q4czdDhDhzN0OEOXM3Q5Q5czdDlDlzN0OUOXM3Q5Q5czdDlDjzP0OEOPM/Q4Q48z9DhDjzP0OEOPM/Q4Q80Zas5Qc4aaM9ScoeYMNWeoOUPNGWrNUP36xZOLJzdPBk8mTxZPHp68PPl4kjPETl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NTFTl3s1MVOXezUxU5d7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdipDzv1Yac+7NSHnfqwUx926sNOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSXnfqyU1926stOfdmpLzv1Zae+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO/dipHzv1Y6d+7NSPnfqxUz926sdO3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NTNTt3s1M1O3ezUzU7d7NStTr1/qVP/Mbl4cvNk8GTyZPHk4cnLk48nOUOLM7Q4Q4sztDhDizO0OEOLM7Q4Q4sztDhDmzO0OUObM7Q5Q5sztDlDmzO0OUObM7Q5Q8EZCs5QcIaCMxScoeAMBWcoOEPBGQrOUHKGkjOUnKHkDCVnKDlDyRlKzlByhpIzVJyh4gwVZ6g4Q8UZKs5QcYaKM1ScoeIMHc7Q4QwdztDhDB3O0OEMHc7Q4QwdztDhDF3O0OUMXc7Q5QxdztDlDF3O0OUMXc7Q5Qw9ztDjDD3O0OMMPc7Q4ww9ztDjDD3O0OMMNWeoOUPNGWrOUHOGmjPUnKHmDDVniJ16sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm516s1NvdurNTr3ZqTc79Wan3uzUm5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536sVM/durHTv3YqR879WOnfuzUj536sVM/durHTv3YqR879WOnfuzUj536sVM/durHTv3YqR879WOnfuzUj536sVM/durHTv3YqR879WOnfuzUj536sVM/durHTv3Yqd/vFfaPfwL6t8H49evPuai/j20bCxtLG/vt/yqv4m9zf/zl+/3/KocnL08+nmyd/L28vrrx5+TN308untw8GTyZPFk8eXjy8uTjydbJwxk6nKHDGTqcocMZOpyhwxk6nKHDGTqcocsZupyhyxm6nKHLGfq9vP6xQn9OnvUXk4cnL08+nmyd/L28/lOTiyc3TwZPJk9yhh5n6HGGHmfocYaaM9ScoeYMNWeoOUPNGWrOUHOGmjPUmqH+9RcZqr9P1l9MLp7cPBk8mTxZPHl48vLk48nWycUZWpyhxRlanKHFGVqcocUZWpyhxRlanKHNGdqcoc0Z2pyhzRnaf5Gh139O9q/fTx6evDz5eLJ1Mn7x5OLJzZPBk8mTnKHgDAVnKDhDwRlKzlByhpIzlJyh5AwlZyg5Q8kZSs5QcoaKM/QXTn3j198mb6zfT26eDJ5MniyePDx5efLxZOvkXzj1PzPJGTqcocMZOpyhwxk6nKHDGTqcocMZupyhyxm6nKHLGbqcocsZ+gv5vZV/Tp7ffg+7f6+wf/wB62/f/f7jL+P3k8GTyZPFk4cnL08+nmyd/L3C/lOTiyc5Q80Zas5Qc4aa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" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2dbW/bNhDHKVmJ7TiWE8dxnGemTTesr+w4BVpgLzygezF0GIYNe7EBw5Aubhesi4vMbVdg+7j7GsVCRRf9fZGFyOOlFGAChiWa4v3uxKcTacpTV2H78uPFx6XLz4K6Gej3Qfzd/X+hZzGvriSnVxBOvyCcJYuchq2lZMtpIGBX24wLBWBcLABjuQCMlQIwVgvAuFQAxloBGJcLwFgvAGNYAMZGARhXCsC4WgDGZgEY1wrA2CoA43oBGNsFYNywyOgBYxAfdy4/m5efLXXls7/0r+IrKgkDWwzHvV/NmJ2Ed9RkMGMTn06CJK5E3BBH/D7E0TOGUpDosGhdh+6xybdsO9/YVyCbVEBHe+y9xxWwk0V2KZtEZZbKIvmkZTgnW1XjY4vPVnoo24s/VZCp4ntExxuQltKRPahcE7sZP1LZrGZcF7DrQkizmKL/QNnVv8x4yozZ3IPl+NiMQTpBYhdiq98xWx1kh/HxhxllP3989Lw37D15dNo9OXrx6Mlp//gRylhQSTkkWQH8/jmk20vhsvks0OTbsJ9vZOs66OYBfyNF5/vx90qs66pK7pElpuMayFOgM4YBHK+C7Vfs8/SE9IzuaTPOa9YynBaMrdaYrerMViGkaYL91gTs54FcypvOSd6cec48jbkWfxSwmnPqm6jOm3b4g5fwutA3WZR9lLddDIFHoF3s10DGbXhWgKdhn6cnpGcX23/b7XST2SpktgohDfZzTQH7eSCX8qZzkjdnvhtmw1OHYxNqkK7uCCPFNYBHYgyW1e6uyMru1lTiB2Jf8zPIFWjP+jgWJ/+4wuwdYBo/SXsSx9Xhd+w708qRwBg3sxytAkOD2fcu+m/yo9L6bynZpCfl3UiRLd2HWcy3j23rwpT7G0CaUfy9om7XLtdVYhsci0qUVaExbh/XnZCN+Bg3gDRvmY1aU2yE9Yds0wIbCehyZPJdF7JRm9mI+NfBRpTmH2Yjiuc2WgMbkW3aYKO2fV0m6jm1MY0U2QI+QrQGANsYYlDMPhRCYVvk9RHQPgLlLOJp5+BZB54NIZ71HDwbwNMR4tnIwYNzGptCPJ0cPJvAsyXEs5mDhxhMHeB9faiSuoFjaiqfLYijMuJDHN2nEsSRrfAZfQc4B8qKHboh2AHLgETfkNfm0nVWSM9uWj+2yXTC8oFjRql+bJ3x0Hkb7kMe5mYBmVsOMGOZ0/Zkd4XGIX3T1lXBriGzL+q1bV/+Ud5x0DbwSPQbQnpGbcYO06nBdAohDfYLOwJ6eiCX8qbzHbgPeZjbDjALyT6ietJg8taZPYz8PQH5ecfDOM+9a5+nJ6RnVE/2mU5tplMIaXzQc19ATw/kUt50vg/3IQ/ztgPMeP+0PdnRGiRtX6fr+tcGZjVFr/sC8k39O1CTIav+3Qeee/Z5ekJ6RvXvkOl0wHQKIU0J9DwU0NMDuZQ3nR/CfcjDvO8AM94/bU923+T7wL5O1/WP7PqA2Rf1+jQ+tjkHa/L4JM7LPHekckeyAvj9oZek+xe4DuzbJfJ58V6bkNUuHACPVLsgoGfULmim032mUwhp0OfVAnp6arI9HsC5hvugczA3C8jccoC5wuIsye4KjTGvfV6y6x6zrwa9BMbOudcH7QJPyz5PT0jPVJ+3znS6a593l/HQeZbPm8WsHWCW9nnrTN4Bs4fQnEJUT7SaDB9zTkFIz6iedJhOmumEcwbo80rMLXlq8jn+QN2cQ8jLvOsAM94/bU/2sdD8xXX903F+G8y+wvM5Uf3DtseE287nSDx/l5zP4Wutd5lOuNYafV6ptdbT5hmy1odnMXccYBaaG+kLrTO6rn9k11VmX1z3XmVxxvf8Bda4z33P2cPc95z7ntOY575nrjD3PdXc97TJPPc9r8Lc97Sj59z3zBU+uu+JY1+Kw7Gv+X0pjsf9Ck7i33HNMY6BBOY2e1n1F+cJKfiO8Ww7xrPoGE/ZMZ6SYzzCayRy89Qc41l2jKfqGE/FMZ7AMZ5Dx3iWHONZcIzHc4Cnpm76FfhcrwlxPrvW9HdP/OR3Guf6cA35TSWII/8kgDga1y1AHI3nFlO4diGOniXuQBz5aVsQp+PjTYij5x+dFLl4fyT+s+Spm/+56TDGOnBI/4fqtjwLjvEsOcZz6BhP4BhPxTGeqmM8y47x1Bzj2XeMp+QYT9kxnkXHeLYd4/Ed42mm8Ag8U47mj3FfD+LCMIDjLWH7COmZOhfUZDrhvAr6TVLzKluMh86z5oKymPcKyKwdYMYyp+3J7grNa17PH5Ndd5l9US8tZNNp+zJpkC0wJ3Gcd04O9+AQmMvvCemZur+AZjrh/95xXkDqf+8bjIfOs/6rrzOY9wvIfFhA5h0HmHFfWA1x5GdR3bzrfWF5+4X77uExfdOzw2WI81OuxX1eTKB1DEXd388+T+/Y8PD96CqMB/ejC/2EC68lLpyLJF34PphCa19T940jjrR941qgi9C6qr6QrhPrfOkdio0UXSnNpp/YZRueVeM+SvT7w5TfKWT187gOUao/xrUNA5CDsjeB1ZLsGz4jrjXBPaTo+DM/ScvXpJCtid3UEWqjkZ1f12TX4Z5S7RT9B+pu+hecs9iDckblSLItbU+xUQVsRGmwLZXYS9Dw8P1KkcMEbP8XWRrco5bSHEEbhXsc43xUWt8lsUY0q+/Cvdd4f1ZL0ZHvByzxHh4cA1DIar9wXtT6+4a6V+/EpLb55XD8zZtXr85enA0vng3ff3tyduEBImEHDNtTkyrw303wU+KETBwViUBNmjNIMaf1V091r1x7gdcsRUOiCugwAP4y2J3SfMmGRBRPXHQvKY86sw19S7xGy+Qr8DqkyEZLzEb8dUgBpPma2YjiuY3QBSDb4GNAAV2iLXprQjZaZjYi/hrYiNJ8z2xE8dxGVbAR2QaXTAno0hdyAyMb8S3b+atLcMv2n5iNwik2wjzINvhaADr2IQ5fY0VxuE0/xVH3tgRx1NWluaQotwRcFEftZQPiiGEF4qj9IFmmHPDuzGrDzufzVCzQj38LYlADVlZJBV1SyXMF8rcbsTIG3oxdTD9oxgzGPzHjMxxbTnsfYw0YKNyLv2n88cP57+ejd+f6fDQe6vH710P91VNMfx5/05j1i4uLk/f67Px0+JcevRnr0Qv9fPTm/PRPvOjNLBf9PctFdX+Gi9ZmuagXX0QPpk7G4+Efr8d6PNInp6f63dn4Nz16O7x48Wr0Dq97OouwZ7Nc9N0sF/1424vUf9LGcJ6egwAA", "debug_symbols": "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" }, { "name": "initialize", "is_unconstrained": false, "custom_attributes": ["aztec(private)", "aztec(initializer)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "headstart", "type": { "kind": "integer", "sign": "unsigned", "width": 64 }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "headstart": [{ "start": 33, "end": 34 }], "inputs": [{ "start": 0, "end": 33 }], "owner": [{ "start": 34, "end": 35 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282] }, "bytecode": "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", "debug_symbols": "5ZrdThsxEIXfZa9R5Pn38CpVL9KWSkgIEKSVKsS7dxNirxMM7u5WdNNcoSgz5vPZ8eyxnafu5u7renN9d/vYXT51AN3lp6fu8X59u/34uFk/bLrLcNFd3X7r/z5fdN+vb666S5T4fPEqDsT3kRAhx0arhCLEFIvIOgwcoBJtRLCPNnI5iP580QGeJDV9FDUhJWqKNJOa51ALaNyHCoY4cGNtiiFgmmPAYZIgVIlmxzyyDbEcd9RyktR6ktQ2q645JmoQGKgBuDbHXKtiw8gQaAcSPxAkDCBwAFIZ2ZjTyFYsXsTa6nVKC93VC61rFCYJ2ZyLlbtTwz9QjZgmqEEaaiCg5e4koaFG1KSzixZqaFWNNDuPZZXK+K6H4X8QzwbxtCUegEtiJqeW1A35YKHyBRnk05Z84JqQESAc9L3xkuA/kQTsuEviTBsy9DIFbYD0Cqai6qXHRnRLQZ4FrpgNlBofoGwHn2UYwPKyBBNuzBPBINdV1OP3KepyUGw5KPNe7lbY5xAaKO/aHfSFgFBYCggsBQRnlqsOIHDcIajaNw2yAyNt/AMHya/joYVvX0NjWyHxglhkLgsETvvV/jUb3qf506fJng16sRdC8R2zniCznSBzPEFmbzBLbAwfLcU66MHwNUeaB8aAxR6Od4uLw1wYCJC7WhBp4ABotndUyl07Q4jZCsZYertYnafnkzTAwsAiVBVMD91LT1+NhUyB4VC/0a2M4SzV7jeHmbm09DhFQlywhBDyCVm/3fUDEbfsdCLs/TN9xc5LZkfMZwuosVG8LJwqjKU4AuurfjtROZeJ6qIn6rkaiakxUVAZDg1iaDRpjqn5Cw3QvjvUZDtTUQxSsBX3UF5zQc42OKZi1802oZ3HM9Vb8z7TlN/X+68eE7Kfa4FbqtoY7GjVy5Jd8FhRPBULlN62LgqZ59OO4kJPdqLMOnURodoRcf3MJeZb8H7nZEfvKcFlcICt6ldepKmyuGyH+ztDW9XveppZMCkLJ2XR6CzyVdUo5X0BFB7S5cW6r6AqRV7GFl/tT/scmJBTlUFguMkpDG7glEWTsnh8lr5VSpyWOnk8tib6ViU1kmBKEk5JorFJElb1ixGhJJ8YHjemPkmnJFW9nVLI74Xyol1TVtWhxEA5i2tZPjKr//Rz/XC9/nJztf3h1PbLH7df0++o+o+bX/cv3zz/Bg==" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "30": { "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self]);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self.lo as Field, self.hi as Field]);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n", "path": "std/hash.nr" }, "33": { "source": "// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n", "path": "std/merkle.nr" }, "35": { "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n", "path": "std/option.nr" }, "60": { "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr" }, "62": { "source": "use dep::protocol_types::{\n    constants::{MAX_NOTES_PER_PAGE, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    abis::side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateSet<T> {}\n\nimpl<Note> PrivateSet<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n    // docs:start:insert\n    pub fn insert<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            broadcast\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N>(self, note: &mut Note) where Note: NoteInterface<N> {\n        create_note_hash_from_public(self.context.public.unwrap(), self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n\n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(\n            false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(\n            false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // docs:start:remove\n    pub fn remove<N>(self, note: Note) where Note: NoteInterface<N> {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_consumption(note);\n        let has_been_read = context.note_hash_read_requests.any(|r: SideEffect| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>\n    ) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(self.context.private.unwrap(), storage_slot, options);\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N>(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr" }, "71": { "source": "use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::{PrivateContext, ContextInterface},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\nfn _nullifier_inclusion(nullifier: Field, header: Header) {\n    // 1) Get the membership witness of the nullifier\n    let witness = get_nullifier_membership_witness(header.global_variables.block_number as u32, nullifier);\n\n    // 2) Check that the witness we obtained matches the nullifier\n    assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n    // 3) Compute the nullifier tree leaf\n    let nullifier_leaf = witness.leaf_preimage.hash();\n\n    // 4) Prove that the nullifier is in the nullifier tree\n    assert(\n        header.state.partial.nullifier_tree.root\n        == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n    );\n    // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n    //     was included in the nullifier tree.\n}\n\npub fn prove_nullifier_inclusion<TContext>(\n    nullifier: Field,\n    context: TContext\n) where TContext: ContextInterface {\n    _nullifier_inclusion(nullifier, context.get_header());\n}\n\npub fn prove_nullifier_inclusion_at(\n    nullifier: Field,\n    block_number: u32, // The block at which we'll prove that the nullifier exists in the nullifier tree\n    context: PrivateContext\n) {\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n\npub fn prove_note_is_nullified<Note, N>(\n    note: Note,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n\n    _nullifier_inclusion(nullifier, context.historical_header);\n}\n\npub fn prove_note_is_nullified_at<Note, N>(\n    note: Note,\n    block_number: u32,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "85": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/log.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "90": { "source": "use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "95": { "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/rand.nr" }, "100": { "source": "use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr" }, "103": { "source": "use dep::protocol_types::{address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr" }, "104": { "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "106": { "source": "use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "114": { "source": "use dep::protocol_types::{\n    hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, ContextInterface},\n    oracle::get_contract_instance::get_contract_instance,\n    history::nullifier_inclusion::prove_nullifier_inclusion,\n};\n\npub fn mark_as_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(*context);\n    ContextInterface::push_new_nullifier(context, init_nullifier, 0);\n}\n\npub fn assert_is_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_contract_initialization_nullifier(*context);\n    prove_nullifier_inclusion(init_nullifier, *context);\n}\n\npub fn compute_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    let address = context.this_address();\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(context)\n    )\n}\n\npub fn compute_unsiloed_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    context.this_address().to_field()\n}\n\npub fn assert_initialization_matches_address_preimage<TContext>(context: TContext) where TContext: ContextInterface {\n    let address = context.this_address(); \n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert((instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\");\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash([init_selector.to_field(), init_args_hash], GENERATOR_INDEX__CONSTRUCTOR)\n}", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr" }, "118": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "122": { "source": "use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn extract_property_value_from_selector<N>(serialized_note: [Field; N], selector: PropertySelector) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = value_field == select.value.to_field();\n        let isLt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "145": { "source": "use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field(),\n            portal_contract_address.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr" }, "146": { "source": "use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::ToField\n};\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr" }, "147": { "source": "use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    let expected_public_keys_hash = 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8;\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/public_keys_hash.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address,\n                deployer\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n    let deployer = AztecAddress::from_field(7);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address,\n        deployer\n    );\n\n    let expected_computed_address_from_preimage = 0x027ea2b41ced2ec9a98305984e96dd28518536a4628883ccdc06e38aa8997220;\n    assert(address.to_field() == expected_computed_address_from_preimage);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "196": { "source": "global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr" }, "201": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "211": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "227": { "source": "use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    portal_contract_address : EthAddress,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt) &\n        self.portal_contract_address.eq(other.portal_contract_address)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.portal_contract_address.to_field(),\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            portal_contract_address: EthAddress::from_field(serialized[4]),\n            public_keys_hash: PublicKeysHash::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.portal_contract_address,\n                self.deployer\n            )\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr" }, "237": { "source": "use dep::aztec::note::{note_getter::view_notes, note_viewer_options::NoteViewerOptions};\nuse dep::aztec::state_vars::PrivateSet;\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: PrivateSet<ValueNote>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let options = NoteViewerOptions::new().set_offset(offset);\n    let opt_notes = set.view_notes(options);\n    // docs:end:view_notes\n    let len = opt_notes.len();\n    for i in 0..len {\n        if opt_notes[i].is_some() {\n            balance += opt_notes[i].unwrap_unchecked().value;\n        }\n    }\n    if (opt_notes[len - 1].is_some()) {\n        balance += get_balance_with_offset(set, offset + opt_notes.len() as u32);\n    }\n\n    balance\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/balance_utils.nr" }, "241": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.owner.to_field(), self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "258": { "source": "contract Counter {\n    // docs:start:imports\n    use dep::aztec::prelude::{AztecAddress, Map};\n    use dep::aztec::context::Context;\n    use dep::value_note::{balance_utils, value_note::{ValueNote, VALUE_NOTE_LEN}};\n    use dep::easy_private_state::EasyPrivateUint;\n    // docs:end:imports\n\n    // docs:start:storage_struct\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>,\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(private)]\n    #[aztec(initializer)]\n    // We can name our initializer anything we want as long as it's marked as aztec(initializer)\n    fn initialize(headstart: u64, owner: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner);\n    }\n    // docs:end:constructor\n\n    // docs:start:increment\n    #[aztec(private)]\n    fn increment(owner: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner);\n    }\n    // docs:end:increment\n\n    // docs:start:get_counter\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n    // docs:end:get_counter\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/counter_contract/src/main.nr" }, "259": { "source": "use dep::aztec::{\n    protocol_types::address::AztecAddress, context::Context,\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\nstruct EasyPrivateUint {\n    context: Context,\n    set: PrivateSet<ValueNote>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl EasyPrivateUint {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet { context, storage_slot };\n        EasyPrivateUint { context, set, storage_slot }\n    }\n\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note, true);\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress) {\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let maybe_notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..maybe_notes.len() {\n            if maybe_notes[i].is_some() {\n                let note = maybe_notes[i].unwrap_unchecked();\n\n                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while\n                // spending someone else's notes).\n                assert(note.owner.eq(owner));\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note, result_value != 0);\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr" } } }
