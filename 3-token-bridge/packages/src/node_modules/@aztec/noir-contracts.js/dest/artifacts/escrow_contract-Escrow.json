{ "noir_version": "0.25.0+d1ed549202e5a840845298c931418e173eb5437c", "name": "Escrow", "functions": [{ "name": "constructor", "is_unconstrained": false, "custom_attributes": ["aztec(private)", "aztec(initializer)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "address_note::aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "address_note::aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "public" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "owner": [{ "start": 33, "end": 34 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280] }, "bytecode": "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", "debug_symbols": "3VrbbhoxEP2XfUbIc7f5laoPNE2lSBGJElqpivLvNQR7DThY7FZk4QmtmPGeOTs+npndt+7x6W65fnhavXaLtw5ct/j21r0+L1eby9f18mXdLdysu1/9jL/vs+7Xw+N9t0Dj99mRHUjYWYKHbOutYorgky0ia7+wg4q1EcHO2ijInvX3WQdwlajxUqgJKaEmTyNR0xjUAup3poLO97ixFqJzmGJ02AcJQhVrDphXtt6W/RY1XyVquUrUOiqv2SfUINCjBqjGmHNVrF8ZHG2B2AWBuB4I7AGprGzMaWUrNi9ibfcGShs9aCi4rqEwSZAtcLFzt2z4C7LhU4DqpMEGAlpWJ3ENNrwmnoNowYZW2UjRBV9mqQxQvXAL5FlPnrbIAwiSMFOgFtWn6UM3Ufqc9PRpiz4ImiAjgNvTvfMpgS+hBOxQJXFkGdJrmYI2gEQGU1JF6rFh3WJwVCUCirmAUuM9KJvFedTilrclmHAjTgSDnFdeD89TlOlA0elAGXe4W1E+O9eAcrLcQT8VIGEiQMhNBQiMTFftgcChQlBVN9VlqSVu3CAW5fn0ccURiybbG1T1TbPeqpfWDcTyDUpxllDV5kwlbk/LU8YNaSa+XugyGrrmvEHVBvR4jqds51AczrFJ24DRKYGx8WD6hxofw2kwPi/sfVkp+OpOCnkuA1iUQ1ibcHhL45BQVohV21ju5i2qezv0/MzyN8JfbB7yqKAs+XDAOInCRUkBl2ciscEJe7RENOy+DE3k/QgNXBYNYu74UH0jZVg4PVeWYjDxoRWM1wudLgw95BwgpgZ00DzTiF1LS5DYJ6ET6kGH7TiI+WbCNEigrZjJxzAr0sW5AwFXdCBs50sXy80wqLl+MuXTDP7XIQjr7SRhxuGdHe41m3KYBtk6EDXCJAu53ypeKWwbFh7VCYtQbUhV7/pOFqocpoEDdF6fG5Omh8mlCO3eWui8Pi5tesEgLxzkRWd7Ec6rgpkrTygqoPDRAYd5/YW05NJWjrrm6AMDfKo0CPSz5KI8c5y8aJAXn+3F9Fkqcdq8FPyh7NBnmdRwgiFOOMSJznayeX0eKpToE8NDYYpOOsSprtvkstKXr/o0eVVl0DvKXlzzCmd6xas/y5eH5Y/H+82nG5s/f6/u0pcc8XL99/njn/d/" }, { "name": "withdraw", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "address_note::aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "address_note::aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "token", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "amount", "type": { "kind": "field" }, "visibility": "private" }, { "name": "recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "amount": [{ "start": 34, "end": 35 }], "inputs": [{ "start": 0, "end": 33 }], "recipient": [{ "start": 35, "end": 36 }], "token": [{ "start": 33, "end": 34 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637] }, "bytecode": "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", "debug_symbols": "7b3driu7cqX5LufaMJJk8M+v0ugLd3U1YKBgF8ruBhrGeffS9plSap2l3EyFQskIxrjyNo5yiuObXOQYnNLgf/7lf/zbf/vn//iXf/vXf//LP/3nX8L2l3/6P/7zL//+P//5X//4f//9P/75f/3HX/5p+4e//Pd//b9v//ev//CX/+df/sd//8s/xUp//YffXhdy/3llaOHx2lZfvDSGdn9tjFT2H7yFF6+uKYWfV9fU8y+v/j//4S8hmBx1vGrUKab7qFNLH446fTLqHEr7eWmOW9vHHV9J3LZ417jFXWTI6cWrqcfHT677a6n916jJ5KizyVGXT0ZdKd9nX9//gYXw8t/AFst90CHFwatTSPcfnWLuH/4zqJ+IbA/YLaeRyNtg7yJT3X+N9dWoqd4Hnf/4YftL/xhyszfkbm7IcbM35GBvyNHekJO9IZO9IWd7Qy72hmxv94tKd7+0e7Ty90NWuvv9yZCTzt2vbPXntSWHvx+yzt2vlvrwwfnPX5oj3X8habe14Q/7/PsYAtWHZS7ll1f/AUPnvjoJhs4dexIM8gXjsZWE8PSD7zB0uoxJMHT6l0kwdDqjb8GI211aiHH7DYZOzzUJhk43NwcG6fSJ39tayw4j/AbDvgNt9x9bno9hhzBC22Na2v6LhX0DKsdCp//s6T6E3mn0j+T+R6qcd2zp1Z8UQnlsq20fQPwbCAKIv4HQ6TsngNDpOSeA0Ok3J4DQ6TUngNDpM68HkXV6zAkgdPrLCSB0mssJIOAsf0AQQPwNBJzlDwg4yx8QcJY/IOAsf0DAWf4NRIGz/AEBZ/kDAs7yBwSc5Q8IAoi/gYCz/AEBZ/kDAs7yBwSc5Q8IOMu/gahwlj8g4Cx/QMBZ/oCAs/wBQQDxNxBwlj8g4Cx/QMBZ/oCAs/wBAWf5NxANzvIHBJzlDwg4yx8Q5p1lDfePkdbYnkH8oY6WVmfeA7Z4n5mtxsEk/tOPCzfzLlAOhXkfKIfCvBOUQ2HeC4qh6ObdoBwK835QDoV5R/hnVqGbt3lyv2gCijsKGMgHChjIBwoYyAcKGMgHChjIO4qwmXeQf+YVwgZXuP+qzdtCQRYwkTsLAosHC9jInQV85M4CRnJnYd5J/rllgDt8/KoDzhd3FrCSOwtYyZ0FrOTOgsDiwQJWcmdh3kr+qWVQeovEnF81zhl3FrCSDxZKL9SYwwJWcmcBK7mzgJXcWdDSlkHpBSdzftU4aNxZwEruLGAldxawkg8WSm+nmcMCVnJnsfTnHoPSe2zm/KoJLB4sYCV3FrCSOwtYyZ0FrOTOAlbywULpBTZSlkHplTRzftU4aNxZwEruLAgsHixgJXcWsJI7C1jJncXaH3+0f++M3K/a/tUzgixgJXcWsJI7C1jJnQWBxYMFrOTOYu2PP9q/YkbwV42Dxp0FrOSDhf27ZgRZwEruLGAldxawkjsLWtoy2L9NRvBXjYPGnQWs5M4CVnJnASv5YGH/chlBFrCSO4u1P/5o/+IYwV81gcWDBazkzgJWcmcBK7mzgJXcWcBKPljYv03mTy2D/TtiBH/VOGjcWcBK7iwILB4sYCV3FrCSOwtYyZ3F2h9/xOUy+68at8s8sYCV3FnASu4sYCV3FgQWDxawkjuLtT/+iEtmnn7VOGjcWcBK3llE+9fMCLKAldxZwEruLGAldxa0smWIuGbm6VeNg8adBazkzgJWcmcBK/lggTtpnljASu4slv74Y8Q1M0+/agKLBwtYyZ0FrOTOAlZyZwErubOAlXywsH8nzZ9aBlwz8/SrxkHjzgJWcmdBYPFgASu5s4CV3FnASu4slv74Y8Q1M/uvGtfMPLGAldxZwEruLGAldxYEFg8WsJI7i6U//hhxzczTrxoHjTsLWMkHC/vXzAiygJXcWcBK7ixgJXcWpJJFq+01i/8a80vL10t5PDIad+wl/bw4Pr9B7i9enOp255FqCrvMGP82nKJrOPXi4aT2GE7LvwznxSTI8T74kAv9PvimevCPWRlKSL8Pvl87+Pb4B5Xa37F88aNruv9bjbU8T5vX//7u4+hbHrx2X2DiVp4E5lf+PqX7ylVT339y3P72T/v1PSgmEe6DDlsogxcPuQRwecklquZS64NLp1+k/tfgk+XBk+XBF82Db50ePzrSaPUN/fHv6XZConVdr06By652bR2Kt+TxSAPDqUjtbrwy0YcQi2aLkRLdt9KUah/+C+3p4aZTXmKlKJqdjp5fj+i6UjS7qK8yn7cKafZ+byLPj1eH3NPg1aX0O5eYP4VI2A8/n4kZED+HqDpQzMvnRbXvn8hFtZOfyOXqI9R6H07qacSllfL4c0d5Gkj72/Fv3QyP/aXrDttWH7/b2H8Z/X899dI3hlC2fRWmgeYQ6nbXcfvvpxnUXs7N0O7+Id7+8vLLBHp/ur2+6eO7AlJ8/I5TS58KIBEBT38ivJ2c/TY5ssibpPSnb1JE3uSxp9/+2PnkRV/+KgKFeJ9MgRL138ZUFY6pKRxT1zem1xcOTB5TUDimqHBMSeGYSOGYssIxKVzHm8J1vClcx5vCdbwrXMe7wnW8K1zHu8J1vCtcx7vCdbwrXMe7wnW8K1zHu751PG361vG06VvH06ZvHU+bvnX89oYKx6RvHU+bvnU8bfrW8bTpW8fTpnAdDwrX8aBwHQ8K1/GgcB0PCtfxoHAdDwrX8aBwHQ8K1/GgcB2PCtfxqHAdjwrX8ahwHY8K1/GocB2PCtfxqHAdjwrX8ahwHU8K1/GkcB1PCtfxpHAdTwrX8aRwHU8K1/GkcB1PCtfxpHAdJ4XrOClcx0nhOk4K13FSuI6TwnWcFK7jpHAdJ4XrOClcx7PCdTwrXMezwnU8K1zHs8J1PM9Yx9P+04mo/TamGes45cfLKaffOc1Yx3N9fJifSoy/jakpHNOMdbzQPp9K+21MZcY6vld73f779393ZcY6Xss+x9v2+5hmrOM9Pb7nmbft99/dhHU8b0/NZttT0d59TBPW8Vz64+W51vzbmCas47mF/XfXw/bbmCas47m3sI+pxz9/eUztPpZ42wEeLw6N8Q2uVKorvbH94+u/ysTw+K5hDPXpS6fbdn+uMJ+rzOca87nOe+71Sf6J5wLzufj6ub06Kz5/4/723D+89eqfd0mXvAt9/i4l3F9cnjsvXr425LSvrPnpJ/dyH1FWN6KibkRV3YiauhF1bSOiTd2IgroRRXUjSupGpG7NJnVrNqlbs0ndmk3q1mxSt2ZndWt2VrdmZ3Vrdla3Zmd1a3ZWt2ZndWt2VrdmZ3Vrdla3Zhd1a3ZRt2aXi//15+3+h7Ec9j9BxXA/2ypF2XguntX5UfKUnyrJ9vHUTdl4grLxRGXjScrGQ8rGk5WN56vrz8971AveQ8Af1HDvvKwvz4xr//57tO2C9wgXvEe84D3SBe9BF7yHwJpQ8/3f+fOf3HlrQivKxlOvHU/Yi54D9frCRbambkRd24j6pm5EQd2IoroRpYtHlB+LY8jxVWLrpG5EWd2IiroRVXUjaupG1LWNKGxXL9rPBzZUXw4p6BtS1DekpG9IpG9IWd+Qir4h1YlDyq/XpaZvSF3dkMKmb0hB35AEVu/2+L5Lf7qZ4N3X3geUtA2ItA0oaxtQ0Tagqm1ATduAurIBxU3bgIK2AWlbqaO2lTpqW6mjtpU6alupo7aVOmpbqaO2lTppW6mTtpU6aVupk7aVOmlbqZO2lTppW6mTtpU6aVupk7aVmrSt1KRtpSZtKzVpW6lJ20pN2lZq0rZSk7aVmrSt1KRtpc7aVuqsbaXO2lbqrG2lztpW6qxtpc7aVuqsbaXO2lbqrG2lLtpW6qJtpS7aVuqibaUu2lbqom2lLtpW6qJtpS7aVuqibaWu2lbqqm2lrtpW6qptpa7aVuqqbaWu2lbqqm2lrtpW6qptpW7aVuqmbaVu2lbqpm2lbtpW6qZtpW7aVuqmbaVu2lbqpm2l7tpW6q5tpe7aVuqubaXu2lbqrm2l7tpW6q5tpe7aVuqubKWOm7KVOm7KVuq4KVup46ZspY6bspU6bspW6rgpW6njpmyljuHidWhU6RZD0Dagi/+VjQpm4tXfLxsPqGgbUNU2oKZtQF3ZgK7+ftl4QF9dh+5vEq94k3TFm9AFb3L1R8qHe8PVHykfDoi0beekbTu/+iPl4wFdHCsyxfuAcnw5INI2oKxtQEXbgKq2AV1ueNpjQOnlgLqyAeVN24CCtgFFbQNK2gZEykxz1hZNs7ZomrVF06wtmmZt0bRoi6YlaBtQ1DagpG1A2lbqom2lLtpW6qJtpS7aVuqibaWu2lbqqm2lrtpW6qptpa7aVuqqbaWu2lbqqm2lrtpW6qptpW7aVuqmbaVu2lbqpm2lbtpW6qZtpW7aVuqmbaVu2lbqpm2l7tpW6q5tpe7aVuqu7NrQ2JXdGxp71Tagpm1AXdeA0nb13aqDP3GmLWgbUNQ2oKRtQKRtQJdfsPrnf1FMW9E2oKptQE3bgLqyAYVN24CUXYOdQtQ2IGUXYadA2gak7CrsFIq2AVVtA2raBtSVDShu2gakbaWO2lbqqG2ljtpW6qhtpY7aVuqobaWO2lbqqG2lTtpW6qRtpU7aVuqkbaVO2lbqpG2lTtpW6qRtpU7aVuqkbaUmbSs1aVupSdtKTdpWalK1UlP+x9cHVjmX+3vk1vejtxDj48HEfZC4D2bug4X7YOU+2LgPduaDrwP/mQcD90HuzIncmRO5MydyZ07kzpzInTmRO3Mid+Yk7sxJ3JmTuDMncWdO4s6cxJ05iTtzEnfmJO7MSdyZQ9yZQ9yZQ9yZQ9yZQ9yZQ9yZQ9yZQ9yZQ9yZQ9yZk7kzJ3NnTubOnMydOZk7czJ35mTuzMncmZO5MydzZ07hzpzCnTmFO3MKd+YU7swp3JlTuDOncGdO4c6cwp05lTtzKnfmVO7MqdyZU7kzp3JnTuXOnMqdOZU7cyp35jTuzGncmdO4M6dxZ07jzpzGnTmNO3Mad+Y07sxp3JnTuTOnc2dO586czp05nTtzOnfmdO7M6dyZ07kzp3NnTtg29pOB/ST7MHBjnwZu7OPAjX0euLEPBDf2ieDGPhLc2HMosOdQYM8h/oEy/0SZf6TMP1PmHyrzT5X5x8rsc+XAPlgO7JPlwD5aDuyz5cA+XA7s0+XAPl4O7PPlwD5gDuwT5sA+Yg7sM+aQ+H/YYs8h9jFzYJ8zB/ZBc2CfNAf2UXNgnzUH9mFzYJ82B/ZxcyD+X0fZc4h94hzYR86BfeYc2IfOgX3qHNjHzoF97hzYB8+BffIc2EfPgX32HNiHz4F9+hzYx8+Bff4c2AfQgX0CHdhH0IF9Bh3Yh9Ch8D+nwZ5D7HPowD6IDuyT6MA+ig7ss+jAPowO7NPowD6ODuzz6FD5H/ZhzyH2kXRgn0kH9qF0YJ9KB/axdGCfSwf2wXRgn0wH9tF0aPxPjLHnEPt0OrCPpwP7fDqwD6gD+4Q6sI+oA/uMOrAPqQP7lDp0/scO+Z87ZH/wkH1OHdnn1JF9Th3Z59SRfU4d2efUkX1OHdnn1JF9Th0D/8Or7DnEPqeO7HPqyD6njuxz6sg+p47sc+rIPqeO/M8/8z8A/cEnoNlziP8ZaP6HoPmfguZ/DJr/OWj+B6HZ59SRfU4d2efUMfE/Rs+eQ+xz6sg+p47sc+rIPqeO7HPqyD6njuxz6sg+p47sc+pI/O9isOcQ+5w6ss+pI/ucOrLPqSP7nDqyz6kj+5w6ss+pI/ucOrLPqSP7nDqyz6kj+5w6ss+pI/ucOrLPqSP7nDqyz6kj+5w6ss+pY+F/K4w9h9jn1JF9Th3Z59SRfU4d2efUkX1OHdnn1JF9Th3Z59Sx8r9ayJ5D7HPqyD6njuxz6sg+p47sc+rIPqeO7HPqyD6njuxz6tj4309lzyH2OXVkn1PHM+fU5fWTkf1kYj9J7Ccz+8nCfrKyn2zsJzvzyXTmnPrgycB+MrKfTOwnif1kZj9Z2E9W9pON/SR7DgX2HArsORTYcyiw51Bgz6HAnkOBPYcCew4F9hwK7DkU2XMosudQZM+hyJ5DkT2HInsORfYciuw5FNlzKLLnUGLPocSeQ4k9hxJ7DiX2HErsOZTYcyix51Biz6HEnkPEnkPEnkPEnkPEnkPEnkPEnkPEnkPjc+q+5V+e/L3zq5b73RS17q9NeX+TdsWb9AveZHxQLvAm49O+v3+Tx5OV/WRjP9m5T9aN/WRgPxnZTyb2k8R+MrOfZM+hyp5DlT2HKnsONfYcauw51NhzqLHnUGPPocaeQ409hxp7DjX2HGrsOdTZc6iz51Bnz6HOnkOdPYc6ew69Pu27he/7kynTfp9V2Gh/srKfbOwnO/NJen3ad+rJwH4ysp9M7CeJ/WRmP1nYT1b2k439JHsOBfYcCuw5FNhzKLDnUGDPocCeQ4E9hwJ7DgX2HArsORTZcyiy51Bkz6HInkORPYciew5F9hyK7DkU2XMosudQYs+hxJ5DiT2HEnsOJfYcSuw5lNhzKLHnUGLPocSeQ8SeQ8SeQ8SeQ8SeQ8SeQ8SeQ8SeQ8SeQ8SeQ8SeQ5k9hzJ7DmX2HMrsOZTZcyiz51Bmz6HMnkOZPYcyew4V9hwq7DlU2HOosOdQYc+hwp5DhT2HCnsOFfYcKuw5VNlzqLLnUGXPocqeQ5U9hyp7DlX2HKrsOVTZc6iy51Bjz6HGnkONPYcaew419hxq7DnU2HOosedQY8+hxp5DnT2HOnsOdfYc6uw51NlzqLPnEPucmtjn1MQ+pyb2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWafU2f2OXVmn1Nn9jl1Zp9TZ/Y5dWGfUxf2OXVhn1MX9jl1YZ9TF/Y5dWGfUxf2OXVhn1MX9jl1YZ9TF/Y5dWGfUxf2OXVhn1MX9jl1YZ9TF/Y5dWGfUxf2OXVhn1MX9jl1YZ9TF/Y5dWGfUxf2OXVhn1MX9jl1YZ9TF/Y5dWGfUxf2OXVhn1MX9jl1YZ9TF/Y5dWGfUxf2OXVhn1MX9jl1YZ9TF/Y5dWGfUxf2OXVhn1MX9jl1YZ9TF/Y5dWGfUxf2OXVhn1MX9jl1YZ9Tl4Nz6tsJ4uPJml4/SewnM/vJwn6ysp9s7Cc798mDc+rnJ9v2+snAfjKyn3w9h2471f3J21L1+kliP5nZTxb2k5X9ZGM/2blPHpwZl0cvSiqtv34ysZ98yZZup+0/T9Lt+Pz1k5X9ZGM/2blPvj6/PfVkYD8Z2U8m9pPEfjKzn2TPocaeQ409hxp7DnX2HOrsOdTZc6iz51Bnz6HOnkOdPYc6ew519hzq3DlUt439ZGA/GdlPvt4F65bu+0oN5eWTByeFvbb7e25bf/1kZD+Z2E8S+8nMfrKwn6zsJxv7yc598uCksOc8fDKwn4zsJxP7SWI/+XrV3NL+ZKbXTxb2k5X9ZGM/2blPvj4pPPXk61Vz63c3TuHgt/L6pPDUk4n9JLGfzOwnD+ZQq48nw+vdIVX2k439ZOc+SRv7ycB+Mo6fbK+fTOwnif3k6zkU9zU+9vT6ycJ+srKfbOwnX8+hSHV/8tfV5Pey0hDovvbc/vPJA1F7vM/rc8UvvE+46H3iRe+TLnofuuh98kXvUy56n3rR+7SL3uei9aBctB6Ui9aDctF6UC5aD8pF60G5aD0oF60H5aL1oFy0HpSL1oN60XpQL1oP6kXrQb1oPagXrQf1ovWgXrQeNIF5nbf74WR+SisxhP1dwiXvIjAHcrofl+ZEr98lX/Iu5ZJ3qZe8S7vkXfoV79K3S97l7X8vjycj+8nXK3WK98FSKnmg7MzfKQ7+YiX/Pvnz9wmPP8qHp09nxJr3dymXvEu95F3aJe/SL3iXdvC3O+l3CZe8S/z8XWK4W4GY0ut3SZe8C13yLvmSdymXvEu95F3aJe8i8G8/0v3QOJby8l3Cdsm7hEveJV7yLumSd6FL3iVf8i4S//bb/d9LSvn1u9RL3uXtf/uPJzv3ybixnwzsJyP7ycR+kthPZvaThf1kZT/JnkORPYcSew4l9hxK7DmU2HMosedQYs+hxJ5DiT2HEnsOHXzSgPrj78s5pc8zZTv4XIL8+4SL3ide9D7povehi94nX/Q+5d33eTxZ2U829pOd+2Te2E9yP2nbcmQ/mdhPEvvJzH6ysJ+s7Ccb+0nup7Vb2dhPsudQYc+hwp5DhT2HCnsOFfYcKuw5VNhzqLDnUGXPocqeQ5U9hyp7DlX2HKrsOcT+9lpjf3utsb+91tjfXmvsb6819rfXGvvba4397bXG/vZaY397rbG/vdbY315r7G+vNfa31xr722uN/e21xv72WmN/e62xv73W2N9ea+xvrzX2t9ca+9trjf3ttc7+9lpnf3uts7+91rfEfpLYT2b2k4X9ZGU/2dhPsudQYM+hwJ5DgT2HAnsOBfYcCuw5FNhzKLDnUGDPocCeQ5E9hyJ7DkX2HIrsORTZcyiy51Bkz6HInkORPYciew4l9hxK7DmU2HMosedQYs+hxJ5DiT2HEnsOJfYcSuw5ROw5ROw5ROw5ROw5ROw5ROw5ROw5ROw5ROw5ROw5lNlziH1O3dnn1J19Tt3Z59SdfU7d2efUnX1O3dnn1J19Tt3Z59SdfU7d2efUnX1O3dnn1J19Tt3Z59SdfU7d2efUnX1O3dnn1J19Tt3Z59SdfU7d2efUnX1O3dnn1J19Tt3Z59SdfU7d2efUnX1O3dnn1J19Tt3Z59SdfU7d2efUnX1O3dnn1J19Tt3Z59SdfU7d2efUnX1O3dnn1J19Tt3Z59SdfU7d2efUnX1OHTb2QfXt0cB/NPIfTfxHif9o5j9a+I9W/qON/yh/NgX+bAr82RT4synwZ1Pgz6bAn02BP5sCfzYF/mwK/NkU+bMp8mdT5M+myJ9NkT+bIn82Rf5sivzZFPmzKfJnU+LPpsSfTYk/mxJ/NiX+bEr82ZT4synxZ1Piz6bEn03En03En03En03En03En03En03En03En03En03En02ZP5syfzZl/mzK/NmU+bMp82dT5s+mzJ9NmT+bMn82Ff5sKvzZVPizqfBnU+HPpsKfTYU/mwp/NhX+bCr82VT5s6nyZ1Plz6bKn02VP5sqfzZV/myq/NlU+bOp8mdT48+mxp9NjT+bGn82Nf5savzZ1PizqfFnU+PPpsafTZ0/mzp/NnX+bOr82dT5s6nzZ1Pnz6bOn02dP5v4Z+GBfxYe+GfhgX8WHvhn4bf/5j+a+Y8W/qOV/2jjP8qfTfyz8MA/Cw/8s/DAPwsP/LPwwD8LD/yz8MA/Cw/8s/DAPwsP/LPwwD8LD/yz8MA/Cw/8s/DAPwsP/APtwD/QDvwD7cA/0A78A+1wcLQs2yZ7e5t8zduUa96mXvM27Zq3kSh7pXvxYs7x9dvQds3bhGveJl7zNgKV3zm1x9ukg7eha94mX/M25Zq3qde8Tbvmba6ofL7Zw+2atwnXvE285m3SNW9D17xNvuZtyjVvU695m3bN21yzCpRrVoFyzSpQrlkFyjWrQLlmFSjXrALlmlWgXLMKlGtWgXLNKlCvWQXqNatAvWYVqNesAvWaVaBeswrUa1aBes0qUK9ZBeo1q0C7ZhVo16wC7ZpVoF2zCrRrVoF2zSrQrlkF2jWrwOs/lp95MHAfjNwHE/dB4j6YuQ8W7oOV+2DjPth5D8Zt4z4YuA9G7oOJ+yBxH8zcBwv3wcp9sHEf5M6c138Ev/37vi9tMcWXrfK3RwP/0ch/NPEfJf6jmf9o4T9a+Y82/qOd/Wjkz6bIn02RP5sifzZF/myK/NkU+bMp8mdT5M+myJ9NiT+bEn82Jf5sSvzZlPizKbFmU6V/fD0f8n3PuP31YH8qxftTjfXU6+TZt/v+FOrjqf4Y4MEntEZPhfefKv8YX/8ps7b7X9v70/2Dve2PFd5jlfdY4z3WWY+9/tPe+LHAe+zlP7ze7tP4j++lPj/3D2+89vEe6YL3oE/f4xZ2yv3Fvfb931MLr65KKfcrzOiP//3v/+39MaKsbkRF3YiquhG1b47o8S79ind5/edB8XcJl7xLvORd0iXvQpe8S77kXcol71IveZeP/+3fDloet3RuLQ1Woz/aFx4/+vkaOdr3tdL1jaluCscUFI4pXjum8nhxKb/ubi9eG8vjtfHlTliT6dGT6dFn06MvpkdfTY++mR59tzz6tpkefTA9etN7bTO91zbTe20zvdc203ttM73XNtN7bTO913bTe203vdd203ttN73XdtN7bTe913bTe203vdd2y3tt2hSv96mHn9emfjB6xev9idErXnMo0M9rKeTXo1e85pwYveI158ToFa85J0av2N+PRx8U+/sTo1e83g8/A5GC4vX+xOgV+/sToyfTo9e8145Hr3mvHY9e8147Hr3mvXY8es177XD0UfNeOx696b02mt5ro+m9Nprea6PpvTZevdcentGwRl9Nj77pHf0f15k8hlGevtWyf64uxW57/GkzPv5gfPzR+PiT8fGT8fFnzeMffi45JcV776nxq9l9HyNSs6M+RqRmj7yPiNTseo8Rfb6PhXDvHo4h18GI/mjJv//okJ6+g1LSPqaocExJ4ZhI4ZjytWOS/Rs1FdOjr6ZH30yPvlsefd5Mjz6YHn00PfpkevRkevSm99pseq/NpvfabHqvzab32mJ6ry2m99pieq8tpvfazxs/po7e9F5bTO+1xfReW0zvtcX0XltN77XV9F5bTe+11fReK9D8MnP0pvfaqni9H39TqCpe78ejb4rXnPE3JpriNefE6BWvOSdGr3jNOTF6xf7+xOgV+/sTo1e83o8/B9kUr/fj0XfF/v7E6BX7+xOj17zXjkevea8dj17zXjsevea9djx6zXvtePSa99rx6E3vtd3yXkub5b2WNst7LW2W91rart5rJb8pRBuZHn3WO/qw1cfnSbf+NP7986S0FePjr8bH34yPv9sef9iMjz8YH3/UPH7q+/jjL+P//dX1cQ9Z255e28quVfE+La5V8a4urlWzB/jlOyUH/wY1e4Az49fsAc6MX7MHODN+zR7gxPijZg9wZvyaPcCZ8Wv2AOPv5FHUvK+fGb/mvfrM+M3svwfjN7P/Hoxfzf77GJGaHfUxIjV75H1ESc2u9xiRwD7W7m8SI+XBiAZ3W/8xoqhuREndiEjdiPK1IxL9fCMJNKfMHH01PfpmevTd8ugFultmjj6YHn00PfpkevRkevSm91oyvdeS6b2WTO+1ZHqvzab32mx6r82m99pseq+V6KOZOHrTe202vddm03ttNr3XZtN7bTG91xbTe20xvdcW03utRB/NxNGb3muL6b22mN5ri+m9tpjea6vpvbaa3mur6b22mt5rJfpoJo7e9F5bTe+11fReW03vtdX0XttM77XN9F7bTO+1zfReK9HDNHH0pvfaZnqvbab32mZ6r22m99pueq/tpvfabnqv7ab3WokepomjN73XdtN7bTe913bTe223vNfmzfJemzfLe23eLO+1ebO81+bN8l6bN8t7bd4s77V5s7zX5s3yXps303ttML3XBtN7bTC91wbTe61EO9LE0Zvea4PpvTaY3muD6b02mN5ro+m9Nprea6PpvTaa3msl2o0mjt70XhtN77XR9F4bTe+10fRem0zvtcn0XptM77XJ9F57dReU8OhN77Wme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3Kpvujcqme6Oy6d6obLo3KpvujSqme6OK6d6oYro3qpjujSqb5b22mO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhiujeqmO6NKqZ7o4rp3qhqujeqmu6NqqZ7o6rp3qi6Wd5rq+neqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o2qpnujquneqGq6N6qa7o1qpnujmuneqGa6N6qZ7o1qm+W9tpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6oZro3qpnujWqme6Oa6d6obro3qpvujeqme6O66d6ovlnea7vp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6N6qZ7o7rp3qhuujeqm+6NCpvp4qjb8C3vtrfhW95ub8O3vN/e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V7QL0Ox0arrfnVtqDgLTjTyJ1ex0xMVqdjriYjU7nbfEnii8Ud22LC5Ws9MRFltUNyKLi9XsdMTFanZF4mKXcVDjppCykSexyzioM2KXcVBnxK7joE6IXcdBnRC7joMai1XdQywudh0HdULsOg7qhFgzDur1IVpR3S18SoAZp3MkQLV76fdhlL6NblEIpd5PbcPt5U+vzk9yVfsXebmqHYy8XNUeRlyu6i7gL8hV7WPk5ap2MvJyVXsZebnkS65qnyQv15erUt0M/AW5vlyV6nZgebmq+4G/INeXq1LdEfwFub5cleqe4C/I9eWqVHcFf0GuL1elui/4C3J9uSrVncFfkOvLVanuDf6CXF+uSnV38Bfk+nJVqvuDvyDXl6tS3SH8Bbm+XJXqHuEvyPXlqlR3CX9Bri9XpbpP+Atyfbkq1Z3CX5Dry1Wp7hX+glxfrkp1t/AX5PpyVar7hb8g15erUt0x/AW5vlxV8eWqVHdIf0GuL1dVfLmq6stVqW4J/4JcX65KdVP4F+SSL7m+XJXqvvAvyPXlqlR3hn9Bri9Xpbo3/Atyfbkq1d3hX5Dry1Wp7g//glxfrkp1h/gX5PpyVap7xL8g15erUt0l/gW5vlyV6u7xL8j15ap0d5XLy/XlqnT3lcvL9eWqdHeWy8t15aqq7t5yebmuXFXV3V0uL9eVq6ob+ZLrylVV3R3m8nJduaqqu8dcXq4vV6W7y1xeri9XpbvPXF6uL1elu/9cXq4vV+WrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9eqrW7366lavvrrVq69u9earW7356lZvvrrVm69u9baRL7mu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le6jGYv15KBWuttlLNaTg1rpnpSxWE8OaqU7R8ZiPTmole7vGIv15KBWugtjLNaTg1rpXomxWE8OaqU7GsZiPTmole47GIv15KBWujtgLNaTg1qph38s1pODWqnTfizWkYNqK/XDj8U6clBtpR73sVhHDqpt5EmsIwfVVupFH4t15KDaSv3lY7GeHJSnTvLmqZO8eeokb546yZunTvLmqZO8eeokb546yZunTvLmqZO8eeokb546yZunTvLmqZO8eeokb546yZunTvLmqZO8eeokb546yZunTvLmqZO8eeokb546yZunTvLmqZO8eeokb546yZunTvLmqZO8eeokb546yZunTvLmqZO8eeokb546yZunTvLmqZO8eeokb546yZunTvLmqZO8eeokb546ydtKzdX9Lra2wU8uqT1GEQavTT38vDb1eABxof17HsSFfME8iAv5jWkQV2oGnwdxIX80D+JCvmsexIX83DyIBIifQ1zoBG8eRCQWAYhILIPXUrz/XCI6gIjEIgARieVziCs18c+DiMQyghh2iAfniSvdHDAPIhKLAEQCxM8hIrEIQERiEYCIxDKEeP9rH4UjiEgsAhCRWD6HuNLNF/MgIrEIQERiEYCIxCIAkQDxc4hILAIQkVgEICKxCEBEYhGAiMTyOcSVbpqZBxGJRQAiEosARCQWAYgEiJ9DRGIRgIjEIgARiUUAIhKLAEQklo8h9pVudpoHEYlFACISiwBEJBYBiASIn0NEYhGAiMQiABGJRQAiEosARCSWzyGudJPaPIhILAIQkVgEICKxCEAkQPwcIhKLAETFPrF0ur+4brmNIMb7N+RbjAdiFfs5cbGa71+TF6vYH8mLVexj5MUq9htvin1jlR+3PHbNd7XNBaPYF8wFo/h0ci4YxSeOc8Gs4w6FwazjJGXBaL6z7ntg3gplJd9DWQsHENdxsxMhruOSJ0J06b6lIRIgfg7RpauXhugyAUhDdJkWpCG6TBbSEF2mEGGImu+ItAMRiUUAIhKLAEQkFgGIBIifQ0RiEYCIxCIAEYlFACISiwBEJJbPIWq+k9UORCQWAYhILAIQkVgEIBIgfg4RiUUAIhKLAEQkFgGISCwCEJFYPoeo+fZlOxAJEP/8teNLMrvm61rtQMTGMvrnPP7mneZLMs1A1HxJph2IOAoTgIijMAGIOAoTgEiA+LHZ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veuOh6961x0PX/WuOx6+6l13OPyietcdD9/2rlts77rF9q57eSe68PBt77rF9q5bbO+6xfauW2zvutX2rltt77rV9q5bbe+6lzeDCw/f9q5bbe+61fauW23vutX2rtts77rN9q7bbO+6zfaue3krsfDwbe+6zfau22zvus32rtts77oSPaIh3ocfchUc/olPU0m0fc4cPtkefrY9/GJ7+NX28Jvt4XfLwy8SvYszhx9sD9/0rls2xbvu+GOoZVO8654ZvuJd98zwFe+6Z4aveNcdfxCybIp33TPDV7zrnhh+ULzrnhm+4l33zPAV77pnhq951x2eNBSJLrKZw9e8654YvuZd98TwVe+64+Gr3nXHw1e96w6HH1XvuuPhq951x8NXveuOh29715XoQZo5fNu7brS960bbu260vetG27tusr3rJtu7brK96ybbu65EO9LM4dvedZPtXTfZ3nWT7V032d51yfauS7Z3XbK965LtXVeiHWnm8G3vumR71yXbuy7Z3nXJ9q6bbe+62fauK9DPsz1GFLeWBId/4tNUAv08U4dfbA+/2h5+sz38bnr4Av08U4cfbA8/2h5+sj1827tuUbzrnvgYalG8654ZvuJd98zwFe+6Z4aveNc98UHIqnjXPTN8xbvumeEr3nXPDF/xrntm+Ip33TPD17zrjk8aquZd98TwNe+6J4avedc9MXzVu+5w+E31rjsevupddzx81bvuePiqd93x8FXvuuPh2951m+1dt9nedZvtXbfZ3nW77V232951u+1dt9vedQXakaYO3/au223vut32rttt77rd9K5bN9O7bt1M77p1M73r1s30rls307tu3UzvunUzvevWzfSuWzfTu27dbO+6wfauG2zvusH2rhts7rq3/+//++f/9S///H/9j//+77cn/vgf/99//W//8S//9q8//+9//P//82//y1//Nw==" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2d227bRhCGlxRtSZZF2bIsy2e6dlo0VzoFSYBeqEB6UaQoiha9aIGiUGI7NZpagSsnDdA+bl8jqJfmmL/GFGGqO84S0AICyeVy55vhnoZLLR11Hbavfk60X7j6Lajbgc4Pom37/4WOwbzakpxOTjjdnHAWDHJqtoaSLaeegF1NMy7kgHExB4zFHDCWcsBYzgHjUg4YKzlgXM4BYzUHjH4OGGs5YFzJAeNqDhjrOWBcywFjIweM6zlgbOaAccMgowOMXrTfuvptXv221LXP/sq9ji+pOAxMMfQ7L/WYnYS31GTQYxOXDrw4rkDcEEf8LsTRM4aCF+uwaFyHdl/nWzSdb+QrkE1KoKM59s6TEtjJILuUTcIyS2WRfNIiHJOtytG+wWcrHZTtRL8yyFTRPaL9DUhL6cgeVK6JXY8fqWyWU67z2HU+pFlM0H+gzOpfZDxFxqzvwXK0r8cgLS+2C7FV75mtCrL9aP9DZtmPut3h6bDTGT4ePu2/7L988rjbfdFu9/qPUMaCisshyfLg/BeQbi+By+SzQJ1vzXy+oa2roJsD/LUEnQ+j7Uqk66qK75Ehpn4F5CnQGcMA9lfB9ivmeTpCeob3tB7llb0MTw/aVmvMVlVmKx/S1MF+awL2c0Au5U3HJG/OPGeexlyJfgpY9TH1TVTndTv8wYl5beibDMruZm0XfeARaBd7FZBxF54V4KmZ5+kI6dnG9t90O11ntvKZrXxIg/1cXcB+DsilvOmY5M2Z74dZ81RhX4cKpKtawkhxNeCRGIOltbsrsrLbFRX7gdjX/AJyBdqzHo7FyT8uMXt7mMaN0w6juCqcx74zqRwJjHFTy9EqMNSYfe+j/yY/Kqn/lpJNelLetQTZ0n2YwXx72LYuTLm/HqQZRdsVdbd2uapi2+BYVKKsCo1xe/jeCdmIj3E9SPOW2agxxUZYf8g2DbCRgC5dne+6kI2azEbEvw42ojT/MBtRPLfRGtiIbNMEGzXN6zJRz6mNqSXIFvARwncAsI0hBsXsQ8EXtkVWHwHtI1DOQp5mBp514NkQ4lnPwLMBPC0hno0MPDinsSnE08rAswk8W0I8mxl4iEHXAd7X+yquGzimpvLZgDgqIy7E0X0qQBzZCp/Rt4BzoIzYoe2DHbAMSPQNWW0uXWeF9Gwn9WObTCcsHzhmlOrH1hkPHTfhPmRhrueQuWEBM5a5wJzsttA4pKfbujLY1Wf2Rb22zcvvZh0HbQOPRL8hpGfYZuwwnWpMJx/SYL+wI6CnA3IpbzregfuQhblpAbOQ7C7VkxqTt87soeXvCcjPOh7Gee5d8zwdIT3DerLPdGoynXxI44Ke+wJ6OiCX8qbjfbgPWZi3LWDG+xeYkx2+gxSY1+mm/jWBWU3R61BAvq5/B2oypNW/Q+D5xDxPR0jPsP4dMZ0OmE4+pCmAnkcCejogl/Km4yO4D1mY9y1gxvsXmJPd0/k+MK/TTf0juz5g9kW9Pov2Tc7B6jw+jfLSzx2p3JEsD84/dOJ0/wLXgXm7hD4v3msd0tqFA+CRahcE9AzbhYDpdMh08iEN+ryBgJ6OmmyPB3AcwH0IMjDXc8jcsIC5xOIMyW4LjTFvfF6y6x6zbwB6CYydw7HEtP83o50p7AKPxHynkJ6JPm+D6XTfPu8u46HjNJ83jTmwgFna520weQfMHkJzCmE9CdRk+JhzCkJ6hvWkxXQKmE44Z4A+r8TckqMmn+MP1O05hKzMuxYw4/0LzMnuC81f3NS/IMpvg9lXeD4nrH/Y9uhw1/kciefvkvM5/F3rXaYTvmuNPq/Uu9bT5hnS3g9PY25ZwCw0N9ITes/opv6RXVeZffG99zKL077nr/CO+9z3nD3Mfc+57zmNee57Zgpz31PNfU+TzHPf8zrMfU8zes59z0zho/ueOPalOBz76vNLUTyuVzCMzuM7x8JzuJ20+ovzhBRcy3gWLeMpWsZzZBlPwTKesmU8Fct4li3jqVvGU7KMZ9syHs8yniXLeBYs43Es4Kmo234FPterQ5zLrtX971M3Pk/jXBeuIb+pAHHkn3gQR+O6BYij8dxiAtcuxNGzxB2IIz9tC+KCaH8T4uj5RytBLt4fif8sOer2f25ajLEKHNL/oborz4JlPEuW8XiW8WxbxlOyjKduGc+yZTwVy3jKlvEULOM5soynaBnPomU8rmU8+wk8As+Uw/ljXNeDuDAMYH9L2D5CeibOBdWZTjivgn6T1LzKFuOh47S5oDTmvRwyBxYwY5kLzMluC81r3swfk113mX1RL4H569R1mbAMCsxJ9NFfVMCAYQD7uAZHIGALIT0T1xfYYzrh/97xOZjU/943GA8dp/1XP415P4fMRzlk3rGAGdeF3YM48rOCaHvf68Ly9gvX3cN92tKzw2WIcxOuxXVedCirfK/vZ56n09c8fD26EuPB9eh8N+bCa4kL50ZJF74OptC7r4nrxhFH0rpxDdClBPEmmYR0nXjPl76hWEvQldJsurFdtuFZNa6jROcfJpynkNbP43uIUv0xvtswADkoexNYDcm+5TPiuya4hhTtf+7Gafk7KWRrYtd1hNpoZOfX1dl1uKZUM0H/gbqf/gXnLPagnFE5kmxLm1NsVAIbURrp9bST2nbiwPUN6f4vsjR0La5R24U2Ctc4xvko3p8JtWUdZKe86RjXXuPrbd5lPWCJ7/DgGIBCWvuF86LGvzfUvv4mJrXNr07G316+fn12enZy8fzk/XfDswsHEAnbY9iOmlSBn9fBTYgTMnFYJDw1aU4vwZzGPz3VvnbtBT6zFA6JSqDDAPiLYHdK8xUbElE8cdG9pDyqzDa0lfiMls5X4HNIoY2WmI3455A8SPMNsxHFcxuhC0C2wceAArqES/RWhGy0zGxE/BWwEaX5gdmI4rmNymAjsg2+MiWgS0/IDexjl0I24p8uwe7wZ2Yjf4qNMA+yDX4WgPZdiMPPWFEcLtNPcdSFLUEcdXVJLinKLQAXxVF7WYM4YliBOGo/SJYuB7w7M9qw8/k8FQl0o3NeBKrBiiquoEsqfq5A/nYtUkbD67GL7gf1mEH7J3p8hmPLad9jrAADhU+iLY0/fjz//Xz07jw4H41PgvH7NyfB188w/Xm0pTHrlxcXw/fB2fnxyV/B6HIcjE6DF6PL8+M/8aLLWS76e5aLqu4MF63NclEnuogeTA3H45M/3oyD8SgYHh8H787GvwWjtycXp69H7/C6Z7MIez7LRd/PctFPd71I/Qe8FCjYnoMAAA==", "debug_symbols": "7Z3dbtw2EIXfZa+Dgj9DDplXKXrhtilgIHCC2C1QBH73bpDV2kEUqJFp8hxx7vKjWX06XM3h0UrU59P7D3/cPNx+uLs/vf18cr+EfHr76+fT/cebuy//cP9w8+nh9FZCfnN6d/fn+U8aH9+c/rp9/+70Nqg8/vbmS5HuKIpurSiruxRlTStFfk9R2FMU9xTJjqK8KoTUuBT5b9V789223ku6bHz+Y75u7aVcduFffxfhpbuQFPzyhUn5aWsf/MrWGuOytcb6TFbnL0ARDUjQgBIaUEYDUjSgggZUwYDUoQF5NCC0Tq1onVrROrWidWpF69SK1qkVrVMrWqcuaJ26oHXqgtapC1qnLmiduqB16oLWqQtapy5onbqgdera+bRPrl42Tr48fbJfcAQLp/MXOsXlk1OUFZyChVOhcLxzYDwejCeA8UQwngbNxz3jka3mHMrSm0N9/O7isXcJjCf35fE5LNeli3v2yWnhUTCeAsZTsXi8A+PxYDwBjCf25Ql++R0qxLjGI2A8CYwng/EoGE8B46lYPKFzfw6yzDdCzms8HowngPFEMB4B40lgPBmMp3d/Lkv/iTGt8RQwnlftz1/3EV2HffgO+wgd9hE77EM67CN12EfusA/tsI/SYR8dznPpcJ5Lh/NcOpzn0uE8lw7nuXQ4z6XDeS4dznPpcJ5Lh/M8vfw8z+W6Dw1uYw6z+QOfTx6OKMARRTgigSNKcEQZjkjhiF7eV1XqlUjLBlHR5ZOrSxvbns1ryafu23y660jrLEf68qdKaI7UT3OkYZojjdMcqUxzpGmaI83THKlOc6TTzJHyNHMknWaOpNPMkXSaOZJOM0dq8Dwey5FOM0fSaeZIOs0cSTvPkWpe6L3z+cWXwbRS4xfHje+58QM3fuTGF278xI2fufGVG5/bdQu361Zu163crlu5XbfBg9XFLffvStGtm1mlLBsnkZfTCzV9oqbP1PRKTV+o6SsxfWjw+P5Iek9NH6jpmb02OGavDY7Za4Nj9trgmL02OGavDQ0WV6j+eqtnzbpBlPOSZTSkF9M3WIphJL2npg/U9JGaXqjpEzV9pqZXavpCTU/ttYHaawO11wZqrw3UXttgOZCR9A28ti6/KCQXt35R8Ockfdnah2f5ZP2GnaCql62D1pUHUUODxUbG8ldk/hhlWTstRq1bn/2E7VPcvHHLX7l9iFvf+mG3hIUGS5fYCL3uCHkbIfARCjZC4CMUbYTAR0hshMBHCHoubSN0HiHotGAjdB4htRECH6FiIwQ+QnZNAXyExK4poI+QXVNAHyG7poA+QnZNAX2ExEYIfITsmgL6CNk1BfQRsmsK6CNk1xTQR8iuKfyvEWr7eG1IdqFgiOyW/ofIbpF+iOyW04fILib7CNktUQ+R3WLyENkt+w6R3QLtENktpY6QPVtKHSK7pdQhsltKHSK7pdQhssu0sp93v2wdNy+3t112Jc8bUkeqPm9GHan6vBF1pOrzJtSRqs8bUAeqrvPm05GqzxtPR6o+bzodqfq84XSk6mKqD1DdsukI1S2bjlDdsukI1S2bjlDdsukA1cuRsmm6bu1TjRtbt13IsBwpbY7U8Uj5caSOR0qEI3UU07GJjkdKbSN1PFIOG6njkZLVSB2PlJVG6nik9DNQx2p5po2Olmfa6Gh5po2Olmfa6CimYxMdLc+00RF6/nieli1XZs+dfOtqK8tiGhV6rnlIzaODnpceVHPoOexBNYee7x5Uc+i58UE1F9O8u+bYL4s7pubYL7g7pubQv00cVHPLof01txzaXXNvObS/5pZD+2tuObS/5pZD+2supnl3zS2H9tfccmh/zS2H9td82hzaduGo6KcNl42FDNMmxtZCThsDWws5bbZrLeS0ga21kGJCthFy2mjVWshp81JrIacNQa2FtGTTSEhLNm2EjJZsGglpyaaRkJZsGgl5pGQzbnmYGMV0bKLjkXLNSB2PFGtG6nikVDNSxyOFmpE6HinTDNRRjhRpRup4pEQzUscjBZqROlqeaaOjmI5NdLQ800ZHyzNtdLQ800ZHyzNNdEzd/Trr07HGDR2rc5eNq7jrtjUu8MIMn5jhMzO8MsMXZvhKDN//7d0t4T0zfGCGZ3bY/m81bgnP7LCZ2WEzs8NmZofNzA6rzA6rzA6rzA6rzA7b/92MLeGZHVaZHVaZHVaZHVaZHbYwO2xhdtjC7LCF2WH7vxmrJTyzwxZmhy3MDluYHbYwO2xldtjK7LCV2WErs8P2f1dLS3hmh63MDluZHbYyO2wldlhxxA4rjthhxRE7rDhihxVH7LDiiB1WHLHDiiN2WHHEDiuO2WE9s8N6Zof1zA7rmR22//rULeGZHdYzO6xndljP7LCe2WEDs8MGZocNzA4bmB22/9qjLeGZHTYwO2xgdtjA7LCB2WEjs8NGZoeNzA4bmR22/yJ4LeGZHTYyO2xkdtjI7LCR2WGF2WGF2WGF2WGF2WH7L8vUEp7ZYYXZYYXZYYXZYYXZYROzwyZmh03MDsu8ppMwr+kkzGs6CfOaTsK8ppMwr+kkzGs6CfOaTsK8ppMwr+kkzGs6Sfc1naJel86Uohvwm0tWSvdlnVrzZ3J+Jecv5PyVm7/7Kk+t+T05fyDnj+T85P6r5P6r5P6r5P6r5P6r5P5byP23kPtvIfffQu6/r7se1GUf6dX3kdaf0tOwvB5CQ/1mH5cqv6vq5Z6TwjIu5yvNcWPMk6vLwfvy9Mn+euwFjKdi8TR4vqQtjwfjCZ154vWlLSmu8UQwHgHjSWA8GYxHwXh69+e4fHKKssZTsXiiA+PxYDwBjCeC8QgYTwLjyWA8CsYD1p8jWH8WsP4sYP1ZwPqzgPVnAevPAtafBaw/C1h/FrD+LGD9OYH15wTWnxNYf05g/TmB9ecE1p8TWH9OYP05gfXnBNafM1h/zmD9OYP15wzWnzNYf85g/TmD9ecf3JOYl/faJxeuVcuNyOkHNwJuFPk9RWFPUdxTJHuK0p6i1a9AKteBqmtFuqeo7CmqO4rWb03ZKvJ7isKeotVvRKrLvfnZ5ZUi2VOU9hTlPUW6p6jsKao7itZfp5PTtSivFfk9RWFPUdxTJHuK0p6ivKdo9RuR9eotZeXUWH8dxlZR/fmivP76h60iv6co7CmKP1d0/ss/N59ub35//+7+XPDl//6+++Ph9sPd5a8P/378+j+P/wE=" }], "events": [], "file_map": { "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "30": { "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self]);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self as Field]);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, [self.lo as Field, self.hi as Field]);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n", "path": "std/hash.nr" }, "33": { "source": "// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n", "path": "std/merkle.nr" }, "35": { "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n", "path": "std/option.nr" }, "59": { "source": "use dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, Context};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes}, note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateImmutable<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateImmutable<T> {}\n\nimpl<Note> PrivateImmutable<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor. \n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot)\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note  where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr" }, "71": { "source": "use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::{PrivateContext, ContextInterface},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\nfn _nullifier_inclusion(nullifier: Field, header: Header) {\n    // 1) Get the membership witness of the nullifier\n    let witness = get_nullifier_membership_witness(header.global_variables.block_number as u32, nullifier);\n\n    // 2) Check that the witness we obtained matches the nullifier\n    assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n    // 3) Compute the nullifier tree leaf\n    let nullifier_leaf = witness.leaf_preimage.hash();\n\n    // 4) Prove that the nullifier is in the nullifier tree\n    assert(\n        header.state.partial.nullifier_tree.root\n        == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n    );\n    // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n    //     was included in the nullifier tree.\n}\n\npub fn prove_nullifier_inclusion<TContext>(\n    nullifier: Field,\n    context: TContext\n) where TContext: ContextInterface {\n    _nullifier_inclusion(nullifier, context.get_header());\n}\n\npub fn prove_nullifier_inclusion_at(\n    nullifier: Field,\n    block_number: u32, // The block at which we'll prove that the nullifier exists in the nullifier tree\n    context: PrivateContext\n) {\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n\npub fn prove_note_is_nullified<Note, N>(\n    note: Note,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n\n    _nullifier_inclusion(nullifier, context.historical_header);\n}\n\npub fn prove_note_is_nullified_at<Note, N>(\n    note: Note,\n    block_number: u32,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "85": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/log.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "90": { "source": "use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "94": { "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n/// - Pack arguments will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr" }, "95": { "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/rand.nr" }, "98": { "source": "use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr" }, "100": { "source": "use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr" }, "103": { "source": "use dep::protocol_types::{address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr" }, "104": { "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "106": { "source": "use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr" }, "114": { "source": "use dep::protocol_types::{\n    hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, ContextInterface},\n    oracle::get_contract_instance::get_contract_instance,\n    history::nullifier_inclusion::prove_nullifier_inclusion,\n};\n\npub fn mark_as_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(*context);\n    ContextInterface::push_new_nullifier(context, init_nullifier, 0);\n}\n\npub fn assert_is_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_contract_initialization_nullifier(*context);\n    prove_nullifier_inclusion(init_nullifier, *context);\n}\n\npub fn compute_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    let address = context.this_address();\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(context)\n    )\n}\n\npub fn compute_unsiloed_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    context.this_address().to_field()\n}\n\npub fn assert_initialization_matches_address_preimage<TContext>(context: TContext) where TContext: ContextInterface {\n    let address = context.this_address(); \n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert((instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\");\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash([init_selector.to_field(), init_args_hash], GENERATOR_INDEX__CONSTRUCTOR)\n}", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr" }, "118": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "122": { "source": "use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn extract_property_value_from_selector<N>(serialized_note: [Field; N], selector: PropertySelector) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = value_field == select.value.to_field();\n        let isLt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "130": { "source": "use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{\n    GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, NUM_FIELDS_PER_SHA256, STATE_REFERENCE_LENGTH,\n    CONTENT_COMMITMENT_LENGTH\n},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr" }, "132": { "source": "struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "145": { "source": "use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field(),\n            portal_contract_address.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr" }, "146": { "source": "use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::ToField\n};\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr" }, "147": { "source": "use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    let expected_public_keys_hash = 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8;\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/public_keys_hash.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address,\n                deployer\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n    let deployer = AztecAddress::from_field(7);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address,\n        deployer\n    );\n\n    let expected_computed_address_from_preimage = 0x027ea2b41ced2ec9a98305984e96dd28518536a4628883ccdc06e38aa8997220;\n    assert(address.to_field() == expected_computed_address_from_preimage);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "150": { "source": "use crate::{address::EthAddress, constants::L2_TO_L1_MESSAGE_LENGTH, traits::{Deserialize, Empty, Serialize}};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "155": { "source": "use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial: PartialStateReference = dep::std::unsafe::zeroed();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr" }, "163": { "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_private == other.is_private\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr" }, "167": { "source": "use crate::{\n    abis::side_effect::{OrderedValue, ContractScopedOrderedValue},\n    traits::{Empty, Serialize, Deserialize}, address::AztecAddress\n};\nuse dep::std::cmp::Eq;\n\nglobal READ_REQUEST_SERIALIZED_LEN = 2;\nglobal READ_REQUEST_CONTEXT_SERIALIZED_LEN = 3;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl OrderedValue<Field> for ReadRequest {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> ReadRequestContext {\n        ReadRequestContext { value: self.value, counter: self.counter, contract_address }\n    }\n}\n\nstruct ReadRequestContext {\n    value: Field,\n    counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl OrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl ContractScopedOrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ReadRequestContext {\n    fn eq(self, read_request: ReadRequestContext) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n        & (self.contract_address.eq(read_request.contract_address))\n    }\n}\n\nimpl Empty for ReadRequestContext {\n    fn empty() -> Self {\n        ReadRequestContext {\n            value: 0,\n            counter: 0,\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn serialize(self) -> [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field, self.contract_address.to_field()]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn deserialize(values: [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            contract_address: AztecAddress::from_field(values[2]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr" }, "168": { "source": "use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, abis::side_effect::Ordered\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    portal_contract_address : EthAddress,\n\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        assert(self.msg_sender.to_field() == 0);\n        assert(self.storage_contract_address.to_field() == 0);\n        assert(self.portal_contract_address.to_field() == 0);\n        assert(self.function_selector.to_field() == 0);\n        assert(self.is_delegate_call == false);\n        assert(self.is_static_call == false);\n        assert(self.side_effect_counter == 0);\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, call_context: CallContext) -> bool {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        call_context.msg_sender.eq(self.msg_sender)\n            & call_context.storage_contract_address.eq(self.storage_contract_address)\n            & call_context.portal_contract_address.eq(self.portal_contract_address)\n            & call_context.function_selector.eq(self.function_selector)\n            & (call_context.is_delegate_call == self.is_delegate_call)\n            & (call_context.is_static_call == self.is_static_call)\n            & (call_context.side_effect_counter == self.side_effect_counter)\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender.to_field(),\n            self.storage_contract_address.to_field(),\n            self.portal_contract_address.to_field(),\n            self.function_selector.to_field(),\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.side_effect_counter as Field,\n        ]\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        CallContext {\n            msg_sender: AztecAddress::from_field(serialized[0]),\n            storage_contract_address: AztecAddress::from_field(serialized[1]),\n            portal_contract_address: EthAddress::from_field(serialized[2]),\n            function_selector: FunctionSelector::from_field(serialized[3]),\n            is_delegate_call: serialized[4] as bool,\n            is_static_call: serialized[5] as bool,\n            side_effect_counter: serialized[6] as u32,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let _hashed = context.hash();\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr" }, "181": { "source": "use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x134b57e317f1554b9c4f547e617338fcc8ff04c6d96a278f1752b26a462c5d25;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr" }, "186": { "source": "use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr" }, "189": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : Field,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n}\n// docs:end:global-variables\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        [\n            self.chain_id,\n            self.version,\n            self.block_number,\n            self.timestamp,\n            self.coinbase.to_field(),\n            self.fee_recipient.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        GlobalVariables {\n            chain_id: serialized[0],\n            version: serialized[1],\n            block_number: serialized[2],\n            timestamp: serialized[3],\n            coinbase: EthAddress::from_field(serialized[4]),\n            fee_recipient: AztecAddress::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient)\n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars: GlobalVariables = dep::std::unsafe::zeroed();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr" }, "192": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    constants::{NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH, NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, grumpkin_point::GrumpkinPoint,\n    grumpkin_private_key::GrumpkinPrivateKey\n};\n\nstruct NullifierKeyValidationRequest {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\nimpl Eq for NullifierKeyValidationRequest {\n    fn eq(self, request: NullifierKeyValidationRequest) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequest {\n    fn empty() -> Self {\n        NullifierKeyValidationRequest {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n        }\n    }\n}\n\nimpl NullifierKeyValidationRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> NullifierKeyValidationRequestContext {\n        NullifierKeyValidationRequestContext { public_key: self.public_key, secret_key: self.secret_key, contract_address }\n    }\n}\n\nstruct NullifierKeyValidationRequestContext {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n    contract_address: AztecAddress,\n}\n\nimpl Eq for NullifierKeyValidationRequestContext {\n    fn eq(self, request: NullifierKeyValidationRequestContext) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n            & (request.contract_address.eq(self.contract_address))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequestContext {\n    fn empty() -> Self {\n        NullifierKeyValidationRequestContext {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n            self.contract_address.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n            contract_address: AztecAddress::from_field(fields[4]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_key_validation_request.nr" }, "193": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, nullifier_key_validation_request::NullifierKeyValidationRequest,\n    read_request::ReadRequest, side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    min_revertible_side_effect_counter: u32,\n\n    note_hash_read_requests: [SideEffect; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_key_validation_requests: [NullifierKeyValidationRequest; MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack_hashes: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The following 2 values are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    chain_id: Field,\n    version: Field,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.return_values == other.return_values) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.nullifier_key_validation_requests == other.nullifier_key_validation_requests) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_stack_hashes == other.private_call_stack_hashes) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.encrypted_logs_hash == other.encrypted_logs_hash) &\n        (self.unencrypted_logs_hash == other.unencrypted_logs_hash) &\n        (self.encrypted_log_preimages_length == other.encrypted_log_preimages_length) &\n        (self.unencrypted_log_preimages_length == other.unencrypted_log_preimages_length) &\n        self.historical_header.eq(other.historical_header) &\n        self.chain_id.eq(other.chain_id) &\n        self.version.eq(other.version)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_key_validation_requests[i].serialize());\n        }\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL{\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL{\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        fields.extend_from_array(self.private_call_stack_hashes);\n        fields.extend_from_array(self.public_call_stack_hashes);\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        fields.extend_from_array(self.encrypted_logs_hash);\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            note_hash_read_requests: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_key_validation_requests: reader.read_struct_array(NullifierKeyValidationRequest::deserialize, [NullifierKeyValidationRequest::empty(); MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_stack_hashes: reader.read_array([0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            encrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            encrypted_log_preimages_length: reader.read(),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            chain_id: reader.read(),\n            version: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x2b5ba01a6b73b68b4f44196e2dea49afd4076333e2dee8eddc9186e080f18201;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr" }, "195": { "source": "use crate::{\n    address::AztecAddress, constants::{GENERATOR_INDEX__SIDE_EFFECT},\n    traits::{Empty, Hash, Serialize, Deserialize}\n};\nuse dep::std::cmp::Eq;\n\nglobal SIDE_EFFECT_SERIALIZED_LEN = 2;\n\ntrait Ordered {\n    fn counter(self) -> u32;\n}\n\ntrait OrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n}\n\ntrait ContractScopedOrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n    fn contract_address(self) -> AztecAddress;\n}\n\nstruct SideEffect {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffect {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffect {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffect {\n    fn eq(self, side_effect: SideEffect) -> bool {\n        (self.value == side_effect.value)\n        & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffect {\n    fn empty() -> Self {\n        SideEffect {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffect {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize() , GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn serialize(self) -> [Field; SIDE_EFFECT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn deserialize(values: [Field; SIDE_EFFECT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nstruct SideEffectLinkedToNoteHash{\n    value: Field,\n    note_hash: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffectLinkedToNoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffectLinkedToNoteHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffectLinkedToNoteHash {\n    fn eq(self, side_effect: SideEffectLinkedToNoteHash) -> bool {\n        (self.value == side_effect.value)\n            & (self.note_hash == side_effect.note_hash) \n            & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffectLinkedToNoteHash {\n    fn empty() -> Self {\n        SideEffectLinkedToNoteHash {\n            value: 0,\n            note_hash: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffectLinkedToNoteHash {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize(),\n        GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<3> for SideEffectLinkedToNoteHash {\n    fn serialize(self) -> [Field; 3] {\n        [self.value, self.note_hash, self.counter as Field]\n    }\n}\n\nimpl Deserialize<3> for SideEffectLinkedToNoteHash {\n    fn deserialize(values: [Field; 3]) -> Self {\n        Self {\n            value: values[0],\n            note_hash: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/side_effect.nr" }, "196": { "source": "global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr" }, "199": { "source": "use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u64 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr" }, "201": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "202": { "source": "use crate::{\n    constants::{NUM_FIELDS_PER_SHA256, CONTENT_COMMITMENT_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::{arr_copy_slice}\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: [Field; NUM_FIELDS_PER_SHA256],\n  in_hash: [Field; NUM_FIELDS_PER_SHA256],\n  out_hash: [Field; NUM_FIELDS_PER_SHA256],\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array([self.tx_tree_height]);\n    fields.extend_from_array(self.txs_effects_hash);\n    fields.extend_from_array(self.in_hash);\n    fields.extend_from_array(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n    let mut offset = 1;\n\n    let txs_effects_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let in_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let out_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: [0; NUM_FIELDS_PER_SHA256],\n      in_hash: [0; NUM_FIELDS_PER_SHA256],\n      out_hash: [0; NUM_FIELDS_PER_SHA256],\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr" }, "209": { "source": "use crate::traits::{Serialize, Deserialize};\nuse dep::std::cmp::Eq;\n\nglobal GRUMPKIN_POINT_SERIALIZED_LEN: Field = 2;\n\nstruct GrumpkinPoint {\n    x: Field,\n    y: Field,\n}\n\nimpl Serialize<GRUMPKIN_POINT_SERIALIZED_LEN> for GrumpkinPoint {\n    fn serialize(self) -> [Field; GRUMPKIN_POINT_SERIALIZED_LEN] {\n        [self.x, self.y]\n    }\n}\n\nimpl Deserialize<GRUMPKIN_POINT_SERIALIZED_LEN> for GrumpkinPoint {\n    fn deserialize(serialized: [Field; GRUMPKIN_POINT_SERIALIZED_LEN]) -> Self {\n        Self {\n            x: serialized[0],\n            y: serialized[1],\n        }\n    }\n}\n\nimpl Eq for GrumpkinPoint {\n    fn eq(self, point: GrumpkinPoint) -> bool {\n        (point.x == self.x) & (point.y == self.y)\n    }\n}\n\nimpl GrumpkinPoint {\n    pub fn new(x: Field, y: Field) -> Self {\n        Self { x, y }\n    }\n\n    pub fn zero() -> Self {\n        Self { x: 0, y: 0 }\n    }\n\n    pub fn is_zero(self) -> bool {\n        (self.x == 0) & (self.y == 0)\n    }\n\n    // TODO(David): Would be quite careful here as (0,0) is not a point\n    // on the curve. A boolean flag may be the better approach here,\n    // would also cost less constraints. It seems like we don't need to \n    // group arithmetic either. \n    fn assert_is_zero(self) {\n        assert(self.x == 0);\n        assert(self.y == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/grumpkin_point.nr" }, "210": { "source": "use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state: StateReference = dep::std::unsafe::zeroed();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr" }, "211": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "227": { "source": "use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    portal_contract_address : EthAddress,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt) &\n        self.portal_contract_address.eq(other.portal_contract_address)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.portal_contract_address.to_field(),\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            portal_contract_address: EthAddress::from_field(serialized[4]),\n            public_keys_hash: PublicKeysHash::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.portal_contract_address,\n                self.deployer\n            )\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr" }, "274": { "source": "// Sample escrow contract that stores a balance of a private token on behalf of an owner.\ncontract Escrow {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector, NoteHeader, PrivateContext, PrivateImmutable};\n\n    use dep::aztec::{context::{PublicContext, Context}, oracle::get_public_key::get_public_key};\n\n    use dep::address_note::address_note::AddressNote;\n\n    struct Storage {\n        owner: PrivateImmutable<AddressNote>,\n    }\n\n    // Creates a new instance\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn constructor(owner: pub AztecAddress) {\n        let mut note = AddressNote::new(owner, owner);\n        storage.owner.initialize(&mut note, true);\n    }\n\n    // Withdraws balance. Requires that msg.sender is the owner.\n    #[aztec(private)]\n    fn withdraw(token: AztecAddress, amount: Field, recipient: AztecAddress) {\n        let this = context.this_address();\n        let sender = context.msg_sender();\n\n        let note = storage.owner.get_note();\n        assert(note.address == sender);\n\n        let selector = FunctionSelector::from_signature(\"transfer((Field),(Field),Field,Field)\");\n        let _callStackItem = context.call_private_function(\n            token,\n            selector,\n            [this.to_field(), recipient.to_field(), amount, 0]\n        );\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/escrow_contract/src/main.nr" }, "275": { "source": "// docs:start:encrypted_import\nuse dep::aztec::log::emit_encrypted_log;\n// docs:end:encrypted_import\nuse dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::Empty},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    hash::pedersen_hash, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n\n// docs:start:address_note_def\n// Stores an address\n#[aztec(note)]\nstruct AddressNote {\n    address: AztecAddress,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteInterface<ADDRESS_NOTE_LEN>  for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        // docs:start:encrypted\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n        // docs:end:encrypted\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n", "path": "/usr/src/noir-projects/aztec-nr/address-note/src/address_note.nr" } } }
