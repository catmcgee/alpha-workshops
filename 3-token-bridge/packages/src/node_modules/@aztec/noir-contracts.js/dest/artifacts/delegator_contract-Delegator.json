{ "noir_version": "0.25.0+d1ed549202e5a840845298c931418e173eb5437c", "name": "Delegator", "functions": [{ "name": "enqueued_delegate_set_value", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "targetContract", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "targetSelector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "args", "type": { "kind": "array", "length": 1, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "args": [{ "start": 35, "end": 36 }], "inputs": [{ "start": 0, "end": 33 }], "targetContract": [{ "start": 33, "end": 34 }], "targetSelector": [{ "start": 34, "end": 35 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306] }, "bytecode": "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", "debug_symbols": "7ZzdTuMwEIXfJddo5Rn/zExfZcVFl2UlJFQQdFdaId59U7Zx0nawRakaGHxFo46dc7444chx/dTd3l0t1zd3q8du8dQBdIvvT93j/XK1OXxcLx/W3cJddNern/3f54vu183tdbfA5J8vDuogyrYSGHItk1KKwEMtYkhjxw6UavIettXkJe5UX150gJ9StT+Xao9+UO3Zv1N1eI/qCIm3pREdj7pRs+gcDh4djiYhal0HwdwzjbWBX1THT6k6fUrVpKkG52k4AQDWRjfBqIcAqKz+tPcln1//Se9QOYn+QKN+2hk9/TnQneQcPpTOASc5Rx4ZQChYuQs4pNw7Jwn7kvD8kqTvcigXiJWRlDBti1Maewav3/MhC3ETHaDqJhkePOwmtZxewPgGRgcTGhgdTGxgdDCpgdHBUAOjg+EGRgcjDYwKxrsGRgcDDYwOpiXfV8DYSr4AnHV72QGzMRu+kllbCbVi1lbqrJi1lSQrZm2lw4pZW4mvbDbYSnEVs7aSWcWsrbRVMTtHgsKQp54FmU9nFsnlVxE0eRXRv4xRqsUPxZImYELQYmgcKNJkYhrdC8NgiyFlhoxYYViM5yE2MDqY1MDoYKiB0cFwA6ODkQZGBRNdA6ODgQZGB4MNjA7GWEg+HZjQwOhgbCVfjiGDobgDZmPWVpqtmLWVUCtmbaXOillbSbJsNtlKhxWzthJfxaytFFcxayuZVcwGU2bFxcGsYDowaytBVczaSlAVs7YSVMWsrQRVMWsrQZXNkq0EVTFrK0FVzNpKUBWzthJUxWywZTZBNjv5Hepg1liCKps1lqDKZo0lqLJZYwmqbNZYgiqaZWMJqmzWWIIqmzWWoMpmjSWostnwlcyeP0Gh61UPkhy5/R/Bc5pBEuFEEsG+JJpDEuc9GxwfSjp/ZkBwkCdvwQXclyQfTpK4OSQllyWB279wAjNIwvzE6D8fbDshOIMkn5eD958p7UvyM0iK4+KI/vEo+5LCDJIIx+HN7oDSDE9vRMoXDnGymYxazjJMVgiOGwoBawvQJ6MUkHfX8R9WV3apkfTR0UjenUaiVNCkcXF+Yj+Z9BE+Ag01NK+h4Y+OZlyTBc7FHTaXm72ZvqkXl2S4s2QSLkW2bfiINuo/+5DVxcmeVDJoA3dMI3hrI4Rv+GZLm0ZyRCN9r4NaIzimEb6tUX/wZ/lws/xxe73ZfHHz3e/V1bAXY3+4/nv//5vnfw==" }, { "name": "public_delegate_set_value", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "targetContract", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "targetSelector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "args", "type": { "kind": "array", "length": 1, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "args": [{ "start": 39, "end": 40 }], "inputs": [{ "start": 0, "end": 37 }], "targetContract": [{ "start": 37, "end": 38 }], "targetSelector": [{ "start": 38, "end": 39 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241] }, "bytecode": "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", "debug_symbols": "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s77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs77Fs76Fsz5/4Kzv9Yjhjzj+SOCPJP5I4Y80/sjBHxn8Efz2Db99w2/f8Ns3/PYNv33Db9/w2zf89g2/fcNv3/Hbd/z2Hb99x2/f8dt3/PYdv33Hb9/x23f89gO//cBvP/DbD/z2A7/9wG8/8NsP/PYDv/3Abz/x20/89hO//cRvP/HbT/z2E7/9xG8/8dtP/PYLv/3Cb7/w2y/89gu//cJvv/DbL/z2C7/9wm+/8dtv/PYbv/3Gb7/x22/89hu//cZvv/Hbb/z2D377B7/9g9/+wW//4Ld/8Ns/+O0f/PYPfvsHv/3Bb3/w2x/89ge//cFvf/DbH/z2B7/9wW9/8Ntf/PYXv/3Fb3/x21/89he//cVvf/HbX/z28azP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8KzP8azP8azP8azP8azv9RNu/JHCH2n8kYM/Mvgj+O3jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWZ/jWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/gWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/iWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/hWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWV/jWd/Bs76DZ30Hz/oOnvWdj7M+i6e+PGUxv37wd3/z6ddPZPzLp1+/jPdPn/P+lqK8pSlvOZS3DOUty3jLx+noN3+LUd7ilLcE5S2U3TfK7htl942y+0bZfaPsvlN23ym775Tdd8ruO2X3nbL7Ttl9p+y+U3bfKbsflN0Pyu4HZfeDsvtB2f2g7H5Qdj8oux+U3Q/K7idl95Oy+0nZ/aTsflJ2Pym7n5TdT8ruJ2X3k7L7Rdn9oux+UXa/KLtflN0vyu4XZfeLsvtF2f2i7H5Tdr8pu9+U3W/K7jdl95uy+03Z/absflN2vym7fyi7fyi7fyi7fyi7fyi7fyi7fyi7fyi7fyi7fyi7P5TdH8ruD2X3h7L7Q9n9oez+UHZ/KLs/lN0fyu4vZfeXsvtL2f2l7P5Sdn8pu7+U3V/K7i9l95ex+/M8lLcY5S1OeUtQ3pKUtxTlLU15y6G8ZShv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pyblU5PyqUn51KR8alI+NSmfmpRPTcqXJuVLk/KlSfnSpHxpUr40KV+alC9Nypcm5UuT8q1J+dakfGtSvjUp35qUb03KtyblW5PyrUn51qT80aT80aT80aS8Zve1NLuvpdl9Lc3ua2l2X0uz+1qa3dfS7L6WZve1NLuvpdl9Lc3ua2l2X0uz+1qa3dfS7L6WZve1NLuvpdl9Lc3ua2l2X0uz+1qa3dfS7L6WZve1NLuvpdl9bc3ua2t2X1uz+9qa3dd+JCnfmt3X1uy+tmb3tTW7r63ZfW3N7mtrdl9bs/vamt3X1uy+tmb3tTW7r63ZfW3N7mtrdl9bs/vamt3X1uy+tmb3tTW7r63ZfW3N7mtrdl9bs/vamt3X1uy+tmb3tTW7r63ZfW3N7mtrdl9bs/vamt3X1uy+tmb3tTW7r63ZfW3N7mtrdl9bs/vamt3X1uy+tmb3tb9H99Uq3v8eJKt+PhprJcf6Ht3X3zKWaY7lmmOF5lipOVZpjtWaYx3NsTQpX5qUb03KtyblW5PyrUn51qR8a1K+NSnfmpRvTcq3JuWPJuWPJuWPJuWPJuWPJuWPJuWPJuWPJuWPJuWPJuVHk/KjSfnRpPxoUn40KT+alB9Nyo8m5UeT8qNJ+dWk/GpSfjUpv5qUX03KryblV5Pyq0n51aT8SlL+PJKUP48k5c8jSfnzSFL+PJKUP48k5c8jSfnzSFL+PJKUP48m5U2T8qZJedOkvGlS3jQpb9+F8ufnsc7UR2O15lhHc6zRHGslx/JHcyzTHMs1xwrNsVJzLE3KuyblXZPyrkl516R8aFI+NCkfmpQPTcqHJuVDk/KhSfnQpHxoUj40KZ+alE9Nyqcm5VOT8qlJ+dSkfGpSPjUpn5qUT03KlyblS5PypUn50qR8aVK+NClfmpQvTcqXJuVLk/KtSfnWpHxrUr41Kd+alG9Nyrcm5VuT8q1J+dak/NGk/NGk/NGk/NGk/NGk/NGk/NGk/NGk/NGk/NGk/GhSfjQpP5qUH03KjyblR5Pyo0n50aT8aFJ+NCm/mpRfTcqvJuVXk/KrSfnVpPxqUn41Kb+alF9Jys8jSfl5JCk/jyTl55Gk/DySlJ9HkvLzSFJ+HknKzyNJ+Xk0KW+alDdNypsm5U2T8qZJec3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6OZvd1NLuvo9l9Hc3u62h2X0ez+zqa3dfR7L6uZvd1Nbuvq9l9Xc3u6z6SlF/N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dTW7r6vZfV3N7utqdl9Xs/u6mt3X1ey+rmb3dSW7r/VIdl9fYylS/jWWIuVfYylS/jWWIuVfYylS/jWWIuVfYylS/jWWIuVfY2lSXrL7+hpLk/KS3dfXWJqUl+y+vsbSpLxk9/U1liblJbuvr7E0KS/ZfX2NpUl5ye7rayxNykt2X19jaVJesvv6GkuT8pLd19dYmpSX7L6+xtKkvGT39TWWJuUlu6+vsTQpL9l9fY2lSXnJ7utrLE3KS3ZfX2NpUl6y+/oaS5Pykt3X11ialJfsvr7G0qS8ZPf1NZYm5SW7r6+xNCkv2X19jaVJecnu62ssTcpLdl9fY2lSXrL7+hpLk/KS3dfXWJqUl+y+vsbSpLxk9/U1liblJbuvr7E0KS/ZfX2NpUl5ye7rayxNykt2X19jaVJesvv6GkuT8pLd19dYmpSX7L6+xtKkvGT39TWWJuUlu6+vsTQpL9l9fY2lSXnJ7utrLE3KS3ZfX2NpUl6y+/oaS5Pykt3X11ialJfsvr7G0qS8ZPf1NZYm5SW7r6+xJClvmt1X0+y+mmb31TS7r/ZIUt40u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvppm99U0u6+m2X01ze6raXZfTbP7aprdV9Psvrpm99U1u6+u2X11ze6rP5KUd83uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvrtl9dc3uq2t2X12z++qa3VfX7L66ZvfVNbuvodl9Dc3ua2h2X0Oz+xqPJOVDs/samt3X0Oy+hmb3NTS7r6HZfQ3N7mtodl9Ds/samt3X0Oy+hmb3NTS7r6HZfQ3N7mtodl9Ds/samt3X0Oy+hmb3NTS7r6HZfQ3N7mtodl9Ds/samt3X0Oy+hmb3NTS7r6HZfQ3N7mtodl9Ds/samt3X0Oy+hmb3NTS7r6HZfQ3N7mtodl9Ds/samt3X0Oy+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7upc3dW5uqtzdVfn6q7O1V3dq7u6V3d1r+7qArv69kjijxT+CB48Lhw8xvOpfzAy3yqtmR/8jxuPXT3dr54eV0/Pq6fX1dP76unn6ulz9fS9ebp9alfreftkPR+ebldP96unx9XT8+rpdfX0vnr6uXr6XD19b57uV3fVr+6qX91Vv7qrfnVX/XP/Xj1vfC97Pjq9r55+rp4+V0/fm6fHc/V0u3q6Xz09rp6eV0+/uqtxdVfj6q7G1V2Nq7uaV3c1r+5qXt3VvLqreXVX8+qu5tVdzau7mld3Na/ual3d1bq6q3V1V+vqrtbVXa2ru1pXd7Wu7mpd3dW6uqt9dVf76q721V3tq7vaV3e1r2apfTVL7atZ6rn6c49z9ece5+rPPc7Vn3t8TjT56ulXf+5xrv7c41zNUs/VLPVczVLnapY6V7PUuZqlztUs9XOiyVdPv/pzj7n6c4+5uqtzdVfn6q7u1V3dq7u6V7+P3KvfR25ePf3q7/n26u/59urv+fbq7/n25u/58nmunm5XT/erp8fV0/Pq6XX19L56+rl6+lw9/equ2tVdtau7ald31a7uql3dVbu6q3Z1V+3qrtrVXbWru+pXd9Wv7qpf3VW/uqt+dVevuj951f3Jq+5PXnV/8qr7k1fdn7zq/uTH/kzvW+FhTr0/ZU+9P1Z/32Mf/hOa+/57avv572fZfH/q/F1Pzd/z1Md+xVe/sI/Fia8/9vf9r59/3//6HzsM/8Vjr//0f//wr3/8w//8p3/88+uJ//gv/8+f/uEvf/znP335j3/5f//y1//m3/8/" }, { "name": "view_private_value", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "amount", "type": { "kind": "field" }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "amount": [{ "start": 0, "end": 1 }], "owner": [{ "start": 1, "end": 2 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [2] }, "bytecode": "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", "debug_symbols": "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lR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDylR2sfGUHK1/ZwcpXdrDqlR2semUHq17ZwapXdrDq65GbtV7ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2semUHq17ZwapXdrDqlR2sVnaw/jZh8oTLEyFPpDxR8kTLEyNPrDxx6oTJZ27ymZt85iafuclnbvKZm3zmJp+5yWdu8pm7fOYun7nLZ+7ymbt85i6fuctn7vKZu3zmLp95yGce8pmHfOYhn3nIZx7ymYd85iGfechnHvKZp3zmKZ95ymee8pmnfOYpn3nKZ57ymad85imfeclnXvKZl3zmJZ95yWde8pmXfOYln3nJZ17ymbd85i2fectn3vKZt3zmLZ95y2fe8pm3fOYtn/nIZz7ymY985iOf+chnPvKZj3zmI5/5yGc+8pmvfOYrn/nKZ77yma985iuf+cpnvvKZr3zmK5/5yWd+8pmffOYnn/nJZ37ymZ985ief+clnfuqZj+xwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssON7HAjO9zIDjeyw43scCM73MgON7LDjexwIzvcyA43ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw63scCs73MoOt7LDrexwKzvcyg63ssOt7HArO9zKDreyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LDnexwJzvcyQ53ssOd7HAnO9zJDneyw53scCc73MkOd7LD2ZcMcb+NmD7i+kjoI6mPlD7S+sjoI6uP6Kdv+umbfvqmn77pp2/66Zt++qafvumnb/rpm376rp++66fv+um7fvqun77rp+/66bt++q6fvuunH/rph376oZ9+6Kcf+umHfvqhn37opx/66Yd++qmffuqnn/rpp376qZ9+6qef+umnfvqpn37qp1/66Zd++qWffumnX/rpl376pZ9+6adf+umXfvqtn37rp9/66bd++q2ffuun3/rpt376rZ9+66c/+umPfvqjn/7opz/66Y9++qOf/uinP/rpj376q5/+6qe/+umvfvqrn/7qp7/66a9++quf/uqnf/rpn376p5/+6ad/+umffvqnn/7pp3/66evWZ7r1mW59pluf6db32+969ZHSR1ofGX1k9RH99HXrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpSt77UrS9160vd+lK3vtStL3XrS936Ure+1K0vdetL3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+kq3vtKtr3TrK936Sre+0q2vdOsr3fpKt77Sra906yvd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Wre+1q2vdetr3fpat77Wra9162vd+lq3vtatr3Xra936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpGt77RrW906xvd+ka3vtGtb3TrG936Rre+0a1vdOsb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+la3vtWtb3XrW936Vre+1a1vdetb3fpWt77VrW9161vd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO936Tre+063vdOs73fpOt77Tre906zvd+k63vtOt73TrO9n6/Eu2vt9GTB9xfST0kdRHSh9pfWT0kdVH9NM3/fRNP33TT9/00zf99E0/fdNP3/TTN/30TT9910/f9dN3/fRdP33XT9/103f99F0/fddP3/XTD/30Qz/90E8/9NMP/fRDP/3QTz/00w/99EM//dRPP/XTT/30Uz/91E8/9dNP/fRTP/3UTz/10y/99Es//dJPv/TTL/30Sz/90k+/9NMv/fRLP/3WT7/102/99Fs//dZPv/XTb/30Wz/91k+/9dMf/fRHP/3RT3/00x/99Ec//dFPf/TTH/30Rz/91U9/9dNf/fRXP/3VT3/101/99Fc//dVPf/XTP/30Tz/900//9NM//fRPP/3TT//00z/99HXrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOsz3fpMtz7Trc906zPd+ky3PtOtz3TrM936TLc+063PdOtz3fpctz7Xrc916/vtT7j1kdJHWh8ZfWT1Ef30detz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+ly3Ptetz3Xrc936XLc+163Pdetz3fpctz7Xrc9163Pd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vdOsL3fpCt77QrS906wvd+kK3vtCtL3TrC936Qre+0K0vvre+f/mRvn+b+pcfpvftYNDBpINFB5sODh1cOnhw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gxpyUEMOashBDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXl+ZciXvw/ul387WHSw6eDQwaWDBwd/Zcj/9uC/fRxu3w4WHWw6OHRw6eCxwf36ooNGB50OBh1MOlh0sOng0MGlg7Qco+UYLcdoOUbLMVqO0XKMlmO0HKPlGC3HaTlOy3FajtNynJbjtByn5Tgtx2k5TssJWk7QcoKWE7ScoOUELSdoOUHLCVpO0HKSlpO0nKTlJC0naTlJy0laTtJykpaTtJyi5RQtp2g5RcspWk7RcoqWU7ScouUULadpOU3LaVpO03KaltO0nKblNC2naTlNyxlaztByhpYztJyh5QwtZ2g5Q8sZWs7QcpaWs7ScpeUsLWdpOUvLWVrO0nKWlrO0nKPlHC3naDlHy6GGvNSQlxryUkNeashLDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNCQ8wsa8m+DRgedDgYdTDpYdLDp4NDBpYO0HKPlGC3HaDlGyzFajtFyjJZjtByj5Rgtx2k5TstxWo7TcpyW47Qcp+U4LcdpOU7LCVpO0HKClhO0nKDlBC0naDlBywlaTtBykpaTtJyk5SQtJ2k5SctJWk7ScpKWk7ScouUULadoOUXLKVpO0XKKllO0nKLlFC2naTlNy2laTtNympbTtJym5TQtp2k5TcsZWs7QcoaWM7ScoeUMLWdoOUPLGVrO0HKWlrO0nKXlLC1naTlLy1laztJylpaztJyj5Rwt52g5R8s5Ws7Rco6Wc7Sco+VQQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JCNGrJRQzZqyEYN2aghGzVko4Zs1JDte0OOjP3bYOT0H4Ptf8wZnHM4F3Au4VzBuYZzA+cWzh2bW9jLwl4W9rKwl4W9LOxlYS8Le1nYy8JeDvZysJeDvRzs5WAvB3s52MvBXg72cqwX//qCcwbnHM4FnEs4V3Cu4dzAuYVzsBeDvRjsxWAvBnsx2IvBXgz2YrAXg70Y7MVhLw57cdiLw14c9uKwF4e9OOzFYS8OewnYS8BeAvYSsJeAvQTsJWAvAXsJ2EvAXhL2krCXhL0k7CVhLwl7SdhLwl4S9pKwl4K9FOylYC8FeynYS8FeCvZSsJeCvRTspWEvDXtp2EvDXhr20rCXhr007KVhLw17gb7r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw59N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9N6HvJvTdhL6b0HcT+m5C303ouwl9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0HcL+m5B3y3ouwV9t6DvFvTdgr5b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19t6HvNvTdhr7b0Hcb+m5D323ouw19d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcH+u5A3x3ouwN9d6DvDvTdgb470HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg757zHfri/nub3MG5xzOBZxLOFdwruHcwLmFc7AXg70Y7MVgLwZ7MdiLwV4M9mKwF4O9GOzFYS8Oe3HYi8NeHPbisBeHvTjsxWEvDnsJ2EvAXgL2ErCXgL0E7CVgLwF7CdhLwF4S9pKwl4S9JOwlYS8Je0nYS8JeEvaSsJeCvRTspWAvBXsp2EvBXgr2UrCXgr0U7KVhLw17adhLw14a9tKwl4a9NOylYS8NexnYy8BeBvYysJeBvQzsZWAvA3sZ2MvAXhb2srCXhb0s7GVhLwt7WdjLwl4W9rKwl4O9HOzlYC8HeznYy8FeDvZysJeDvUDfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2DvmvQdw36rkHfNei7Bn3XoO8a9F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfdei7Dn3Xoe869F2HvuvQdx36rkPfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03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UUM2ashGDdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQnRqyU0N2ashODdmpITs1ZKeG7NSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmoIQc15KCGHNSQgxpyUEMOashBDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQkxpyUkNOashJDTmpISc15KSGnNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQmxpyU0NuashNDbmpITc15KaG3NSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmoIQ815KGGPNSQhxryUEMeashDDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWG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" }, { "name": "view_public_value", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [], "param_witnesses": {}, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [0] }, "bytecode": "H4sIAAAAAAAA/81UzU7DMAx20jZrmYbgyAHUC/dM4gHCK/AGRS2Iyyp1mwQvjyDD1j4y35YiLFV2v/zY/uzY0FEM60LBRDzrGrDA32H9HHnwaxcvKUmVxfdXsb2EfZaxa8AMxCnrn7ni9H59Sacc1cBdyOgrrUEAuwA+0n1LWLeA2eRs5PUe1ivljFP8iY01kdI55SzyVEEugW1/nhx4Ql8B/sXfCuJwfxAPtnKA/+qf+F7k9+1rOs6H3Dk1kEOA+MVfCXvuWF/RT80Fl7iw/6OsgJsG7m1mykXqYZL6iD98T/jGLOQq+3H25Jxz8V43Q/6YGwEPKAHsud/qBXMbZbsbp+51eBq63kBoZRImaqOkYQFDu1Awot+jsgRM2lNrARyzaTs3dEpp1v4tSBeNDMRuWd+wfpym7qN92/TDezvud+340j6P+02/pS876jhFnggAAA==", "debug_symbols": "zdjNaoNAFAXgd7lrKfdndGZ8ldLFNLUgiAnRFor47lWMdpEQqLTh7Bw81/kQPMIM1BwPqa+PbUflQPyUU/k8UHdK7bzu+nTuqZQQY0ZV+zZdRvVjRu91U1GphY3ZdVrEr2lxYUvfDJvXS9aJbVFhP75kE6fA4ngsTsDiRCyOMJhHwDwK5jEwjwPzgHWzgJWzgLWzgNWzgPWzgvWz/m8/L3voA/b4kx7Nw7ZH4Pvv9U54ATk0UP5oEIutYVb9eTTzRVTAiTycKMCJIprIGE4kcCKFExmc6ObXr8X64zF21z9QC3uG4o4hx3uGZM+Q/nJoWn2mc51em2o+UplvfrSH9YRlWvZfp+XO+A0=" }, { "name": "private_delegate_set_value", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "targetContract", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "targetSelector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "args", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "args": [{ "start": 35, "end": 37 }], "inputs": [{ "start": 0, "end": 33 }], "targetContract": [{ "start": 33, "end": 34 }], "targetSelector": [{ "start": 34, "end": 35 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471] }, "bytecode": "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", "debug_symbols": "7b3hjuxIdqT5LvVbGNBJJ92pV1nsj95ZLSBAaA1GvQsshH73SWluMPOqPOswyu06z3GzX1KheTPdvszgMWNG2Pn33/7lX//7X/72z//613/77R///beUfvvH/+Pff/u3//GXv/7Hf/7b3/7yP//22z8u//DbP/31//74v3//h9/+n3/+l3/67R/XY/v7P/zuurSfP65MNV3X1tK4dE31de265uPzCy+pcXXZtvTj6rKd+09X/5//8FtaQ556G3Xqbd1ep97q1nnq3HPqPR31x6X7utTPc68ticuyvjQu66fItLe+dD7X6yuXz2tz/c9T7yFPfYQ8dWmd+rgOU3K2frfXI+XXadZjPf/47NhXZR19euir8wSc/vPOsh7n8vX0H99hXQDfIR9/9B1S/3coS7q+Q11243c/p/WSnLd8/tcDrd4OtHk7UPZ2oN3bgQ5vByreDlS9Heh0dqBt8XYgb3fqzdudevN2p9683ak3b3fqzdudevN2p9683ak3b3fq7O1Onb3dqbO3O3X2dqfO3u7U2dudOnu7U2dvd+rs7U6dvd2pd2936t3bnXr3dqfevd2pd2936t3bnXr3dqfevd2pd2936t3bnfrwdqc+vN2pD2936sPbnfrwdqc+vN2pD2936sPbnfrwdqc+vN2pi7c7dfF2py7e7tTF2526eLtTF2936uLtTl283amLtzt18Xanrt7u1NXbnbp6u1NXb3fq6u1OXb3dqau3O3X1dqeu3u7U1dud+vR2pz693alPb3fq09ud+vR2pz693alPb3fq09ud+vR2pz693anT4u1WnZbx9+rtWK4T5Vx/d6LxN+u81+tE+/Z7RuPv1nu53gafj3X93YmyuxONv18f+fP36Ki/P9H4G3ZZPk9UGq+18Xfscnz+Ztfl9ycaf8s+t+sDMPuy/P6nNvyevS/r8nmimv/ridLwe/a+1nKdaDvL7040/J695+36CNi+p98zGn7P3s96Xb6f5/rHl69bff2M14+7/XXxf34+8ndXWx+kShuT2vO/NW9bH7+Z14k+5aZt/fGP6p/5R80Xfz5favb0+Vo4849/0359Wv8ovfuP1vTf1vbbHMv1EcOzfn5g7azXvzr+1L8qf+pf1T/1r84/86/a748z/1X6U/+qeYM5P++Ty1q//rN/eOPa17fYfv23yL3fIp37ZcPOchov7XzsPy7O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ltCztoSetcN7u7GnDz1rS+hZW0LP2hJ61pbQs7aGnrU19KytoWdtDT1rh3cGY08fetbW0LO2hp61NfSsraFnLaLnM62v06e9AE9vvzcK0cb54Olz6NPvoU9/hD59CX36Gvr0Z+DTH4hexAdPn0KfPvKsPRbHs9Z8N+mxOJ61N07veNbeOL3jWXvj9I5nrfmOxmNxPGtvnN7xrLVPnxzP2hundzxrb5ze8ay9cXrPs9Z6pnAgusIePL3nWWuf3vOstU/vetaap3c9a83Tu5611ulX17PWPL3rWWue3vWsNU8fetYieooePH3oWbuGnrVr6Fm7hp61a+hZu4WetVvoWbuFnrVb6FmL6C568PShZ+0WetZuoWftFnrWbqFnbQ49a3PoWZtDz9ocetYiuosePH3oWZtDz9ocetbm0LM2h561e+hZu4eetYD+nOU60LrUDXh6+71RgP6cJ09/hD59CX36Gvr0Z+TTA/pznjx9Cn36NfTpt9CnDz1rD8ez1n436eF41t44veNZe+P0jmftjdM7nrX2OxqL41l74/SOZ+2N0zuetTdO73jW3ji941l74/SeZ635TKF4nrX26T3PWvv0nmetfXrXs9Y6fXU9a83Tu5615uldz1rz9K5nrXl617PWPH3oWVtDz9oaetbW0LO2hp61Z+hZe4aetWfoWXuGnrWA7qInTx961p6hZ+0ZetaeoWftGXnWliXyrC1L5FlblsiztiyRZ21ZIs/askSetWWJPGvLEnnWliXyrC1L6FmbQs/aFHrWptCzNsWctR//9f/95X/+81/+r3/5p3/7+Bf/8T/+v3/973/753/964///Nv//z/+9//y9/8F" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "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", "debug_symbols": "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" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "35": { "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n", "path": "std/option.nr" }, "62": { "source": "use dep::protocol_types::{\n    constants::{MAX_NOTES_PER_PAGE, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    abis::side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateSet<T> {}\n\nimpl<Note> PrivateSet<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n    // docs:start:insert\n    pub fn insert<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            broadcast\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N>(self, note: &mut Note) where Note: NoteInterface<N> {\n        create_note_hash_from_public(self.context.public.unwrap(), self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n\n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(\n            false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(\n            false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // docs:start:remove\n    pub fn remove<N>(self, note: Note) where Note: NoteInterface<N> {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_consumption(note);\n        let has_been_read = context.note_hash_read_requests.any(|r: SideEffect| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>\n    ) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(self.context.private.unwrap(), storage_slot, options);\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N>(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr" }, "63": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T> Storage<T> for PublicMutable<T> {}\n\nimpl<T> PublicMutable<T> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable reads only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "94": { "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n/// - Pack arguments will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr" }, "98": { "source": "use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr" }, "99": { "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, \n    address::AztecAddress, \n    constants::ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr" }, "104": { "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "105": { "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, constants::RETURN_VALUES_LENGTH};\n\n#[oracle(callPublicFunction)]\nfn call_public_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; RETURN_VALUES_LENGTH] {}\n\nunconstrained pub fn call_public_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; RETURN_VALUES_LENGTH] {\n    call_public_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/public_call.nr" }, "107": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "122": { "source": "use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn extract_property_value_from_selector<N>(serialized_note: [Field; N], selector: PropertySelector) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(serialized_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = value_field == select.value.to_field();\n        let isLt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "130": { "source": "use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{\n    GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, NUM_FIELDS_PER_SHA256, STATE_REFERENCE_LENGTH,\n    CONTENT_COMMITMENT_LENGTH\n},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr" }, "132": { "source": "struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress,\n        deployer: AztecAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address,\n                deployer\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n    let deployer = AztecAddress::from_field(7);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address,\n        deployer\n    );\n\n    let expected_computed_address_from_preimage = 0x027ea2b41ced2ec9a98305984e96dd28518536a4628883ccdc06e38aa8997220;\n    assert(address.to_field() == expected_computed_address_from_preimage);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "150": { "source": "use crate::{address::EthAddress, constants::L2_TO_L1_MESSAGE_LENGTH, traits::{Deserialize, Empty, Serialize}};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "155": { "source": "use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial: PartialStateReference = dep::std::unsafe::zeroed();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr" }, "163": { "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_private == other.is_private\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr" }, "167": { "source": "use crate::{\n    abis::side_effect::{OrderedValue, ContractScopedOrderedValue},\n    traits::{Empty, Serialize, Deserialize}, address::AztecAddress\n};\nuse dep::std::cmp::Eq;\n\nglobal READ_REQUEST_SERIALIZED_LEN = 2;\nglobal READ_REQUEST_CONTEXT_SERIALIZED_LEN = 3;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl OrderedValue<Field> for ReadRequest {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> ReadRequestContext {\n        ReadRequestContext { value: self.value, counter: self.counter, contract_address }\n    }\n}\n\nstruct ReadRequestContext {\n    value: Field,\n    counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl OrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl ContractScopedOrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ReadRequestContext {\n    fn eq(self, read_request: ReadRequestContext) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n        & (self.contract_address.eq(read_request.contract_address))\n    }\n}\n\nimpl Empty for ReadRequestContext {\n    fn empty() -> Self {\n        ReadRequestContext {\n            value: 0,\n            counter: 0,\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn serialize(self) -> [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field, self.contract_address.to_field()]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn deserialize(values: [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            contract_address: AztecAddress::from_field(values[2]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr" }, "168": { "source": "use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, abis::side_effect::Ordered\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    portal_contract_address : EthAddress,\n\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        assert(self.msg_sender.to_field() == 0);\n        assert(self.storage_contract_address.to_field() == 0);\n        assert(self.portal_contract_address.to_field() == 0);\n        assert(self.function_selector.to_field() == 0);\n        assert(self.is_delegate_call == false);\n        assert(self.is_static_call == false);\n        assert(self.side_effect_counter == 0);\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, call_context: CallContext) -> bool {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        call_context.msg_sender.eq(self.msg_sender)\n            & call_context.storage_contract_address.eq(self.storage_contract_address)\n            & call_context.portal_contract_address.eq(self.portal_contract_address)\n            & call_context.function_selector.eq(self.function_selector)\n            & (call_context.is_delegate_call == self.is_delegate_call)\n            & (call_context.is_static_call == self.is_static_call)\n            & (call_context.side_effect_counter == self.side_effect_counter)\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender.to_field(),\n            self.storage_contract_address.to_field(),\n            self.portal_contract_address.to_field(),\n            self.function_selector.to_field(),\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.side_effect_counter as Field,\n        ]\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        CallContext {\n            msg_sender: AztecAddress::from_field(serialized[0]),\n            storage_contract_address: AztecAddress::from_field(serialized[1]),\n            portal_contract_address: EthAddress::from_field(serialized[2]),\n            function_selector: FunctionSelector::from_field(serialized[3]),\n            is_delegate_call: serialized[4] as bool,\n            is_static_call: serialized[5] as bool,\n            side_effect_counter: serialized[6] as u32,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let _hashed = context.hash();\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr" }, "181": { "source": "use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x134b57e317f1554b9c4f547e617338fcc8ff04c6d96a278f1752b26a462c5d25;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr" }, "184": { "source": "use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem, side_effect::SideEffect\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x02e15f4157b5e2cb0a7ec3dfec18c6812ef16e1da319b364e5a11e337dfca414;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x0f22ddeca80a2c6f455165f1d2d1950c5e1b772bdc312742d1de089b424f0f5f;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr" }, "186": { "source": "use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr" }, "189": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : Field,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n}\n// docs:end:global-variables\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        [\n            self.chain_id,\n            self.version,\n            self.block_number,\n            self.timestamp,\n            self.coinbase.to_field(),\n            self.fee_recipient.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        GlobalVariables {\n            chain_id: serialized[0],\n            version: serialized[1],\n            block_number: serialized[2],\n            timestamp: serialized[3],\n            coinbase: EthAddress::from_field(serialized[4]),\n            fee_recipient: AztecAddress::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient)\n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars: GlobalVariables = dep::std::unsafe::zeroed();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr" }, "192": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    constants::{NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH, NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, grumpkin_point::GrumpkinPoint,\n    grumpkin_private_key::GrumpkinPrivateKey\n};\n\nstruct NullifierKeyValidationRequest {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\nimpl Eq for NullifierKeyValidationRequest {\n    fn eq(self, request: NullifierKeyValidationRequest) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequest {\n    fn empty() -> Self {\n        NullifierKeyValidationRequest {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n        }\n    }\n}\n\nimpl NullifierKeyValidationRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> NullifierKeyValidationRequestContext {\n        NullifierKeyValidationRequestContext { public_key: self.public_key, secret_key: self.secret_key, contract_address }\n    }\n}\n\nstruct NullifierKeyValidationRequestContext {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n    contract_address: AztecAddress,\n}\n\nimpl Eq for NullifierKeyValidationRequestContext {\n    fn eq(self, request: NullifierKeyValidationRequestContext) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n            & (request.contract_address.eq(self.contract_address))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequestContext {\n    fn empty() -> Self {\n        NullifierKeyValidationRequestContext {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n            self.contract_address.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n            contract_address: AztecAddress::from_field(fields[4]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_key_validation_request.nr" }, "193": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, nullifier_key_validation_request::NullifierKeyValidationRequest,\n    read_request::ReadRequest, side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    min_revertible_side_effect_counter: u32,\n\n    note_hash_read_requests: [SideEffect; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_key_validation_requests: [NullifierKeyValidationRequest; MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack_hashes: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The following 2 values are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    chain_id: Field,\n    version: Field,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.return_values == other.return_values) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.nullifier_key_validation_requests == other.nullifier_key_validation_requests) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_stack_hashes == other.private_call_stack_hashes) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.encrypted_logs_hash == other.encrypted_logs_hash) &\n        (self.unencrypted_logs_hash == other.unencrypted_logs_hash) &\n        (self.encrypted_log_preimages_length == other.encrypted_log_preimages_length) &\n        (self.unencrypted_log_preimages_length == other.unencrypted_log_preimages_length) &\n        self.historical_header.eq(other.historical_header) &\n        self.chain_id.eq(other.chain_id) &\n        self.version.eq(other.version)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_key_validation_requests[i].serialize());\n        }\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL{\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL{\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        fields.extend_from_array(self.private_call_stack_hashes);\n        fields.extend_from_array(self.public_call_stack_hashes);\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        fields.extend_from_array(self.encrypted_logs_hash);\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            note_hash_read_requests: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_key_validation_requests: reader.read_struct_array(NullifierKeyValidationRequest::deserialize, [NullifierKeyValidationRequest::empty(); MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_stack_hashes: reader.read_array([0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            encrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            encrypted_log_preimages_length: reader.read(),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            chain_id: reader.read(),\n            version: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x2b5ba01a6b73b68b4f44196e2dea49afd4076333e2dee8eddc9186e080f18201;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr" }, "195": { "source": "use crate::{\n    address::AztecAddress, constants::{GENERATOR_INDEX__SIDE_EFFECT},\n    traits::{Empty, Hash, Serialize, Deserialize}\n};\nuse dep::std::cmp::Eq;\n\nglobal SIDE_EFFECT_SERIALIZED_LEN = 2;\n\ntrait Ordered {\n    fn counter(self) -> u32;\n}\n\ntrait OrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n}\n\ntrait ContractScopedOrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n    fn contract_address(self) -> AztecAddress;\n}\n\nstruct SideEffect {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffect {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffect {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffect {\n    fn eq(self, side_effect: SideEffect) -> bool {\n        (self.value == side_effect.value)\n        & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffect {\n    fn empty() -> Self {\n        SideEffect {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffect {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize() , GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn serialize(self) -> [Field; SIDE_EFFECT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn deserialize(values: [Field; SIDE_EFFECT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nstruct SideEffectLinkedToNoteHash{\n    value: Field,\n    note_hash: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffectLinkedToNoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffectLinkedToNoteHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffectLinkedToNoteHash {\n    fn eq(self, side_effect: SideEffectLinkedToNoteHash) -> bool {\n        (self.value == side_effect.value)\n            & (self.note_hash == side_effect.note_hash) \n            & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffectLinkedToNoteHash {\n    fn empty() -> Self {\n        SideEffectLinkedToNoteHash {\n            value: 0,\n            note_hash: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffectLinkedToNoteHash {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize(),\n        GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<3> for SideEffectLinkedToNoteHash {\n    fn serialize(self) -> [Field; 3] {\n        [self.value, self.note_hash, self.counter as Field]\n    }\n}\n\nimpl Deserialize<3> for SideEffectLinkedToNoteHash {\n    fn deserialize(values: [Field; 3]) -> Self {\n        Self {\n            value: values[0],\n            note_hash: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/side_effect.nr" }, "198": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::AztecAddress,\n    constants::{\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs{\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    prover_address: AztecAddress,\n\n    reverted: bool,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.reverted as Field);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            reverted: reader.read() as bool,\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x083ac560a513d670a7f50f0a3052d42cb9816b7b643e62025b8278652ad637ab;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr" }, "199": { "source": "use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u64 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr" }, "200": { "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<1> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<1> for U128 {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr" }, "201": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "202": { "source": "use crate::{\n    constants::{NUM_FIELDS_PER_SHA256, CONTENT_COMMITMENT_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::{arr_copy_slice}\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: [Field; NUM_FIELDS_PER_SHA256],\n  in_hash: [Field; NUM_FIELDS_PER_SHA256],\n  out_hash: [Field; NUM_FIELDS_PER_SHA256],\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array([self.tx_tree_height]);\n    fields.extend_from_array(self.txs_effects_hash);\n    fields.extend_from_array(self.in_hash);\n    fields.extend_from_array(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n    let mut offset = 1;\n\n    let txs_effects_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let in_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let out_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: [0; NUM_FIELDS_PER_SHA256],\n      in_hash: [0; NUM_FIELDS_PER_SHA256],\n      out_hash: [0; NUM_FIELDS_PER_SHA256],\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr" }, "209": { "source": "use crate::traits::{Serialize, Deserialize};\nuse dep::std::cmp::Eq;\n\nglobal GRUMPKIN_POINT_SERIALIZED_LEN: Field = 2;\n\nstruct GrumpkinPoint {\n    x: Field,\n    y: Field,\n}\n\nimpl Serialize<GRUMPKIN_POINT_SERIALIZED_LEN> for GrumpkinPoint {\n    fn serialize(self) -> [Field; GRUMPKIN_POINT_SERIALIZED_LEN] {\n        [self.x, self.y]\n    }\n}\n\nimpl Deserialize<GRUMPKIN_POINT_SERIALIZED_LEN> for GrumpkinPoint {\n    fn deserialize(serialized: [Field; GRUMPKIN_POINT_SERIALIZED_LEN]) -> Self {\n        Self {\n            x: serialized[0],\n            y: serialized[1],\n        }\n    }\n}\n\nimpl Eq for GrumpkinPoint {\n    fn eq(self, point: GrumpkinPoint) -> bool {\n        (point.x == self.x) & (point.y == self.y)\n    }\n}\n\nimpl GrumpkinPoint {\n    pub fn new(x: Field, y: Field) -> Self {\n        Self { x, y }\n    }\n\n    pub fn zero() -> Self {\n        Self { x: 0, y: 0 }\n    }\n\n    pub fn is_zero(self) -> bool {\n        (self.x == 0) & (self.y == 0)\n    }\n\n    // TODO(David): Would be quite careful here as (0,0) is not a point\n    // on the curve. A boolean flag may be the better approach here,\n    // would also cost less constraints. It seems like we don't need to \n    // group arithmetic either. \n    fn assert_is_zero(self) {\n        assert(self.x == 0);\n        assert(self.y == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/grumpkin_point.nr" }, "210": { "source": "use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state: StateReference = dep::std::unsafe::zeroed();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr" }, "211": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "241": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.owner.to_field(), self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "263": { "source": "// A contract used along with `Parent` contract to test nested calls.\ncontract Delegator {\n    use dep::aztec::prelude::{\n        AztecAddress, FunctionSelector, NoteHeader, NoteViewerOptions, emit_unencrypted_log,\n        PublicMutable, PrivateSet\n    };\n    use dep::value_note::value_note::ValueNote;\n\n    struct Storage {\n        current_value: PublicMutable<Field>,\n        a_private_value: PrivateSet<ValueNote>,\n    }\n\n    #[aztec(private)]\n    fn private_delegate_set_value(\n        targetContract: AztecAddress,\n        targetSelector: FunctionSelector,\n        args: [Field; 2]\n    ) {\n        // Call the target private function\n        let return_values = context.delegate_call_private_function(targetContract, targetSelector, args);\n        // Copy the return value from the call to this function's return values\n        return_values[0]\n    }\n\n    #[aztec(private)]\n    fn enqueued_delegate_set_value(\n        targetContract: AztecAddress,\n        targetSelector: FunctionSelector,\n        args: [Field; 1]\n    ) {\n        context.delegate_call_public_function(targetContract, targetSelector, args);\n    }\n\n    #[aztec(public)]\n    fn public_delegate_set_value(\n        targetContract: AztecAddress,\n        targetSelector: FunctionSelector,\n        args: [Field; 1]\n    ) {\n        let _ = context.delegate_call_public_function(targetContract, targetSelector, args);\n    }\n\n    unconstrained fn view_private_value(amount: Field, owner: AztecAddress) -> pub Field {\n        let options = NoteViewerOptions::new().select(ValueNote::properties().value, amount, Option::none()).select(\n            ValueNote::properties().owner,\n            owner.to_field(),\n            Option::none()\n        ).set_limit(1);\n        let notes = storage.a_private_value.view_notes(options);\n        notes[0].unwrap_unchecked().value\n    }\n\n    unconstrained fn view_public_value() -> pub Field {\n        storage.current_value.read()\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/delegator_contract/src/main.nr" } } }
